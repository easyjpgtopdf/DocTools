<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor - Professional Tools</title>
    <link rel="icon" type="image/png" href="images/favicon.png">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/footer.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --success: #4bb543;
            --danger: #dc3545;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7ff;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .editor-workspace {
            display: grid;
            grid-template-columns: 250px 1fr 320px;
            gap: 15px;
            flex: 1;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            min-height: 600px;
        }

        /* Left Panel - Tools */
        .tools-panel {
            border-right: 1px solid #e9ecef;
            padding-right: 15px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tool-group {
            margin-bottom: 20px;
        }

        .tool-group-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #6c757d;
            margin-bottom: 10px;
        }

        .tool-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #f8f9fa;
            border-color: var(--primary);
            transform: translateX(2px);
        }

        .tool-btn i {
            color: var(--primary);
            width: 18px;
        }

        .tool-message {
            text-align: center;
            padding: 30px 20px;
            color: #6c757d;
        }

        .tool-message i {
            font-size: 48px;
            color: var(--primary);
            margin-bottom: 15px;
            opacity: 0.6;
        }

        .tool-message h4 {
            color: #495057;
            margin: 10px 0;
            font-size: 1rem;
        }

        .tool-message p {
            font-size: 0.85rem;
            margin: 5px 0;
            line-height: 1.5;
        }

        #toolActions {
            padding: 15px;
            border-top: 1px solid #dee2e6;
            display: flex;
            gap: 10px;
        }

        #toolActions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        #toolActions button:first-child {
            background: var(--primary);
            color: white;
        }

        #toolActions button:first-child:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        #toolActions button:last-child {
            background: #6c757d;
            color: white;
        }

        #toolActions button:last-child:hover {
            background: #5a6268;
        }

        .tool-control {
            margin-bottom: 20px;
        }

        .tool-control label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
        }

        .tool-control input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .tool-control .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #6c757d;
            font-weight: 600;
        }

        .tool-control input[type="number"],
        .tool-control input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        /* Layers Panel (Photoshop-style) */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background 0.2s;
            gap: 8px;
        }

        .layer-item:hover {
            background: #f8f9fa;
        }

        .layer-item.active {
            background: #e7f3ff;
            border-left: 3px solid var(--primary);
        }

        .layer-visibility {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #6c757d;
            border-radius: 4px;
        }

        .layer-visibility:hover {
            background: #dee2e6;
            color: var(--primary);
        }

        .layer-preview {
            width: 40px;
            height: 40px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
            background: repeating-conic-gradient(#e9ecef 0% 25%, white 0% 50%) 50% / 8px 8px;
        }

        .layer-preview canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .layer-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .layer-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
        }

        .layer-opacity {
            font-size: 0.7rem;
            color: #6c757d;
        }

        .layer-blend {
            font-size: 0.7rem;
            color: #6c757d;
            padding: 2px 6px;
            background: #f8f9fa;
            border-radius: 3px;
        }

        /* Center Panel - Canvas */
        .canvas-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #fafbfc;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            overflow: auto;
            max-height: 672px; /* 7 inches at 96 DPI */
        }

        #editorCanvas {
            max-width: 100%;
            max-height: 672px; /* 7 inches maximum height */
            width: auto;
            height: auto;
            object-fit: contain;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            border-radius: 4px;
        }

        /* Right Panel - Properties */
        .properties-panel {
            border-left: 1px solid #e9ecef;
            padding-left: 15px;
            overflow-y: auto;
        }

        .prop-section {
            margin-bottom: 20px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .prop-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #495057;
        }

        .control-value {
            font-weight: 600;
            color: var(--primary);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .btn-apply {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--success) 0%, #38a832 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn-apply:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(75, 181, 67, 0.3);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .preset-option {
            padding: 8px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-option:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Action Buttons Below Canvas */
        .action-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            min-width: 140px;
            justify-content: center;
        }

        .action-btn i {
            font-size: 1.1rem;
        }

        .btn-preview {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
        }

        .btn-download {
            background: linear-gradient(135deg, var(--success) 0%, #38a832 100%);
            color: white;
        }

        .btn-reupload {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
        }

        .btn-share {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        /* Mobile Responsive */
        @media (max-width: 1024px) {
            .editor-workspace {
                grid-template-columns: 1fr;
                gap: 0;
            }

            .tools-panel, .properties-panel {
                border: none;
                padding: 0;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }

            .tools-panel.open {
                max-height: 400px;
                padding: 15px 0;
                margin-bottom: 15px;
            }

            .properties-panel.open {
                max-height: 500px;
                padding: 15px 0;
                margin-top: 15px;
            }

            .toggle-panel-btn {
                display: block;
                width: 100%;
                padding: 12px;
                background: var(--primary);
                color: white;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                margin-bottom: 10px;
                cursor: pointer;
            }

            .canvas-panel {
                order: -1;
            }
        }

        @media (min-width: 1025px) {
            .toggle-panel-btn {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .editor-container {
                padding: 10px;
            }

            .action-buttons {
                padding: 15px;
            }

            .action-btn {
                min-width: 120px;
                padding: 10px 16px;
                font-size: 0.85rem;
            }
        }

        .info-display {
            font-size: 0.8rem;
        }

        .info-display div {
            padding: 6px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .info-display div:last-child {
            border-bottom: none;
        }

        .color-picker-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Professional Toolbar */
        .professional-toolbar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            overflow: visible;
        }

        .toolbar-category {
            position: relative;
            z-index: 100;
        }
        
        .toolbar-category:hover {
            z-index: 10001;
        }

        .category-button {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.3s;
            white-space: nowrap;
            user-select: none;
        }

        .category-button:hover {
            background: rgba(255, 255, 255, 0.28);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .category-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        
        .toolbar-category.active .category-button {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .category-button i {
            font-size: 0.75rem;
        }

        .category-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 2px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            min-width: 220px;
            max-height: 450px;
            overflow-y: auto;
            z-index: 10000;
            padding: 8px;
            animation: slideDown 0.2s ease-out;
            pointer-events: auto;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toolbar-category:hover .category-dropdown,
        .toolbar-category.active .category-dropdown {
            display: block;
            pointer-events: auto;
        }
        
        .toolbar-category .category-dropdown:hover {
            display: block;
        }

        .tool-item-dropdown {
            width: 100%;
            padding: 10px 12px;
            background: white;
            border: none;
            border-radius: 6px;
            text-align: left;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            color: #333;
            margin-bottom: 3px;
            user-select: none;
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }

        .tool-item-dropdown:hover {
            background: linear-gradient(135deg, #f0f4ff 0%, #e3e8ff 100%);
            color: var(--primary);
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(67, 97, 238, 0.2);
        }
        
        .tool-item-dropdown:active {
            transform: translateX(2px) scale(0.98);
            background: linear-gradient(135deg, #e3e8ff 0%, #d4dbff 100%);
        }

        .tool-item-dropdown i {
            color: var(--primary);
            width: 18px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .professional-toolbar {
                padding: 10px;
                gap: 5px;
            }

            .category-button {
                padding: 8px 12px;
                font-size: 0.75rem;
            }

            .category-dropdown {
                min-width: 200px;
            }

            .tool-item-dropdown {
                padding: 8px 10px;
                font-size: 0.8rem;
            }
        }

        .color-picker-item {
            flex: 1;
        }

        .color-picker-item label {
            font-size: 0.75rem;
            display: block;
            margin-bottom: 5px;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <nav class="navbar">
                <a href="index.html" class="logo"><img src="images/logo.png" alt="Logo" style="height:54px;"></a>
                <div class="nav-links">
                    <div class="dropdown">
                        <a href="#">Convert to PDF <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="jpg-to-pdf.html">JPG to PDF</a>
                            <a href="word-to-pdf.html">Word to PDF</a>
                            <a href="excel-to-pdf.html">Excel to PDF</a>
                            <a href="ppt-to-pdf.html">PowerPoint to PDF</a>
                        </div>
                    </div>
                    <div class="dropdown">
                        <a href="#">Convert from PDF <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="pdf-to-jpg.html">PDF to JPG</a>
                            <a href="pdf-to-word.html">PDF to Word</a>
                            <a href="pdf-to-excel.html">PDF to Excel</a>
                            <a href="pdf-to-ppt.html">PDF to PowerPoint</a>
                        </div>
                    </div>
                    <div class="dropdown">
                        <a href="#">Pdf Editor <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="merge-pdf.html">Merge PDF</a>
                            <a href="split-pdf.html">Split PDF</a>
                            <a href="compress-pdf.html">Compress PDF</a>
                            <a href="edit-pdf.html">Pdf Editor</a>
                            <a href="protect-pdf.html">Protect PDF</a>
                            <a href="unlock-pdf.html">Unlock PDF</a>
                            <a href="watermark-pdf.html">Watermark PDF</a>
                            <a href="crop-pdf.html">Crop PDF</a>
                            <a href="add-page-numbers.html">Add Page Numbers</a>
                        </div>
                    </div>
                    <div class="dropdown">
                        <a href="#">Image Tools <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="image-repair.html">AI Image Repair</a>
                            <a href="image-compressor.html">Image Compressor</a>
                            <a href="image-resizer.html">Image Resizer</a>
                            <a href="image-editor.html">Image Editor</a>
                            <a href="background-remover.html">Image Background Remover</a>
                            <a href="ocr-image.html">OCR Image</a>
                            <a href="image-watermark.html">Image Watermark Tool</a>
                        </div>
                    </div>
                    <div class="dropdown">
                        <a href="#">Design Tools <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="resume-maker.html">Resume Maker</a>
                            <a href="biodata-maker.html">Marriage Biodata Maker</a>
                            <a href="ai-image-generator.html">AI Image Generator</a>
                            <a href="marriage-card.html">Marriage Card</a>
                        </div>
                    </div>
                    <div class="dropdown">
                        <a href="#">Other Tools <i class="fas fa-chevron-down"></i></a>
                        <div class="dropdown-content">
                            <a href="excel-unlocker.html">Excel Unlocker</a>
                            <a href="protect-excel.html">Protect Excel Sheet</a>
                        </div>
                    </div>
                </div>
                <div class="auth-buttons">
                    <a href="login.html" class="auth-link">Sign In</a>
                    <a href="signup.html" class="auth-btn"><i class="fas fa-user-plus"></i><span>Signup</span></a>
                </div>
                <div id="user-menu" class="user-menu" data-open="false">
                    <button id="user-menu-toggle" class="user-menu-toggle" type="button" aria-haspopup="true" aria-expanded="false" aria-label="Account menu">
                        <span class="user-initial" aria-hidden="true">U</span>
                        <i class="fas fa-chevron-down" aria-hidden="true"></i>
                    </button>
                    <div class="user-dropdown" id="user-dropdown" hidden>
                        <a href="dashboard.html#dashboard-overview"><i class="fas fa-user-circle"></i> Account Dashboard</a>
                        <a href="dashboard.html#dashboard-billing"><i class="fas fa-file-invoice"></i> Billing Details</a>
                        <a href="dashboard.html#dashboard-payments"><i class="fas fa-wallet"></i> Payment History</a>
                        <a href="dashboard.html#dashboard-orders"><i class="fas fa-clipboard-list"></i> Orders &amp; Subscriptions</a>
                        <a href="accounts.html#login"><i class="fas fa-user-cog"></i> Account Center</a>
                        <button type="button" id="logout-button" class="dropdown-logout"><i class="fas fa-sign-out-alt"></i> Sign out</button>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <!-- Editor Container -->
    <div class="editor-container">
        <!-- Professional Toolbar with Categories -->
        <div class="professional-toolbar">
            <!-- FILE & BASIC -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-file"></i> FILE
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="newImage()">
                        <i class="fas fa-plus-square"></i> New Image
                    </button>
                    <button class="tool-item-dropdown" onclick="openImage()">
                        <i class="fas fa-folder-open"></i> Open Image
                    </button>
                    <button class="tool-item-dropdown" onclick="saveImage()">
                        <i class="fas fa-save"></i> Save Image
                    </button>
                    <button class="tool-item-dropdown" onclick="exportAs()">
                        <i class="fas fa-file-export"></i> Export As
                    </button>
                    <button class="tool-item-dropdown" onclick="undoEdit()">
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="tool-item-dropdown" onclick="redoEdit()">
                        <i class="fas fa-redo"></i> Redo
                    </button>
                    <button class="tool-item-dropdown" onclick="resetToOriginal()">
                        <i class="fas fa-refresh"></i> Reset to Original
                    </button>
                    <button class="tool-item-dropdown" onclick="duplicateImage()">
                        <i class="fas fa-copy"></i> Duplicate Image
                    </button>
                    <button class="tool-item-dropdown" onclick="printImage()">
                        <i class="fas fa-print"></i> Print
                    </button>
                </div>
            </div>

            <!-- SELECTION -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-mouse-pointer"></i> SELECTION
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="rectangularSelection()">
                        <i class="far fa-square"></i> Rectangular Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="ellipticalSelection()">
                        <i class="far fa-circle"></i> Elliptical Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="lassoSelection()">
                        <i class="fas fa-draw-polygon"></i> Lasso Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="magicWand()">
                        <i class="fas fa-magic"></i> Magic Wand
                    </button>
                    <button class="tool-item-dropdown" onclick="quickSelection()">
                        <i class="fas fa-bolt"></i> Quick Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="selectAll()">
                        <i class="fas fa-border-all"></i> Select All
                    </button>
                    <button class="tool-item-dropdown" onclick="deselectAll()">
                        <i class="fas fa-times"></i> Deselect All
                    </button>
                    <button class="tool-item-dropdown" onclick="invertSelection()">
                        <i class="fas fa-exchange-alt"></i> Invert Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="expandSelection()">
                        <i class="fas fa-expand"></i> Expand Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="contractSelection()">
                        <i class="fas fa-compress"></i> Contract Selection
                    </button>
                </div>
            </div>

            <!-- CROP & TRANSFORM -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-crop"></i> TRANSFORM
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="cropImage()">
                        <i class="fas fa-crop-alt"></i> Crop
                    </button>
                    <button class="tool-item-dropdown" onclick="cropToSelection()">
                        <i class="fas fa-crop"></i> Crop to Selection
                    </button>
                    <button class="tool-item-dropdown" onclick="trimCanvas()">
                        <i class="fas fa-cut"></i> Trim Canvas
                    </button>
                    <button class="tool-item-dropdown" onclick="rotateRight()">
                        <i class="fas fa-redo"></i> Rotate 90° Right
                    </button>
                    <button class="tool-item-dropdown" onclick="rotateLeft()">
                        <i class="fas fa-undo"></i> Rotate 90° Left
                    </button>
                    <button class="tool-item-dropdown" onclick="rotate180()">
                        <i class="fas fa-sync"></i> Rotate 180°
                    </button>
                    <button class="tool-item-dropdown" onclick="customRotate()">
                        <i class="fas fa-spinner"></i> Custom Rotate
                    </button>
                    <button class="tool-item-dropdown" onclick="flipHorizontal()">
                        <i class="fas fa-arrows-alt-h"></i> Flip Horizontal
                    </button>
                    <button class="tool-item-dropdown" onclick="flipVertical()">
                        <i class="fas fa-arrows-alt-v"></i> Flip Vertical
                    </button>
                    <button class="tool-item-dropdown" onclick="resizeImage()">
                        <i class="fas fa-expand-arrows-alt"></i> Resize Image
                    </button>
                    <button class="tool-item-dropdown" onclick="scaleImage()">
                        <i class="fas fa-search-plus"></i> Scale Image
                    </button>
                    <button class="tool-item-dropdown" onclick="skewImage()">
                        <i class="fas fa-sliders-h"></i> Skew
                    </button>
                    <button class="tool-item-dropdown" onclick="perspectiveTransform()">
                        <i class="fas fa-cube"></i> Perspective
                    </button>
                </div>
            </div>

            <!-- BRUSH & PAINT -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-paint-brush"></i> BRUSH
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="brushTool()">
                        <i class="fas fa-brush"></i> Brush Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="pencilTool()">
                        <i class="fas fa-pencil-alt"></i> Pencil Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="eraserTool()">
                        <i class="fas fa-eraser"></i> Eraser Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="paintBucket()">
                        <i class="fas fa-fill-drip"></i> Paint Bucket
                    </button>
                    <button class="tool-item-dropdown" onclick="gradientTool()">
                        <i class="fas fa-palette"></i> Gradient Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="blurTool()">
                        <i class="fas fa-eye-slash"></i> Blur Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="sharpenTool()">
                        <i class="fas fa-adjust"></i> Sharpen Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="smudgeTool()">
                        <i class="fas fa-hand-paper"></i> Smudge Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="cloneStamp()">
                        <i class="fas fa-stamp"></i> Clone Stamp
                    </button>
                    <button class="tool-item-dropdown" onclick="healingBrush()">
                        <i class="fas fa-band-aid"></i> Healing Brush
                    </button>
                    <button class="tool-item-dropdown" onclick="dodgeTool()">
                        <i class="fas fa-sun"></i> Dodge (Lighten)
                    </button>
                    <button class="tool-item-dropdown" onclick="burnTool()">
                        <i class="fas fa-moon"></i> Burn (Darken)
                    </button>
                </div>
            </div>

            <!-- FILTERS & EFFECTS -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-filter"></i> FILTERS
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="applyFilter('grayscale')">
                        <i class="fas fa-adjust"></i> Grayscale
                    </button>
                    <button class="tool-item-dropdown" onclick="applyFilter('sepia')">
                        <i class="fas fa-image"></i> Sepia
                    </button>
                    <button class="tool-item-dropdown" onclick="applyFilter('invert')">
                        <i class="fas fa-exchange-alt"></i> Invert Colors
                    </button>
                    <button class="tool-item-dropdown" onclick="applyFilter('blur')">
                        <i class="fas fa-cloud"></i> Blur
                    </button>
                    <button class="tool-item-dropdown" onclick="sharpenFilter()">
                        <i class="fas fa-certificate"></i> Sharpen
                    </button>
                    <button class="tool-item-dropdown" onclick="edgeDetect()">
                        <i class="fas fa-border-style"></i> Edge Detect
                    </button>
                    <button class="tool-item-dropdown" onclick="embossFilter()">
                        <i class="fas fa-layer-group"></i> Emboss
                    </button>
                    <button class="tool-item-dropdown" onclick="pixelateFilter()">
                        <i class="fas fa-th"></i> Pixelate
                    </button>
                    <button class="tool-item-dropdown" onclick="posterizeFilter()">
                        <i class="fas fa-image"></i> Posterize
                    </button>
                    <button class="tool-item-dropdown" onclick="vignetteEffect()">
                        <i class="far fa-circle"></i> Vignette
                    </button>
                    <button class="tool-item-dropdown" onclick="presetEffect('vibrant')">
                        <i class="fas fa-star"></i> Vibrant
                    </button>
                    <button class="tool-item-dropdown" onclick="presetEffect('cool')">
                        <i class="fas fa-snowflake"></i> Cool
                    </button>
                    <button class="tool-item-dropdown" onclick="presetEffect('warm')">
                        <i class="fas fa-fire"></i> Warm
                    </button>
                    <button class="tool-item-dropdown" onclick="presetEffect('vintage')">
                        <i class="fas fa-clock"></i> Vintage
                    </button>
                </div>
            </div>

            <!-- ADJUSTMENTS -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-sliders-h"></i> ADJUST
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="brightnessContrast()">
                        <i class="fas fa-sun"></i> Brightness/Contrast
                    </button>
                    <button class="tool-item-dropdown" onclick="hueSaturation()">
                        <i class="fas fa-palette"></i> Hue/Saturation
                    </button>
                    <button class="tool-item-dropdown" onclick="colorBalance()">
                        <i class="fas fa-balance-scale"></i> Color Balance
                    </button>
                    <button class="tool-item-dropdown" onclick="levels()">
                        <i class="fas fa-chart-bar"></i> Levels
                    </button>
                    <button class="tool-item-dropdown" onclick="curves()">
                        <i class="fas fa-chart-line"></i> Curves
                    </button>
                    <button class="tool-item-dropdown" onclick="exposure()">
                        <i class="fas fa-camera"></i> Exposure
                    </button>
                    <button class="tool-item-dropdown" onclick="vibrance()">
                        <i class="fas fa-star"></i> Vibrance
                    </button>
                    <button class="tool-item-dropdown" onclick="autoAdjust()">
                        <i class="fas fa-magic"></i> Auto Adjust
                    </button>
                </div>
            </div>

            <!-- LAYERS & MASKS -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-layer-group"></i> LAYERS
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="newLayer()">
                        <i class="fas fa-plus-square"></i> New Layer
                    </button>
                    <button class="tool-item-dropdown" onclick="duplicateLayer()">
                        <i class="fas fa-copy"></i> Duplicate Layer
                    </button>
                    <button class="tool-item-dropdown" onclick="deleteLayer()">
                        <i class="fas fa-trash"></i> Delete Layer
                    </button>
                    <button class="tool-item-dropdown" onclick="mergeDown()">
                        <i class="fas fa-level-down-alt"></i> Merge Down
                    </button>
                    <button class="tool-item-dropdown" onclick="mergeVisible()">
                        <i class="fas fa-compress"></i> Merge Visible
                    </button>
                    <button class="tool-item-dropdown" onclick="flattenImage()">
                        <i class="fas fa-layer-group"></i> Flatten Image
                    </button>
                    <button class="tool-item-dropdown" onclick="layerOpacity()">
                        <i class="fas fa-adjust"></i> Layer Opacity
                    </button>
                    <button class="tool-item-dropdown" onclick="addLayerMask()">
                        <i class="fas fa-mask"></i> Add Layer Mask
                    </button>
                </div>
            </div>

            <!-- TEXT & SHAPES -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-font"></i> TEXT
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="addText()">
                        <i class="fas fa-text-height"></i> Text Tool
                    </button>
                    <button class="tool-item-dropdown" onclick="verticalText()">
                        <i class="fas fa-text-width"></i> Vertical Text
                    </button>
                    <button class="tool-item-dropdown" onclick="addRectangle()">
                        <i class="fas fa-square"></i> Rectangle
                    </button>
                    <button class="tool-item-dropdown" onclick="addCircle()">
                        <i class="fas fa-circle"></i> Circle/Ellipse
                    </button>
                    <button class="tool-item-dropdown" onclick="addLine()">
                        <i class="fas fa-minus"></i> Line
                    </button>
                    <button class="tool-item-dropdown" onclick="addArrow()">
                        <i class="fas fa-arrow-right"></i> Arrow
                    </button>
                    <button class="tool-item-dropdown" onclick="addPolygon()">
                        <i class="fas fa-draw-polygon"></i> Polygon
                    </button>
                    <button class="tool-item-dropdown" onclick="addStar()">
                        <i class="fas fa-star"></i> Star
                    </button>
                </div>
            </div>

            <!-- AI TOOLS -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-robot"></i> AI
                </button>
                <div class="category-dropdown" style="max-width: 280px; columns: 2; column-gap: 5px;">
                    <!-- Background AI Tools -->
                    <button class="tool-item-dropdown" onclick="removeBackground()" title="Remove Background">
                        <i class="fas fa-user-slash"></i> Remove BG
                    </button>
                    <button class="tool-item-dropdown" onclick="changeBackground()" title="Change Background">
                        <i class="fas fa-image"></i> Change BG
                    </button>
                    <button class="tool-item-dropdown" onclick="addBackgroundDesign()" title="Add Background Design">
                        <i class="fas fa-paint-brush"></i> BG Design
                    </button>
                    <button class="tool-item-dropdown" onclick="blurBackground()" title="Blur Background">
                        <i class="fas fa-cloud"></i> Blur BG
                    </button>
                    <button class="tool-item-dropdown" onclick="replaceBackground()" title="Replace Background with Image">
                        <i class="fas fa-copy"></i> Replace BG
                    </button>
                    
                    <!-- Enhancement Tools -->
                    <button class="tool-item-dropdown" onclick="enhancePhoto()" title="AI Enhance Photo">
                        <i class="fas fa-magic"></i> Enhance
                    </button>
                    <button class="tool-item-dropdown" onclick="autoColorCorrect()" title="Auto Color Correction">
                        <i class="fas fa-palette"></i> Auto Color
                    </button>
                    <button class="tool-item-dropdown" onclick="denoisePic()" title="Reduce Noise">
                        <i class="fas fa-broom"></i> Denoise
                    </button>
                    <button class="tool-item-dropdown" onclick="sharpenAI()" title="AI Sharpening">
                        <i class="fas fa-star"></i> Sharpen AI
                    </button>
                    <button class="tool-item-dropdown" onclick="hdrEffect()" title="HDR Effect">
                        <i class="fas fa-sun"></i> HDR
                    </button>
                    
                    <!-- Quality & Resolution -->
                    <button class="tool-item-dropdown" onclick="upscaleImage()" title="Upscale Quality">
                        <i class="fas fa-search-plus"></i> Upscale
                    </button>
                    <button class="tool-item-dropdown" onclick="superResolution()" title="Super Resolution 4K">
                        <i class="fas fa-expand"></i> 4K Upscale
                    </button>
                    <button class="tool-item-dropdown" onclick="deblurImage()" title="Remove Blur">
                        <i class="fas fa-eye"></i> Deblur
                    </button>
                    <button class="tool-item-dropdown" onclick="enhanceDetails()" title="Enhance Details">
                        <i class="fas fa-microscope"></i> Details
                    </button>
                    
                    <!-- Restoration Tools -->
                    <button class="tool-item-dropdown" onclick="restorePhoto()" title="Restore Old Photo">
                        <i class="fas fa-hammer"></i> Restore
                    </button>
                    <button class="tool-item-dropdown" onclick="removeScratch()" title="Remove Scratches">
                        <i class="fas fa-band-aid"></i> Fix Scratch
                    </button>
                    <button class="tool-item-dropdown" onclick="colorizePhoto()" title="Colorize B&W">
                        <i class="fas fa-fill-drip"></i> Colorize
                    </button>
                    <button class="tool-item-dropdown" onclick="faceRestore()" title="Restore Face Details">
                        <i class="fas fa-user"></i> Face Fix
                    </button>
                    
                    <!-- Object Manipulation -->
                    <button class="tool-item-dropdown" onclick="removeObject()" title="Remove Object">
                        <i class="fas fa-eraser"></i> Remove Obj
                    </button>
                    <button class="tool-item-dropdown" onclick="removeWatermark()" title="Remove Watermark">
                        <i class="fas fa-trademark"></i> Remove WM
                    </button>
                    <button class="tool-item-dropdown" onclick="removePeople()" title="Remove People">
                        <i class="fas fa-user-times"></i> Remove PPL
                    </button>
                    <button class="tool-item-dropdown" onclick="cloneObject()" title="Clone & Duplicate Object">
                        <i class="fas fa-clone"></i> Clone
                    </button>
                    
                    <!-- Portrait Tools -->
                    <button class="tool-item-dropdown" onclick="portraitEnhance()" title="Portrait Enhancement">
                        <i class="fas fa-user-circle"></i> Portrait
                    </button>
                    <button class="tool-item-dropdown" onclick="faceDetection()" title="Face Detection & Recognition">
                        <i class="fas fa-face-smile"></i> Face Detect
                    </button>
                    <!-- Portrait & Face Tools -->
                    <button class="tool-item-dropdown" onclick="advancedFaceDetection()" title="Advanced Face Detection">
                        <i class="fas fa-user-check"></i> Detect Faces
                    </button>
                    <button class="tool-item-dropdown" onclick="advancedFaceBlur()" title="Advanced Face Blur">
                        <i class="fas fa-user-secret"></i> Blur Faces
                    </button>
                    <button class="tool-item-dropdown" onclick="skinSmooth()" title="Skin Smoothing">
                        <i class="fas fa-spa"></i> Smooth
                    </button>
                    <button class="tool-item-dropdown" onclick="eyeEnhance()" title="Eye Enhancement">
                        <i class="fas fa-eye"></i> Eyes
                    </button>
                    <button class="tool-item-dropdown" onclick="teethWhiten()" title="Teeth Whitening">
                        <i class="fas fa-tooth"></i> Teeth
                    </button>
                    <button class="tool-item-dropdown" onclick="beautifyFace()" title="Face Beautify">
                        <i class="fas fa-smile"></i> Beautify
                    </button>
                    
                    <!-- Advanced Repair Tools -->
                    <button class="tool-item-dropdown" onclick="advancedPhotoRepair()" title="Advanced Photo Repair & Restoration">
                        <i class="fas fa-toolbox"></i> AI Repair
                    </button>
                    <button class="tool-item-dropdown" onclick="advancedNoiseRemoval()" title="Advanced Noise Removal">
                        <i class="fas fa-broom"></i> Denoise
                    </button>
                    <button class="tool-item-dropdown" onclick="perspectiveCorrection()" title="Fix Perspective/Skew (Tedhe Ko Barabar)">
                        <i class="fas fa-ruler-combined"></i> Perspective
                    </button>
                    <button class="tool-item-dropdown" onclick="autoStraighten()" title="Auto Straighten Image">
                        <i class="fas fa-level"></i> Straighten
                    </button>
                    
                    <!-- Lighting & Exposure -->
                    <button class="tool-item-dropdown" onclick="autoExposure()" title="Auto Exposure Fix">
                        <i class="fas fa-lightbulb"></i> Exposure
                    </button>
                    <button class="tool-item-dropdown" onclick="shadowRecovery()" title="Recover Shadows">
                        <i class="fas fa-adjust"></i> Shadows
                    </button>
                    <button class="tool-item-dropdown" onclick="highlightFix()" title="Fix Highlights">
                        <i class="fas fa-sun"></i> Highlights
                    </button>
                    <button class="tool-item-dropdown" onclick="lowLightBoost()" title="Low Light Enhancement">
                        <i class="fas fa-moon"></i> Low Light
                    </button>
                    
                    <!-- Style Transfer -->
                    <button class="tool-item-dropdown" onclick="artisticStyle()" title="Artistic Style Transfer">
                        <i class="fas fa-paint-roller"></i> Artistic
                    </button>
                    <button class="tool-item-dropdown" onclick="cartoonize()" title="Cartoonize Photo">
                        <i class="fas fa-smile-wink"></i> Cartoon
                    </button>
                    <button class="tool-item-dropdown" onclick="sketchEffect()" title="Sketch Effect">
                        <i class="fas fa-pencil-alt"></i> Sketch
                    </button>
                    <button class="tool-item-dropdown" onclick="oilPainting()" title="Oil Painting Effect">
                        <i class="fas fa-brush"></i> Oil Paint
                    </button>
                    <button class="tool-item-dropdown" onclick="watercolor()" title="Watercolor Effect">
                        <i class="fas fa-tint"></i> Watercolor
                    </button>
                    
                    <!-- Sky & Scene -->
                    <button class="tool-item-dropdown" onclick="skyReplacement()" title="Replace Sky">
                        <i class="fas fa-cloud-sun"></i> Sky
                    </button>
                    <button class="tool-item-dropdown" onclick="weatherChange()" title="Change Weather">
                        <i class="fas fa-cloud-rain"></i> Weather
                    </button>
                    <button class="tool-item-dropdown" onclick="seasonChange()" title="Change Season">
                        <i class="fas fa-snowflake"></i> Season
                    </button>
                    <button class="tool-item-dropdown" onclick="dayToNight()" title="Day to Night">
                        <i class="fas fa-moon"></i> Day/Night
                    </button>
                    
                    <!-- Effects & Filters -->
                    <button class="tool-item-dropdown" onclick="vintageLook()" title="Vintage Film Look">
                        <i class="fas fa-film"></i> Vintage
                    </button>
                    <button class="tool-item-dropdown" onclick="glowEffect()" title="Glow Effect">
                        <i class="fas fa-star"></i> Glow
                    </button>
                    <button class="tool-item-dropdown" onclick="bokehEffect()" title="Bokeh Effect">
                        <i class="fas fa-circle"></i> Bokeh
                    </button>
                    <button class="tool-item-dropdown" onclick="cinematicLook()" title="Cinematic Color Grade">
                        <i class="fas fa-video"></i> Cinematic
                    </button>
                    
                    <!-- Smart Tools -->
                    <button class="tool-item-dropdown" onclick="smartCrop()" title="AI Smart Crop">
                        <i class="fas fa-crop"></i> Smart Crop
                    </button>
                    <button class="tool-item-dropdown" onclick="autoStraighten()" title="Auto Straighten">
                        <i class="fas fa-level-up-alt"></i> Straighten
                    </button>
                    <button class="tool-item-dropdown" onclick="perspectiveFix()" title="Fix Perspective">
                        <i class="fas fa-cube"></i> Perspective
                    </button>
                    <button class="tool-item-dropdown" onclick="redEyeRemoval()" title="Red Eye Removal">
                        <i class="fas fa-eye-slash"></i> Red Eye
                    </button>
                    
                    <!-- Advanced AI -->
                    <button class="tool-item-dropdown" onclick="depthMap()" title="Generate Depth Map">
                        <i class="fas fa-layer-group"></i> Depth
                    </button>
                    <button class="tool-item-dropdown" onclick="edgeDetectAI()" title="AI Edge Detection">
                        <i class="fas fa-border-style"></i> Edges
                    </button>
                    <button class="tool-item-dropdown" onclick="imageToImage()" title="Image to Image AI">
                        <i class="fas fa-exchange-alt"></i> Img2Img
                    </button>
                    <button class="tool-item-dropdown" onclick="inpaintAI()" title="AI Inpainting">
                        <i class="fas fa-fill"></i> Inpaint
                    </button>
                </div>
            </div>

            <!-- IMAGE UTILITIES -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-cog"></i> UTILITIES
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="compressImage()">
                        <i class="fas fa-compress"></i> Compress Image
                    </button>
                    <button class="tool-item-dropdown" onclick="resizeImage()">
                        <i class="fas fa-expand-arrows-alt"></i> Resize Image
                    </button>
                    <button class="tool-item-dropdown" onclick="cropImage()">
                        <i class="fas fa-crop-alt"></i> Crop Image
                    </button>
                    <button class="tool-item-dropdown" onclick="convertFormat()">
                        <i class="fas fa-file-image"></i> Convert Format
                    </button>
                </div>
            </div>

            <!-- QUICK ACTIONS -->
            <div class="toolbar-category">
                <button class="category-button">
                    <i class="fas fa-bolt"></i> QUICK
                </button>
                <div class="category-dropdown">
                    <button class="tool-item-dropdown" onclick="undoEdit()">
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="tool-item-dropdown" onclick="redoEdit()">
                        <i class="fas fa-redo"></i> Redo
                    </button>
                    <button class="tool-item-dropdown" onclick="saveImage()">
                        <i class="fas fa-save"></i> Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Mobile Toggle Buttons -->
        <button class="toggle-panel-btn" onclick="toggleToolsPanel()">
            <i class="fas fa-tools"></i> Toggle Tools Panel
        </button>

        <!-- 3-Panel Editor Workspace -->
        <div class="editor-workspace">
            <!-- Left Panel - Tools -->
            <div class="tools-panel" id="toolsPanel">
                <div class="panel-title">
                    <i class="fas fa-toolbox"></i>
                    <span id="toolPanelTitle">Tool Controls</span>
                </div>
                
                <!-- Dynamic Tool Settings Container -->
                <div id="toolSettings" style="padding: 15px;">
                    <!-- Default State -->
                    <div id="defaultToolMessage" class="tool-message">
                        <i class="fas fa-hand-pointer" style="font-size: 2.5rem; color: #667eea; margin-bottom: 15px;"></i>
                        <h4 style="color: #333; margin-bottom: 10px;">Select a Tool</h4>
                        <p style="font-size: 0.85rem; color: #6c757d; line-height: 1.6;">
                            Click any tool from the toolbar above to see its controls here.
                        </p>
                        <p style="font-size: 0.75rem; color: #999; margin-top: 10px;">
                            ✨ Live preview will show in the center canvas
                        </p>
                    </div>
                    
                    <!-- Tool Controls will be injected here dynamically -->
                </div>
                
                <!-- Preview & Apply Buttons -->
                <div id="toolActions" style="padding: 15px; display: none; border-top: 2px solid #e9ecef;">
                    <button onclick="applyToolChanges()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #4bb543 0%, #38a832 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">
                        <i class="fas fa-check"></i> Apply Changes
                    </button>
                    <button onclick="cancelToolChanges()" style="width: 100%; padding: 10px; background: #6c757d; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>

            <!-- Center Panel - Canvas -->
            <div class="canvas-panel">
                <canvas id="editorCanvas"></canvas>
            </div>

            <!-- Right Panel - Properties -->
            <div class="properties-panel" id="propertiesPanel">
                <div class="panel-title">
                    <i class="fas fa-sliders-h"></i>
                    Properties
                </div>

                <!-- Color Pickers -->
                <div class="prop-section">
                    <div class="prop-section-title">
                        <i class="fas fa-palette"></i>
                        Colors
                    </div>
                    <div class="color-picker-group">
                        <div class="color-picker-item">
                            <label>Foreground</label>
                            <input type="color" id="fgColor" value="#000000">
                        </div>
                        <div class="color-picker-item">
                            <label>Background</label>
                            <input type="color" id="bgColor" value="#ffffff">
                        </div>
                    </div>
                </div>

                <!-- Adjustments -->
                <div class="prop-section">
                    <div class="prop-section-title">
                        <i class="fas fa-adjust"></i>
                        Adjustments
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            <span>Brightness</span>
                            <span class="control-value" id="brightnessVal">0</span>
                        </label>
                        <input type="range" id="brightnessRange" min="-100" max="100" value="0" oninput="livePreview()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            <span>Contrast</span>
                            <span class="control-value" id="contrastVal">0</span>
                        </label>
                        <input type="range" id="contrastRange" min="-100" max="100" value="0" oninput="livePreview()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            <span>Saturation</span>
                            <span class="control-value" id="saturationVal">100</span>
                        </label>
                        <input type="range" id="saturationRange" min="0" max="200" value="100" oninput="livePreview()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            <span>Opacity</span>
                            <span class="control-value" id="opacityVal">100</span>%
                        </label>
                        <input type="range" id="opacityRange" min="0" max="100" value="100" oninput="livePreview()">
                    </div>
                    <button class="btn-apply" onclick="applyChanges()">
                        <i class="fas fa-check"></i> Apply Changes
                    </button>
                </div>

                <!-- Image Info -->
                <div class="prop-section">
                    <div class="prop-section-title">
                        <i class="fas fa-info-circle"></i>
                        Image Info
                    </div>
                    <div class="info-display">
                        <div><strong>Dimensions:</strong> <span id="imgDimensions">-</span></div>
                        <div><strong>File Size:</strong> <span id="imgSize">-</span></div>
                        <div><strong>Format:</strong> <span id="imgFormat">PNG</span></div>
                    </div>
                </div>

                <!-- Live Tool Info (Photoshop-style) -->
                <div class="prop-section" id="liveToolInfo" style="display: none;">
                    <div class="prop-section-title">
                        <i class="fas fa-crosshairs"></i>
                        <span id="toolInfoTitle">Tool Info</span>
                    </div>
                    <div class="info-display">
                        <div><strong>X:</strong> <span id="toolX">0</span> px</div>
                        <div><strong>Y:</strong> <span id="toolY">0</span> px</div>
                        <div><strong>Width:</strong> <span id="toolW">0</span> px</div>
                        <div><strong>Height:</strong> <span id="toolH">0</span> px</div>
                        <div id="toolRatioInfo" style="display: none;"><strong>Ratio:</strong> <span id="toolRatio">-</span></div>
                        <div id="toolAngleInfo" style="display: none;"><strong>Angle:</strong> <span id="toolAngle">0</span>°</div>
                    </div>
                </div>

                <!-- Selection Info -->
                <div class="prop-section" id="selectionInfo" style="display: none;">
                    <div class="prop-section-title">
                        <i class="fas fa-vector-square"></i>
                        Selection
                    </div>
                    <div class="info-display">
                        <div><strong>Area:</strong> <span id="selectionArea">0</span> px²</div>
                        <div><strong>Perimeter:</strong> <span id="selectionPerimeter">0</span> px</div>
                    </div>
                    <button class="btn-apply" onclick="cropToSelection()" style="margin-top: 10px;">
                        <i class="fas fa-crop"></i> Crop to Selection
                    </button>
                    <button class="btn-apply" onclick="clearSelection()" style="margin-top: 5px; background: #dc3545;">
                        <i class="fas fa-times"></i> Clear Selection
                    </button>
                </div>

                <!-- Layers Panel (Photoshop-style) -->
                <div class="prop-section" id="layersPanelSection">
                    <div class="prop-section-title">
                        <i class="fas fa-layer-group"></i>
                        Layers
                    </div>
                    
                    <!-- Layer Controls -->
                    <div style="display: flex; gap: 5px; margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                        <button onclick="createLayer('New Layer', canvas.width, canvas.height)" style="flex: 1; padding: 6px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 0.75rem;" title="New Layer">
                            <i class="fas fa-plus"></i>
                        </button>
                        <button onclick="duplicateLayer(activeLayer?.id)" style="flex: 1; padding: 6px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 0.75rem;" title="Duplicate Layer">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button onclick="deleteLayer(activeLayer?.id)" style="flex: 1; padding: 6px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 0.75rem;" title="Delete Layer">
                            <i class="fas fa-trash"></i>
                        </button>
                        <button onclick="mergeDown(activeLayer?.id)" style="flex: 1; padding: 6px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 0.75rem;" title="Merge Down">
                            <i class="fas fa-compress-arrows-alt"></i>
                        </button>
                    </div>
                    
                    <!-- Layers List -->
                    <div id="layersPanel" style="max-height: 300px; overflow-y: auto; background: #ffffff; border: 1px solid #dee2e6; border-radius: 4px;">
                        <!-- Layers will be populated here -->
                    </div>
                    
                    <!-- Active Layer Controls -->
                    <div id="activeLayerControls" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; display: none;">
                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 0.8rem; font-weight: 600; color: #495057; display: block; margin-bottom: 4px;">Opacity</label>
                            <input type="range" id="layerOpacity" min="0" max="100" value="100" oninput="updateLayerOpacity(this.value)" style="width: 100%;">
                            <span id="layerOpacityValue" style="font-size: 0.75rem; color: #6c757d;">100%</span>
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600; color: #495057; display: block; margin-bottom: 4px;">Blend Mode</label>
                            <select id="layerBlendMode" onchange="updateLayerBlendMode(this.value)" style="width: 100%; padding: 6px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.8rem;">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="screen">Screen</option>
                                <option value="overlay">Overlay</option>
                                <option value="darken">Darken</option>
                                <option value="lighten">Lighten</option>
                                <option value="color-dodge">Color Dodge</option>
                                <option value="color-burn">Color Burn</option>
                                <option value="hard-light">Hard Light</option>
                                <option value="soft-light">Soft Light</option>
                                <option value="difference">Difference</option>
                                <option value="exclusion">Exclusion</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Overlay for Interactive Tools (Photoshop-style) -->
        <div id="canvasOverlay" style="position: absolute; top: 0; left: 0; pointer-events: none; display: none;">
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Tool Cursor Indicator -->
        <div id="toolCursor" style="position: absolute; pointer-events: none; display: none; z-index: 10000;">
            <div style="width: 20px; height: 20px; border: 2px solid #fff; border-radius: 50%; box-shadow: 0 0 10px rgba(0,0,0,0.5);"></div>
        </div>

        <!-- Crop Handles (Photoshop-style) -->
        <div id="cropOverlay" style="position: absolute; display: none; border: 2px dashed #fff; box-shadow: 0 0 0 9999px rgba(0,0,0,0.5); cursor: move;">
            <div class="crop-handle" data-position="nw" style="position: absolute; top: -5px; left: -5px; width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: nw-resize;"></div>
            <div class="crop-handle" data-position="ne" style="position: absolute; top: -5px; right: -5px; width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: ne-resize;"></div>
            <div class="crop-handle" data-position="sw" style="position: absolute; bottom: -5px; left: -5px; width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: sw-resize;"></div>
            <div class="crop-handle" data-position="se" style="position: absolute; bottom: -5px; right: -5px; width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: se-resize;"></div>
            <div class="crop-handle" data-position="n" style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: n-resize;"></div>
            <div class="crop-handle" data-position="s" style="position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: s-resize;"></div>
            <div class="crop-handle" data-position="e" style="position: absolute; top: 50%; right: -5px; transform: translateY(-50%); width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: e-resize;"></div>
            <div class="crop-handle" data-position="w" style="position: absolute; top: 50%; left: -5px; transform: translateY(-50%); width: 10px; height: 10px; background: #fff; border: 2px solid #4bb543; cursor: w-resize;"></div>
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 0.8rem; text-shadow: 0 0 5px rgba(0,0,0,0.8); pointer-events: none;">
                <span id="cropDimensions"></span>
            </div>
        </div>

        <!-- Selection Marquee (Photoshop-style animated border) -->
        <div id="selectionMarquee" style="position: absolute; display: none; border: 1px dashed #fff; pointer-events: none; animation: marchingAnts 0.5s linear infinite;">
            <style>
                @keyframes marchingAnts {
                    0% { border-color: #fff; }
                    50% { border-color: #000; }
                    100% { border-color: #fff; }
                }
            </style>
        </div>

        <!-- Mobile Toggle Buttons -->
        <button class="mobile-toggle left" onclick="toggleToolsPanel()">
            <i class="fas fa-tools"></i>
        </button>
        <button class="mobile-toggle right" onclick="togglePropertiesPanel()">
            <i class="fas fa-sliders-h"></i>
        </button>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; z-index: 999999; align-items: center; justify-content: center;">
            <div style="text-align: center; color: white;">
                <div class="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #4bb543; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                <h3 id="loadingMessage" style="font-size: 1.2rem; margin: 0;">Processing...</h3>
                <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">Please wait while we work on your image</p>
            </div>
            <style>
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            </style>
        </div>
    </div>

    <script>
        let canvas, ctx, currentImageData, editorHistory = [], historyIndex = -1;
        let isDrawing = false, lastX = 0, lastY = 0;
        let currentTool = null, brushSize = 5, brushColor = '#000000';
        
        // Professional Interactive Tool State
        let activeCropBox = null;
        let activeSelection = null;
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let cropResizeHandle = null;
        let cropStartX = 0, cropStartY = 0;
        let overlayCanvas, overlayCtx;
        let mouseX = 0, mouseY = 0;
        
        // Photoshop-style Multi-Layer System
        let layers = [];
        let activeLayer = null;
        let layerIdCounter = 0;
        let blendModes = ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion'];
        
        // Adjustment Layers (Non-destructive)
        let adjustmentLayers = [];
        
        // Cloud Run Configuration
        const CLOUD_RUN_ENDPOINTS = {
            rembg: 'https://rembg-service-XXXXX.run.app/remove',
            upscale: 'https://upscale-service-XXXXX.run.app/process',
            enhance: 'https://enhance-service-XXXXX.run.app/process',
            style_transfer: 'https://style-service-XXXXX.run.app/process',
            face_detect: 'https://face-detect-XXXXX.run.app/detect',
            face_blur: 'https://face-blur-XXXXX.run.app/blur',
            photo_repair: 'https://photo-repair-XXXXX.run.app/repair',
            perspective: 'https://perspective-XXXXX.run.app/correct'
        };
        
        // Loading overlay helpers
        function showLoadingOverlay(message = 'Processing...') {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingMessage').textContent = message;
        }
        
        function hideLoadingOverlay() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        
        // Layer Management (Photoshop-style)
        function createLayer(name = 'Layer', width = 800, height = 600) {
            const layer = {
                id: ++layerIdCounter,
                name: name,
                canvas: document.createElement('canvas'),
                visible: true,
                opacity: 100,
                blendMode: 'normal',
                locked: false,
                type: 'raster' // raster, adjustment, text, shape
            };
            
            layer.canvas.width = width;
            layer.canvas.height = height;
            layer.ctx = layer.canvas.getContext('2d', { willReadFrequently: true });
            
            layers.push(layer);
            activeLayer = layer;
            updateLayersPanel();
            return layer;
        }
        
        function addLayerFromImage(img, name = 'New Layer') {
            const layer = createLayer(name, img.width, img.height);
            layer.ctx.drawImage(img, 0, 0);
            compositeAllLayers();
            saveToHistory();
            return layer;
        }
        
        function deleteLayer(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index > -1 && layers.length > 1) {
                layers.splice(index, 1);
                if (activeLayer && activeLayer.id === layerId) {
                    activeLayer = layers[layers.length - 1];
                }
                updateLayersPanel();
                compositeAllLayers();
            }
        }
        
        function duplicateLayer(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                const newLayer = createLayer(layer.name + ' copy', layer.canvas.width, layer.canvas.height);
                newLayer.ctx.drawImage(layer.canvas, 0, 0);
                newLayer.opacity = layer.opacity;
                newLayer.blendMode = layer.blendMode;
                compositeAllLayers();
            }
        }
        
        function mergeDown(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index > 0) {
                const upperLayer = layers[index];
                const lowerLayer = layers[index - 1];
                
                lowerLayer.ctx.globalAlpha = upperLayer.opacity / 100;
                lowerLayer.ctx.globalCompositeOperation = upperLayer.blendMode;
                lowerLayer.ctx.drawImage(upperLayer.canvas, 0, 0);
                lowerLayer.ctx.globalAlpha = 1;
                lowerLayer.ctx.globalCompositeOperation = 'source-over';
                
                layers.splice(index, 1);
                updateLayersPanel();
                compositeAllLayers();
            }
        }
        
        function compositeAllLayers() {
            // Clear main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Composite all visible layers
            layers.forEach(layer => {
                if (layer.visible) {
                    ctx.globalAlpha = layer.opacity / 100;
                    ctx.globalCompositeOperation = layer.blendMode;
                    ctx.drawImage(layer.canvas, 0, 0);
                }
            });
            
            // Reset composite settings
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function updateLayersPanel() {
            // Update layers panel HTML (will be implemented in UI)
            const layersHTML = layers.map((layer, index) => `
                <div class="layer-item ${layer.id === activeLayer?.id ? 'active' : ''}" onclick="selectLayer(${layer.id})">
                    <div class="layer-visibility" onclick="toggleLayerVisibility(${layer.id}, event)">
                        <i class="fas ${layer.visible ? 'fa-eye' : 'fa-eye-slash'}"></i>
                    </div>
                    <div class="layer-preview">
                        <canvas id="layer-thumb-${layer.id}" width="40" height="40"></canvas>
                    </div>
                    <div class="layer-info">
                        <span class="layer-name">${layer.name}</span>
                        <span class="layer-opacity">${layer.opacity}%</span>
                    </div>
                    <div class="layer-blend">${layer.blendMode}</div>
                </div>
            `).reverse().join('');
            
            // Will be injected into layers panel
            if (document.getElementById('layersPanel')) {
                document.getElementById('layersPanel').innerHTML = layersHTML;
            }
        }
        
        function selectLayer(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                activeLayer = layer;
                canvas = layer.canvas;
                ctx = layer.ctx;
                updateLayersPanel();
            }
        }
        
        function toggleLayerVisibility(layerId, event) {
            event.stopPropagation();
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                layer.visible = !layer.visible;
                updateLayersPanel();
                compositeAllLayers();
            }
        }
        
        function updateLayerOpacity(value) {
            if (activeLayer) {
                activeLayer.opacity = parseInt(value);
                document.getElementById('layerOpacityValue').textContent = value + '%';
                compositeAllLayers();
            }
        }
        
        function updateLayerBlendMode(mode) {
            if (activeLayer) {
                activeLayer.blendMode = mode;
                compositeAllLayers();
            }
        }
        
        function renameLayer(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                const newName = prompt('Rename layer:', layer.name);
                if (newName && newName.trim()) {
                    layer.name = newName.trim();
                    updateLayersPanel();
                }
            }
        }
        
        function moveLayerUp(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index < layers.length - 1) {
                [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
                updateLayersPanel();
                compositeAllLayers();
            }
        }
        
        function moveLayerDown(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index > 0) {
                [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
                updateLayersPanel();
                compositeAllLayers();
            }
        }

        // Removed duplicate DOMContentLoaded - merged with image load listener below

        function initializeInteractiveTools() {
            const canvasPanel = document.querySelector('.canvas-panel');
            
            // Track mouse position for live cursor
            canvasPanel.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Update live tool info in right panel
                updateLiveToolInfo(mouseX, mouseY);
                
                // Handle crop box dragging/resizing
                if (activeCropBox && (isDraggingCrop || isResizingCrop)) {
                    handleCropDragResize(e);
                }
            });
            
            canvasPanel.addEventListener('mousedown', function(e) {
                if (currentTool === 'crop' && !activeCropBox) {
                    startCropSelection(e);
                } else if (activeCropBox) {
                    checkCropHandleClick(e);
                }
            });
            
            canvasPanel.addEventListener('mouseup', function(e) {
                isDraggingCrop = false;
                isResizingCrop = false;
                cropResizeHandle = null;
            });
        }

        function updateLiveToolInfo(x, y) {
            document.getElementById('toolX').textContent = Math.round(x);
            document.getElementById('toolY').textContent = Math.round(y);
            
            if (activeCropBox) {
                const w = activeCropBox.width;
                const h = activeCropBox.height;
                document.getElementById('toolW').textContent = Math.round(w);
                document.getElementById('toolH').textContent = Math.round(h);
                document.getElementById('toolRatio').textContent = (w / h).toFixed(2);
                document.getElementById('liveToolInfo').style.display = 'block';
                document.getElementById('toolRatioInfo').style.display = 'block';
                
                // Update crop overlay dimensions
                document.getElementById('cropDimensions').textContent = `${Math.round(w)} × ${Math.round(h)} px`;
            }
        }

        function startCropSelection(e) {
            const rect = canvas.getBoundingClientRect();
            cropStartX = e.clientX - rect.left;
            cropStartY = e.clientY - rect.top;
            
            activeCropBox = {
                x: cropStartX,
                y: cropStartY,
                width: 0,
                height: 0
            };
            
            const cropOverlay = document.getElementById('cropOverlay');
            cropOverlay.style.display = 'block';
            
            isDraggingCrop = true;
        }

        function handleCropDragResize(e) {
            if (!activeCropBox) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            if (isResizingCrop && cropResizeHandle) {
                resizeCropBox(currentX, currentY, cropResizeHandle);
            } else if (isDraggingCrop) {
                activeCropBox.width = currentX - cropStartX;
                activeCropBox.height = currentY - cropStartY;
            }
            
            updateCropOverlay();
        }

        function resizeCropBox(x, y, handle) {
            const box = activeCropBox;
            
            switch(handle) {
                case 'se': // Southeast
                    box.width = x - box.x;
                    box.height = y - box.y;
                    break;
                case 'nw': // Northwest
                    const oldRight = box.x + box.width;
                    const oldBottom = box.y + box.height;
                    box.x = x;
                    box.y = y;
                    box.width = oldRight - x;
                    box.height = oldBottom - y;
                    break;
                case 'ne': // Northeast
                    const oldBottom2 = box.y + box.height;
                    box.y = y;
                    box.width = x - box.x;
                    box.height = oldBottom2 - y;
                    break;
                case 'sw': // Southwest
                    const oldRight2 = box.x + box.width;
                    box.x = x;
                    box.width = oldRight2 - x;
                    box.height = y - box.y;
                    break;
                case 'n':
                    const oldBottom3 = box.y + box.height;
                    box.y = y;
                    box.height = oldBottom3 - y;
                    break;
                case 's':
                    box.height = y - box.y;
                    break;
                case 'e':
                    box.width = x - box.x;
                    break;
                case 'w':
                    const oldRight3 = box.x + box.width;
                    box.x = x;
                    box.width = oldRight3 - x;
                    break;
            }
            
            updateCropOverlay();
        }

        function updateCropOverlay() {
            const cropOverlay = document.getElementById('cropOverlay');
            const rect = canvas.getBoundingClientRect();
            
            cropOverlay.style.left = (rect.left + activeCropBox.x) + 'px';
            cropOverlay.style.top = (rect.top + activeCropBox.y) + 'px';
            cropOverlay.style.width = activeCropBox.width + 'px';
            cropOverlay.style.height = activeCropBox.height + 'px';
        }

        function checkCropHandleClick(e) {
            const handles = document.querySelectorAll('.crop-handle');
            handles.forEach(handle => {
                const rect = handle.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right &&
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    isResizingCrop = true;
                    cropResizeHandle = handle.dataset.position;
                }
            });
            
            // Check if clicking inside crop box (for dragging)
            const cropOverlay = document.getElementById('cropOverlay');
            const rect = cropOverlay.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom &&
                !isResizingCrop) {
                isDraggingCrop = true;
                cropStartX = e.clientX - rect.left;
                cropStartY = e.clientY - rect.top;
            }
        }

        function clearSelection() {
            activeCropBox = null;
            activeSelection = null;
            document.getElementById('cropOverlay').style.display = 'none';
            document.getElementById('selectionMarquee').style.display = 'none';
            document.getElementById('selectionInfo').style.display = 'none';
            document.getElementById('liveToolInfo').style.display = 'none';
        }

        function cropToSelection() {
            if (!activeCropBox) {
                alert('Please select an area to crop first');
                return;
            }
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = Math.abs(activeCropBox.width);
            tempCanvas.height = Math.abs(activeCropBox.height);
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(canvas, 
                activeCropBox.x, activeCropBox.y, 
                activeCropBox.width, activeCropBox.height,
                0, 0, 
                activeCropBox.width, activeCropBox.height
            );
            
            canvas.width = activeCropBox.width;
            canvas.height = activeCropBox.height;
            ctx.drawImage(tempCanvas, 0, 0);
            
            saveToHistory();
            clearSelection();
            updateImageInfo();
        }

        function updateImageInfo() {
            document.getElementById('imgDimensions').textContent = `${canvas.width} × ${canvas.height} px`;
            
            canvas.toBlob(blob => {
                const sizeKB = (blob.size / 1024).toFixed(2);
                document.getElementById('imgSize').textContent = `${sizeKB} KB`;
            });
        }

        function setupFileUpload() {
                        <div><strong>File Size:</strong> <span id="imgFileSize">-</span></div>
                        <div><strong>Format:</strong> <span id="imgFormat">-</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Toggle for Properties -->
        <button class="toggle-panel-btn" onclick="togglePropertiesPanel()">
            <i class="fas fa-sliders-h"></i> Toggle Properties Panel
        </button>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="action-btn btn-preview" onclick="previewImage()">
                <i class="fas fa-eye"></i> Preview
            </button>
            <button class="action-btn btn-download" onclick="downloadImage()">
                <i class="fas fa-download"></i> Download
            </button>
            <button class="action-btn btn-reupload" onclick="reuploadImage()">
                <i class="fas fa-upload"></i> Re-upload
            </button>
            <button class="action-btn btn-share" onclick="shareImage()">
                <i class="fas fa-share-alt"></i> Share
            </button>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>About DocTools</h3>
                    <p>Professional document and image editing tools for all your needs.</p>
                </div>
                <div class="footer-section">
                    <h3>Quick Links</h3>
                    <a href="index.html">Home</a>
                    <a href="privacy-policy.html">Privacy Policy</a>
                    <a href="terms-of-service.html">Terms of Service</a>
                </div>
                <div class="footer-section">
                    <h3>Contact</h3>
                    <p>Email: support@doctools.com</p>
                    <p>Phone: +1 234 567 8900</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 DocTools. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        let canvas, ctx;
        let originalImageData, currentImageData;
        let editorHistory = [];
        let historyIndex = -1;

        // Load image from sessionStorage on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Initialize canvas elements first
            canvas = document.getElementById('editorCanvas');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            // Initialize overlay canvas for interactive tools
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            
            // Check for uploaded image
            const imageData = sessionStorage.getItem('uploadedImage');
            const fileName = sessionStorage.getItem('uploadedFileName');
            const fileSize = sessionStorage.getItem('uploadedFileSize');
            const fileType = sessionStorage.getItem('uploadedFileType');

            if (!imageData) {
                alert('No image found. Please upload an image first.');
                window.location.href = 'image-repair.html';
                return;
            }

            const img = new Image();
            img.onload = function() {
                // Maximum frame height: 7 inches = 672 pixels at 96 DPI
                const maxHeight = 672;
                const maxWidth = 1200; // Reasonable max width for display
                
                let width = img.width;
                let height = img.height;
                
                // Auto-resize to fit within frame while maintaining aspect ratio
                if (height > maxHeight || width > maxWidth) {
                    const heightRatio = maxHeight / height;
                    const widthRatio = maxWidth / width;
                    const ratio = Math.min(heightRatio, widthRatio);
                    
                    width = Math.floor(img.width * ratio);
                    height = Math.floor(img.height * ratio);
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // Also sync overlay canvas size
                overlayCanvas.width = width;
                overlayCanvas.height = height;
                
                ctx.drawImage(img, 0, 0, width, height);

                originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                editorHistory = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
                historyIndex = 0;

                // Update image info in right panel
                document.getElementById('imgDimensions').textContent = `${width} × ${height}px`;
                document.getElementById('imgFileSize').textContent = fileSize || 'Unknown';
                document.getElementById('imgFormat').textContent = fileType || 'Unknown';
                
                // Show success message
                console.log('✅ Image loaded successfully:', fileName || 'Unknown');
                
                // Initialize all features after image is loaded
                initializeToolbarDropdowns();
                initializeLivePreview();
                initializeInteractiveTools();
                setupFileUpload();
                setupKeyboardShortcuts();
            };
            
            img.onerror = function() {
                alert('Failed to load image. Please try uploading again.');
                window.location.href = 'image-repair.html';
            };
            
            img.src = imageData;
        });
        
        // Keyboard Shortcuts for Undo/Redo
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl+Z or Cmd+Z for Undo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoEdit();
                }
                
                // Ctrl+Y or Ctrl+Shift+Z for Redo
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redoEdit();
                }
                
                // Ctrl+S for Save
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveImage();
                }
            });
        }
        
        // Live Preview System
        let livePreviewActive = false;
        let previewTimeout = null;
        
        function initializeLivePreview() {
            // Real-time slider updates
            const brightnessRange = document.getElementById('brightnessRange');
            const contrastRange = document.getElementById('contrastRange');
            const saturationRange = document.getElementById('saturationRange');
            const opacityRange = document.getElementById('opacityRange');
            
            // Update value displays and live preview
            brightnessRange.addEventListener('input', function() {
                document.getElementById('brightnessVal').textContent = this.value;
                debouncedLivePreview();
            });
            
            contrastRange.addEventListener('input', function() {
                document.getElementById('contrastVal').textContent = this.value;
                debouncedLivePreview();
            });
            
            saturationRange.addEventListener('input', function() {
                document.getElementById('saturationVal').textContent = this.value;
                debouncedLivePreview();
            });
            
            opacityRange.addEventListener('input', function() {
                document.getElementById('opacityVal').textContent = this.value;
                debouncedLivePreview();
            });
        }
        
        // Debounced live preview for smooth performance
        function debouncedLivePreview() {
            clearTimeout(previewTimeout);
            previewTimeout = setTimeout(() => {
                livePreview();
            }, 50); // 50ms delay for smooth updates
        }

        // Toolbar Dropdown Handler for Mobile/Touch Devices
        function initializeToolbarDropdowns() {
            const categories = document.querySelectorAll('.toolbar-category');
            let openCategory = null;
            
            categories.forEach(category => {
                const button = category.querySelector('.category-button');
                const dropdown = category.querySelector('.category-dropdown');
                let hoverTimeout = null;
                
                // Click event - MAIN INTERACTION
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // If clicking on already active category, keep it open
                    const wasActive = category.classList.contains('active');
                    
                    // Close all other dropdowns
                    categories.forEach(cat => {
                        if (cat !== category) {
                            cat.classList.remove('active');
                        }
                    });
                    
                    // Toggle current dropdown
                    if (wasActive) {
                        // Keep it open on second click
                        category.classList.add('active');
                    } else {
                        category.classList.add('active');
                    }
                    
                    openCategory = category;
                });
                
                // Hover behavior - DESKTOP ONLY
                category.addEventListener('mouseenter', function() {
                    clearTimeout(hoverTimeout);
                    // Only activate on hover if no category is clicked open
                    if (!openCategory || openCategory === category) {
                        category.classList.add('active');
                    }
                });
                
                category.addEventListener('mouseleave', function() {
                    // Don't close if this is the clicked-open category
                    if (openCategory !== category) {
                        hoverTimeout = setTimeout(() => {
                            category.classList.remove('active');
                        }, 300);
                    }
                });
                
                // Prevent dropdown from closing when hovering inside it
                if (dropdown) {
                    dropdown.addEventListener('mouseenter', function(e) {
                        clearTimeout(hoverTimeout);
                        category.classList.add('active');
                    });
                    
                    dropdown.addEventListener('mouseleave', function(e) {
                        if (openCategory !== category) {
                            hoverTimeout = setTimeout(() => {
                                category.classList.remove('active');
                            }, 300);
                        }
                    });
                    
                    // Tool button click handlers
                    const toolButtons = dropdown.querySelectorAll('.tool-item-dropdown');
                    toolButtons.forEach(toolBtn => {
                        toolBtn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            
                            // Execute the onclick function
                            const onclickAttr = this.getAttribute('onclick');
                            if (onclickAttr) {
                                // Function will execute automatically via onclick attribute
                            }
                            
                            // Close dropdown after brief delay
                            setTimeout(() => {
                                category.classList.remove('active');
                                openCategory = null;
                            }, 300);
                        });
                    });
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.toolbar-category')) {
                    categories.forEach(cat => {
                        cat.classList.remove('active');
                    });
                    openCategory = null;
                }
            });
            
            // Show instruction on first load
            setTimeout(() => {
                if (!sessionStorage.getItem('toolbarInstructionShown')) {
                    alert('🎨 Welcome to Image Editor!\n\n' +
                          '📌 How to Use:\n' +
                          '1. CLICK category buttons to open dropdown\n' +
                          '2. Dropdown stays open until you click a tool\n' +
                          '3. Or hover to quickly preview tools\n\n' +
                          '⌨️ Keyboard Shortcuts:\n' +
                          '• Ctrl+Z = Undo\n' +
                          '• Ctrl+Y = Redo\n' +
                          '• Ctrl+S = Save\n' +
                          '• ESC = Exit tool mode\n\n' +
                          '🖌️ Drawing Tools:\n' +
                          '• Brush/Pencil/Eraser: Click and drag\n' +
                          '• Changes save automatically\n' +
                          '• Use sliders for real-time adjustments\n\n' +
                          'Enjoy editing! 🚀');
                    sessionStorage.setItem('toolbarInstructionShown', 'true');
                }
            }, 1000);
        }

        // Mobile Panel Toggles
        function toggleToolsPanel() {
            document.getElementById('toolsPanel').classList.toggle('open');
        }

        function togglePropertiesPanel() {
            document.getElementById('propertiesPanel').classList.toggle('open');
        }

        // Dynamic Tool Panel System
        let currentToolConfig = null;
        let previewImageData = null;

        function showToolPanel(toolName, config) {
            const toolSettings = document.getElementById('toolSettings');
            const toolActions = document.getElementById('toolActions');
            const toolPanelTitle = document.getElementById('toolPanelTitle');
            const defaultMessage = document.getElementById('defaultToolMessage');
            
            // Hide default message
            if (defaultMessage) {
                defaultMessage.style.display = 'none';
            }
            
            // Update title
            toolPanelTitle.innerHTML = `<i class="fas fa-cog"></i> ${toolName}`;
            
            // Save current state for preview
            previewImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Store config
            currentToolConfig = config;
            
            // Build controls HTML
            let controlsHTML = `<div style="padding: 15px;">`;
            
            if (config.type === 'slider') {
                config.controls.forEach(control => {
                    controlsHTML += `
                        <div class="tool-control">
                            <label>${control.label}</label>
                            <input type="range" 
                                   id="${control.id}" 
                                   min="${control.min}" 
                                   max="${control.max}" 
                                   value="${control.default}"
                                   oninput="updateToolPreview()">
                            <div class="value-display">
                                <span id="${control.id}_value">${control.default}</span>
                            </div>
                        </div>
                    `;
                });
            } else if (config.type === 'input') {
                config.controls.forEach(control => {
                    controlsHTML += `
                        <div class="tool-control">
                            <label>${control.label}</label>
                            <input type="${control.inputType || 'text'}" 
                                   id="${control.id}" 
                                   value="${control.default || ''}"
                                   placeholder="${control.placeholder || ''}"
                                   oninput="updateToolPreview()">
                        </div>
                    `;
                });
            } else if (config.type === 'buttons') {
                controlsHTML += `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">`;
                config.options.forEach(option => {
                    controlsHTML += `
                        <button onclick="applyPreset('${option.value}')" 
                                style="padding: 12px; border: 2px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s;">
                            ${option.label}
                        </button>
                    `;
                });
                controlsHTML += `</div>`;
            }
            
            controlsHTML += `</div>`;
            
            // Insert controls
            toolSettings.innerHTML = controlsHTML;
            
            // Show action buttons
            toolActions.style.display = 'flex';
        }

        function updateToolPreview() {
            if (!currentToolConfig || !previewImageData) return;
            
            // Restore original image
            ctx.putImageData(previewImageData, 0, 0);
            
            // Apply preview based on tool type
            if (currentToolConfig.type === 'slider') {
                const values = {};
                currentToolConfig.controls.forEach(control => {
                    const input = document.getElementById(control.id);
                    const valueDisplay = document.getElementById(control.id + '_value');
                    if (input && valueDisplay) {
                        values[control.id] = parseFloat(input.value);
                        valueDisplay.textContent = input.value;
                    }
                });
                
                // Apply the effect
                if (currentToolConfig.applyFunction) {
                    currentToolConfig.applyFunction(values);
                }
            }
        }

        function applyToolChanges() {
            // Save to history
            saveToHistory();
            
            // Reset tool panel
            resetToolPanel();
        }

        function cancelToolChanges() {
            // Restore original image
            if (previewImageData) {
                ctx.putImageData(previewImageData, 0, 0);
            }
            
            // Reset tool panel
            resetToolPanel();
        }

        function resetToolPanel() {
            const toolSettings = document.getElementById('toolSettings');
            const toolActions = document.getElementById('toolActions');
            const toolPanelTitle = document.getElementById('toolPanelTitle');
            const defaultMessage = document.getElementById('defaultToolMessage');
            
            // Reset title
            toolPanelTitle.innerHTML = '<i class="fas fa-toolbox"></i> Tool Controls';
            
            // Show default message
            if (defaultMessage) {
                defaultMessage.style.display = 'block';
            }
            
            // Clear controls
            toolSettings.innerHTML = defaultMessage ? defaultMessage.outerHTML : '';
            
            // Hide action buttons
            toolActions.style.display = 'none';
            
            // Clear config
            currentToolConfig = null;
            previewImageData = null;
        }

        function applyPreset(presetValue) {
            if (currentToolConfig && currentToolConfig.presetFunction) {
                currentToolConfig.presetFunction(presetValue);
            }
        }

        // Save to history
        function saveToHistory() {
            if (historyIndex < editorHistory.length - 1) {
                editorHistory = editorHistory.slice(0, historyIndex + 1);
            }
            editorHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            historyIndex++;
            if (editorHistory.length > 20) {
                editorHistory.shift();
                historyIndex--;
            }
        }

        // Transform Functions
        function rotateRight() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.height;
            tempCanvas.height = canvas.width;
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(90 * Math.PI / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            canvas.width = tempCanvas.width;
            canvas.height = tempCanvas.height;
            ctx.drawImage(tempCanvas, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        function rotateLeft() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.height;
            tempCanvas.height = canvas.width;
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(-90 * Math.PI / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            canvas.width = tempCanvas.width;
            canvas.height = tempCanvas.height;
            ctx.drawImage(tempCanvas, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        function flipHorizontal() {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(canvas, 0, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        function flipVertical() {
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
            ctx.drawImage(canvas, 0, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        // Filter Functions
        function applyFilter(filterType) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            switch(filterType) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = data[i + 1] = data[i + 2] = avg;
                    }
                    break;
                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                    }
                    break;
                case 'invert':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];
                        data[i + 1] = 255 - data[i + 1];
                        data[i + 2] = 255 - data[i + 2];
                    }
                    break;
                case 'blur':
                    // Simple box blur
                    const tempData = new Uint8ClampedArray(data);
                    const width = canvas.width;
                    for (let i = 0; i < data.length; i += 4) {
                        const x = (i / 4) % width;
                        const y = Math.floor((i / 4) / width);
                        if (x > 0 && x < width - 1 && y > 0 && y < canvas.height - 1) {
                            for (let c = 0; c < 3; c++) {
                                let sum = 0;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                                        sum += tempData[idx];
                                    }
                                }
                                data[i + c] = sum / 9;
                            }
                        }
                    }
                    break;
            }

            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        // Live Preview
        function livePreview() {
            if (!currentImageData) return;

            const brightness = parseInt(document.getElementById('brightnessRange').value);
            const contrast = parseInt(document.getElementById('contrastRange').value);
            const saturation = parseInt(document.getElementById('saturationRange').value);
            const opacity = parseInt(document.getElementById('opacityRange').value);

            document.getElementById('brightnessVal').textContent = brightness;
            document.getElementById('contrastVal').textContent = contrast;
            document.getElementById('saturationVal').textContent = saturation;
            document.getElementById('opacityVal').textContent = opacity;

            const imageData = ctx.createImageData(currentImageData);
            const data = imageData.data;
            const sourceData = currentImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let r = sourceData[i];
                let g = sourceData[i + 1];
                let b = sourceData[i + 2];

                // Brightness
                r += brightness;
                g += brightness;
                b += brightness;

                // Contrast
                if (contrast !== 0) {
                    const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                    r = factor * (r - 128) + 128;
                    g = factor * (g - 128) + 128;
                    b = factor * (b - 128) + 128;
                }

                // Saturation
                if (saturation !== 100) {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    const satFactor = saturation / 100;
                    r = gray + (r - gray) * satFactor;
                    g = gray + (g - gray) * satFactor;
                    b = gray + (b - gray) * satFactor;
                }

                data[i] = Math.min(255, Math.max(0, r));
                data[i + 1] = Math.min(255, Math.max(0, g));
                data[i + 2] = Math.min(255, Math.max(0, b));
                data[i + 3] = Math.min(255, sourceData[i + 3] * (opacity / 100));
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Apply Changes
        function applyChanges() {
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            resetSliders();
            alert('✓ Changes applied successfully!');
        }

        function resetSliders() {
            document.getElementById('brightnessRange').value = 0;
            document.getElementById('contrastRange').value = 0;
            document.getElementById('saturationRange').value = 100;
            document.getElementById('opacityRange').value = 100;
            document.getElementById('brightnessVal').textContent = '0';
            document.getElementById('contrastVal').textContent = '0';
            document.getElementById('saturationVal').textContent = '100';
            document.getElementById('opacityVal').textContent = '100';
        }

        // Preset Effects
        function presetEffect(preset) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            switch(preset) {
                case 'bw':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = data[i + 1] = data[i + 2] = avg;
                    }
                    break;
                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                    }
                    break;
                case 'vibrant':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.3);
                        data[i + 1] = Math.min(255, data[i + 1] * 1.3);
                        data[i + 2] = Math.min(255, data[i + 2] * 1.3);
                    }
                    break;
                case 'cool':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, data[i] - 20);
                        data[i + 2] = Math.min(255, data[i + 2] + 20);
                    }
                    break;
                case 'warm':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] + 20);
                        data[i + 2] = Math.max(0, data[i + 2] - 20);
                    }
                    break;
                case 'vintage':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = Math.min(255, r * 0.9 + 30);
                        data[i + 1] = Math.min(255, g * 0.85 + 20);
                        data[i + 2] = Math.max(0, b * 0.7);
                    }
                    break;
            }

            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        // Action Button Functions
        function previewImage() {
            const dataURL = canvas.toDataURL('image/png');
            const win = window.open();
            win.document.write('<img src="' + dataURL + '" style="max-width:100%; height:auto;">');
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'edited-image-' + Date.now() + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function reuploadImage() {
            if (confirm('Are you sure you want to upload a new image? Current changes will be lost.')) {
                sessionStorage.clear();
                window.location.href = 'image-repair.html';
            }
        }

        function shareImage() {
            canvas.toBlob(async function(blob) {
                const file = new File([blob], 'edited-image.png', { type: 'image/png' });
                
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    try {
                        await navigator.share({
                            files: [file],
                            title: 'Edited Image',
                            text: 'Check out my edited image!'
                        });
                    } catch (err) {
                        console.log('Share failed:', err);
                        fallbackShare();
                    }
                } else {
                    fallbackShare();
                }
            });
        }

        function fallbackShare() {
            const dataURL = canvas.toDataURL('image/png');
            const shareText = 'Copy this link to share: ' + dataURL.substring(0, 100) + '...';
            alert('Sharing not supported on this device. You can download the image and share it manually.');
        }

        // ==================== TOOLBAR FUNCTIONS ====================
        
        // FILE & BASIC
        function newImage() {
            if (confirm('Create a new image? Current changes will be lost.')) {
                const width = prompt('Enter width (px):', '800');
                const height = prompt('Enter height (px):', '600');
                if (width && height) {
                    canvas.width = parseInt(width);
                    canvas.height = parseInt(height);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                }
            }
        }

        function openImage() {
            if (confirm('Open a new image? Current changes will be lost.')) {
                window.location.href = 'image-repair.html';
            }
        }

        function saveImage() {
            downloadImage();
        }

        function exportAs() {
            const format = prompt('Export format (png, jpg, webp):', 'png');
            if (format) {
                const link = document.createElement('a');
                link.download = 'edited-image-' + Date.now() + '.' + format;
                link.href = canvas.toDataURL('image/' + format);
                link.click();
            }
        }

        function undoEdit() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(editorHistory[historyIndex], 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                resetSliders();
            } else {
                alert('Nothing to undo');
            }
        }

        function redoEdit() {
            if (historyIndex < editorHistory.length - 1) {
                historyIndex++;
                ctx.putImageData(editorHistory[historyIndex], 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                resetSliders();
            } else {
                alert('Nothing to redo');
            }
        }

        function resetToOriginal() {
            if (confirm('Reset to original image? All changes will be lost.')) {
                if (originalImageData) {
                    ctx.putImageData(originalImageData, 0, 0);
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                    resetSliders();
                }
            }
        }

        function duplicateImage() {
            const link = document.createElement('a');
            link.download = 'copy-' + Date.now() + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            alert('Image duplicated and downloaded!');
        }

        // SELECTION
        // SELECTION TOOLS - All Activated
        let selectionActive = false;
        let selectionRect = { x: 0, y: 0, width: 0, height: 0 };
        
        function rectangularSelection() {
            const x = parseInt(prompt('Selection X position:', '50'));
            const y = parseInt(prompt('Selection Y position:', '50'));
            const w = parseInt(prompt('Selection width:', '200'));
            const h = parseInt(prompt('Selection height:', '150'));
            
            if (x !== null && y !== null && w && h) {
                selectionRect = { x, y, width: w, height: h };
                selectionActive = true;
                
                // Draw selection outline
                ctx.save();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
                
                alert('Rectangular selection created! Use Crop to Selection or other tools.');
            }
        }
        
        function ellipticalSelection() {
            const cx = parseInt(prompt('Center X:', canvas.width / 2));
            const cy = parseInt(prompt('Center Y:', canvas.height / 2));
            const rx = parseInt(prompt('Radius X:', '100'));
            const ry = parseInt(prompt('Radius Y:', '80'));
            
            if (cx !== null && cy !== null && rx && ry) {
                ctx.save();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                
                selectionRect = { x: cx - rx, y: cy - ry, width: rx * 2, height: ry * 2 };
                selectionActive = true;
                alert('Elliptical selection created!');
            }
        }
        
        function lassoSelection() {
            alert('Lasso Selection: Click and drag to draw freehand selection - interactive mode coming soon!');
        }
        
        function magicWand() {
            const x = parseInt(prompt('Click X position:', canvas.width / 2));
            const y = parseInt(prompt('Click Y position:', canvas.height / 2));
            const tolerance = parseInt(prompt('Tolerance (0-100):', '30'));
            
            if (x !== null && y !== null && tolerance !== null) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const idx = (y * canvas.width + x) * 4;
                const targetR = data[idx];
                const targetG = data[idx + 1];
                const targetB = data[idx + 2];
                
                // Highlight similar pixels
                for (let i = 0; i < data.length; i += 4) {
                    const diff = Math.sqrt(
                        Math.pow(data[i] - targetR, 2) +
                        Math.pow(data[i + 1] - targetG, 2) +
                        Math.pow(data[i + 2] - targetB, 2)
                    );
                    
                    if (diff < tolerance) {
                        // Add green tint to selected pixels
                        data[i + 1] = Math.min(255, data[i + 1] + 50);
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                selectionActive = true;
                alert('Magic wand selected similar colors! (shown in green tint)');
            }
        }
        
        function quickSelection() {
            alert('Quick Selection: AI-powered edge detection selection - use Magic Wand for color-based selection!');
        }
        
        function selectAll() {
            selectionRect = { x: 0, y: 0, width: canvas.width, height: canvas.height };
            selectionActive = true;
            
            ctx.save();
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            alert('Entire canvas selected!');
        }
        
        function deselectAll() {
            selectionActive = false;
            selectionRect = { x: 0, y: 0, width: 0, height: 0 };
            
            // Redraw without selection outline
            ctx.putImageData(currentImageData, 0, 0);
            alert('Selection cleared!');
        }
        
        function invertSelection() {
            if (!selectionActive) {
                alert('No active selection to invert!');
                return;
            }
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Invert colors
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Selection inverted!');
        }
        
        function expandSelection() {
            if (!selectionActive) {
                alert('No active selection to expand!');
                return;
            }
            
            const expand = parseInt(prompt('Expand by pixels:', '10'));
            if (expand) {
                selectionRect.x = Math.max(0, selectionRect.x - expand);
                selectionRect.y = Math.max(0, selectionRect.y - expand);
                selectionRect.width = Math.min(canvas.width, selectionRect.width + expand * 2);
                selectionRect.height = Math.min(canvas.height, selectionRect.height + expand * 2);
                
                rectangularSelection();
                alert('Selection expanded by ' + expand + ' pixels!');
            }
        }
        
        function contractSelection() {
            if (!selectionActive) {
                alert('No active selection to contract!');
                return;
            }
            
            const contract = parseInt(prompt('Contract by pixels:', '10'));
            if (contract) {
                selectionRect.x += contract;
                selectionRect.y += contract;
                selectionRect.width = Math.max(0, selectionRect.width - contract * 2);
                selectionRect.height = Math.max(0, selectionRect.height - contract * 2);
                
                rectangularSelection();
                alert('Selection contracted by ' + contract + ' pixels!');
            }
        }

        // CROP & TRANSFORM
        function cropImage() {
            // Activate interactive crop mode (Photoshop-style)
            currentTool = 'crop';
            
            // Show instruction in left panel
            const toolSettings = document.getElementById('toolSettings');
            const defaultMessage = document.getElementById('defaultToolMessage');
            if (defaultMessage) defaultMessage.style.display = 'none';
            
            toolSettings.innerHTML = 
                '<div style="padding: 20px; text-align: center;">' +
                    '<i class="fas fa-crop" style="font-size: 3rem; color: #4bb543; margin-bottom: 15px;"></i>' +
                    '<h4 style="color: #333; margin-bottom: 15px;">Interactive Crop Mode</h4>' +
                    '<p style="font-size: 0.9rem; color: #666; line-height: 1.6; margin-bottom: 20px;">' +
                        '📍 <strong>Click and drag</strong> on the canvas to select crop area<br>' +
                        '🔲 <strong>Drag handles</strong> to resize selection<br>' +
                        '↔️ <strong>Drag inside box</strong> to move selection<br>' +
                        '📊 <strong>Live dimensions</strong> shown in right panel' +
                    '</p>' +
                    '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 15px;">' +
                        '<h5 style="color: #4bb543; margin-bottom: 10px;">✨ Tips:</h5>' +
                        '<ul style="text-align: left; font-size: 0.85rem; color: #666; line-height: 1.8;">' +
                            '<li>Hold <kbd>Shift</kbd> for square crop</li>' +
                            '<li>Use handles for precise adjustment</li>' +
                            '<li>Click "Crop to Selection" when ready</li>' +
                        '</ul>' +
                    '</div>' +
                '</div>';
            
            // Show selection info panel
            document.getElementById('selectionInfo').style.display = 'block';
            document.getElementById('liveToolInfo').style.display = 'block';
            document.getElementById('toolInfoTitle').innerHTML = '<i class="fas fa-crop"></i> Crop Tool';
            
            // Enable canvas interaction
            canvas.style.cursor = 'crosshair';
            
            alert('🎨 Interactive Crop Mode Activated!\n\n' +
                  '📍 Click and drag on the image to select crop area\n' +
                  '🔲 Use handles to resize\n' +
                  '↔️ Drag inside to move\n' +
                  '✅ Click "Crop to Selection" in right panel when ready');
        }
        
        function cropToSelection() { alert('Select an area first using Selection tools'); }
        
        function trimCanvas() {
            // Remove transparent edges
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let top = canvas.height, left = canvas.width, right = 0, bottom = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx + 3] > 0) {
                        if (y < top) top = y;
                        if (y > bottom) bottom = y;
                        if (x < left) left = x;
                        if (x > right) right = x;
                    }
                }
            }
            
            const width = right - left + 1;
            const height = bottom - top + 1;
            
            if (width > 0 && height > 0) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(canvas, left, top, width, height, 0, 0, width, height);
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(tempCanvas, 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
                alert('Canvas trimmed!');
            }
        }
        
        function rotate180() {
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(Math.PI);
            ctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        function customRotate() {
            const angle = prompt('Enter rotation angle (degrees):', '45');
            if (angle) {
                const rad = parseFloat(angle) * Math.PI / 180;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                tempCtx.rotate(rad);
                tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }

        function resizeImage() {
            showToolPanel('Resize Image', {
                type: 'input',
                controls: [
                    { id: 'resize_width', label: 'Width (px)', inputType: 'number', default: canvas.width, placeholder: 'Enter width' },
                    { id: 'resize_height', label: 'Height (px)', inputType: 'number', default: canvas.height, placeholder: 'Enter height' },
                    { id: 'maintain_ratio', label: 'Maintain Aspect Ratio', inputType: 'checkbox', default: true }
                ],
                applyFunction: function(values) {
                    const width = parseInt(document.getElementById('resize_width').value) || canvas.width;
                    const height = parseInt(document.getElementById('resize_height').value) || canvas.height;
                    
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    tempCtx.drawImage(canvas, 0, 0, width, height);
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(tempCanvas, 0, 0);
                }
            });
        }

        function scaleImage() {
            const scale = prompt('Enter scale factor (e.g., 1.5 for 150%):', '1');
            if (scale) {
                const factor = parseFloat(scale);
                const newWidth = canvas.width * factor;
                const newHeight = canvas.height * factor;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
                canvas.width = newWidth;
                canvas.height = newHeight;
                ctx.drawImage(tempCanvas, 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }

        function skewImage() { 
            const skewX = parseFloat(prompt('Skew X angle (degrees):', '0'));
            const skewY = parseFloat(prompt('Skew Y angle (degrees):', '0'));
            
            if (skewX !== null || skewY !== null) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                tempCtx.transform(1, Math.tan(skewY * Math.PI / 180), Math.tan(skewX * Math.PI / 180), 1, 0, 0);
                tempCtx.drawImage(canvas, 0, 0);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function perspectiveTransform() { 
            alert('Advanced perspective transform - Use the Transform controls in the right panel for basic transformations');
        }

        // BRUSH & PAINT - Interactive Drawing Tools
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'none';
        let brushSize = 10;
        let brushColor = '#000000';
        let interactiveModeActive = false;

        function enableDrawingTool(tool) {
            currentTool = tool;
            interactiveModeActive = true;
            canvas.style.cursor = 'crosshair';
            
            // Show interactive mode indicator
            showToolIndicator(tool);
            
            // Add drawing event listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch support
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', stopDrawing);
        }
        
        function disableDrawingTool() {
            currentTool = 'none';
            interactiveModeActive = false;
            canvas.style.cursor = 'default';
            
            // Remove event listeners
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', draw);
            canvas.removeEventListener('mouseup', stopDrawing);
            canvas.removeEventListener('mouseout', stopDrawing);
            canvas.removeEventListener('touchstart', handleTouchStart);
            canvas.removeEventListener('touchmove', handleTouchMove);
            canvas.removeEventListener('touchend', stopDrawing);
            
            hideToolIndicator();
        }
        
        function showToolIndicator(tool) {
            // Create indicator if not exists
            let indicator = document.getElementById('toolIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'toolIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #4361ee 0%, #3a0ca3 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-weight: 600;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                `;
                document.body.appendChild(indicator);
            }
            
            const toolNames = {
                'brush': '🖌️ Brush Tool Active',
                'pencil': '✏️ Pencil Tool Active',
                'eraser': '🧹 Eraser Tool Active',
                'selection': '📐 Selection Mode'
            };
            
            indicator.textContent = toolNames[tool] || `🔧 ${tool} Active`;
            indicator.innerHTML += '<br><small>Press ESC to exit | Ctrl+Z to undo</small>';
            indicator.style.display = 'block';
        }
        
        function hideToolIndicator() {
            const indicator = document.getElementById('toolIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }
        
        // ESC key to exit interactive mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && interactiveModeActive) {
                disableDrawingTool();
                alert('Interactive mode disabled. Tool deactivated.');
            }
        });

        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
        }

        function handleTouchMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawLine(lastX, lastY, x, y);
            lastX = x;
            lastY = y;
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawLine(lastX, lastY, x, y);
            lastX = x;
            lastY = y;
        }

        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            
            if (currentTool === 'brush') {
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            } else if (currentTool === 'pencil') {
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = 2;
                ctx.lineCap = 'square';
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = brushSize * 2;
                ctx.lineCap = 'round';
            }
            
            ctx.stroke();
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }

        function brushTool() { 
            const size = prompt('Brush size (5-100px):', '15');
            if (size) {
                brushSize = parseInt(size);
                brushColor = document.getElementById('fgColor').value;
                enableDrawingTool('brush');
                alert('✓ Brush tool activated!\n\n• Click and drag to draw\n• Use color picker to change color\n• Press ESC to exit\n• Ctrl+Z to undo');
            }
        }
        
        function pencilTool() { 
            brushSize = 2;
            brushColor = document.getElementById('fgColor').value;
            enableDrawingTool('pencil');
            alert('✓ Pencil tool activated!\n\n• Click and drag to draw thin lines\n• Use color picker to change color\n• Press ESC to exit\n• Ctrl+Z to undo');
        }
        
        function eraserTool() { 
            const size = prompt('Eraser size (10-100px):', '30');
            if (size) {
                brushSize = parseInt(size);
                enableDrawingTool('eraser');
                alert('✓ Eraser tool activated!\n\n• Click and drag to erase\n• Press ESC to exit\n• Ctrl+Z to undo');
            }
        }
        
        function paintBucket() {
            const x = parseInt(prompt('Click X position:', Math.floor(canvas.width / 2)));
            const y = parseInt(prompt('Click Y position:', Math.floor(canvas.height / 2)));
            const fillColor = document.getElementById('fgColor').value;
            
            if (x !== null && y !== null) {
                // Convert hex to RGB
                const r = parseInt(fillColor.substr(1,2), 16);
                const g = parseInt(fillColor.substr(3,2), 16);
                const b = parseInt(fillColor.substr(5,2), 16);
                
                floodFill(x, y, r, g, b);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }

        function floodFill(startX, startY, fillR, fillG, fillB) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const startPos = (startY * width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            
            if (startR === fillR && startG === fillG && startB === fillB) return;
            
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited.has(key)) continue;
                
                const pos = (y * width + x) * 4;
                if (data[pos] === startR && data[pos + 1] === startG && data[pos + 2] === startB) {
                    data[pos] = fillR;
                    data[pos + 1] = fillG;
                    data[pos + 2] = fillB;
                    visited.add(key);
                    
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function gradientTool() {
            const type = prompt('Gradient type (linear/radial):', 'linear');
            const color1 = document.getElementById('fgColor').value;
            const color2 = document.getElementById('bgColor').value;
            
            let gradient;
            if (type === 'radial') {
                gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
            } else {
                gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            }
            
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        function blurTool() { 
            showToolPanel('Blur Effect', {
                type: 'slider',
                controls: [
                    { id: 'blur_radius', label: 'Blur Radius', min: 1, max: 50, default: 5 }
                ],
                applyFunction: function(values) {
                    const radius = parseInt(values.blur_radius) || 5;
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const tempData = new Uint8ClampedArray(data);
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Box blur algorithm
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            let r = 0, g = 0, b = 0, count = 0;
                            
                            for (let ky = -radius; ky <= radius; ky++) {
                                for (let kx = -radius; kx <= radius; kx++) {
                                    const px = Math.min(width - 1, Math.max(0, x + kx));
                                    const py = Math.min(height - 1, Math.max(0, y + ky));
                                    const idx = (py * width + px) * 4;
                                    
                                    r += tempData[idx];
                                    g += tempData[idx + 1];
                                    b += tempData[idx + 2];
                                    count++;
                                }
                            }
                            
                            const i = (y * width + x) * 4;
                            data[i] = r / count;
                            data[i + 1] = g / count;
                            data[i + 2] = b / count;
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }
            });
        }
        
        function smudgeTool() {
            const x = parseInt(prompt('Smudge center X:', canvas.width / 2));
            const y = parseInt(prompt('Smudge center Y:', canvas.height / 2));
            const radius = parseInt(prompt('Smudge radius:', '30'));
            
            if (x !== null && y !== null && radius) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                
                // Smudge by averaging nearby pixels
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const px = x + dx;
                            const py = y + dy;
                            
                            if (px > 0 && px < width - 1 && py > 0 && py < canvas.height - 1) {
                                const idx = (py * width + px) * 4;
                                
                                // Average with neighboring pixels
                                let r = 0, g = 0, b = 0, count = 0;
                                for (let i = -2; i <= 2; i++) {
                                    for (let j = -2; j <= 2; j++) {
                                        const nIdx = ((py + i) * width + (px + j)) * 4;
                                        r += data[nIdx];
                                        g += data[nIdx + 1];
                                        b += data[nIdx + 2];
                                        count++;
                                    }
                                }
                                
                                data[idx] = r / count;
                                data[idx + 1] = g / count;
                                data[idx + 2] = b / count;
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                saveToHistory();
                alert('Smudge applied!');
            }
        }
        
        function cloneStamp() {
            const srcX = parseInt(prompt('Source X (to clone from):', '100'));
            const srcY = parseInt(prompt('Source Y (to clone from):', '100'));
            const destX = parseInt(prompt('Destination X (to clone to):', '200'));
            const destY = parseInt(prompt('Destination Y (to clone to):', '100'));
            const radius = parseInt(prompt('Clone radius:', '40'));
            
            if (srcX !== null && srcY !== null && destX !== null && destY !== null && radius) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                
                // Clone circular area
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const sx = srcX + dx;
                            const sy = srcY + dy;
                            const dx2 = destX + dx;
                            const dy2 = destY + dy;
                            
                            if (sx >= 0 && sx < width && sy >= 0 && sy < canvas.height &&
                                dx2 >= 0 && dx2 < width && dy2 >= 0 && dy2 < canvas.height) {
                                const srcIdx = (sy * width + sx) * 4;
                                const destIdx = (dy2 * width + dx2) * 4;
                                
                                data[destIdx] = data[srcIdx];
                                data[destIdx + 1] = data[srcIdx + 1];
                                data[destIdx + 2] = data[srcIdx + 2];
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                saveToHistory();
                alert('Clone stamp applied!');
            }
        }
        
        function healingBrush() {
            const x = parseInt(prompt('Healing brush X:', canvas.width / 2));
            const y = parseInt(prompt('Healing brush Y:', canvas.height / 2));
            const radius = parseInt(prompt('Healing radius:', '25'));
            
            if (x !== null && y !== null && radius) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                
                // Healing by blending with surrounding area
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const px = x + dx;
                            const py = y + dy;
                            
                            if (px > 2 && px < width - 2 && py > 2 && py < canvas.height - 2) {
                                const idx = (py * width + px) * 4;
                                
                                // Sample from outer ring
                                let r = 0, g = 0, b = 0, count = 0;
                                const sampleDist = radius + 5;
                                
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                    const sx = Math.floor(x + Math.cos(angle) * sampleDist);
                                    const sy = Math.floor(y + Math.sin(angle) * sampleDist);
                                    
                                    if (sx >= 0 && sx < width && sy >= 0 && sy < canvas.height) {
                                        const sIdx = (sy * width + sx) * 4;
                                        r += data[sIdx];
                                        g += data[sIdx + 1];
                                        b += data[sIdx + 2];
                                        count++;
                                    }
                                }
                                
                                if (count > 0) {
                                    // Blend with original
                                    const blend = 0.7;
                                    data[idx] = data[idx] * (1 - blend) + (r / count) * blend;
                                    data[idx + 1] = data[idx + 1] * (1 - blend) + (g / count) * blend;
                                    data[idx + 2] = data[idx + 2] * (1 - blend) + (b / count) * blend;
                                }
                            }
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                saveToHistory();
                alert('Healing brush applied!');
            }
        }
        function dodgeTool() { 
            // Lighten image
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.15);
                data[i + 1] = Math.min(255, data[i + 1] * 1.15);
                data[i + 2] = Math.min(255, data[i + 2] * 1.15);
            }
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        function burnTool() { 
            // Darken image
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, data[i] * 0.85);
                data[i + 1] = Math.max(0, data[i + 1] * 0.85);
                data[i + 2] = Math.max(0, data[i + 2] * 0.85);
            }
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        // FILTERS & EFFECTS
        function sharpenFilter() { 
            // Sharpen filter using convolution
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const tempData = new Uint8ClampedArray(data);
            
            // Sharpen kernel
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += tempData[idx] * kernel[kernelIdx];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        data[idx] = Math.min(255, Math.max(0, sum));
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function edgeDetect() { 
            // Edge detection using Sobel operator
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const tempData = new Uint8ClampedArray(data);
            
            // Convert to grayscale first
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                tempData[i] = tempData[i + 1] = tempData[i + 2] = gray;
            }
            
            // Sobel edge detection
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    // Get surrounding pixels
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const val = tempData[idx];
                            gx += val * (kx);
                            gy += val * (ky);
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const idx = (y * width + x) * 4;
                    data[idx] = data[idx + 1] = data[idx + 2] = Math.min(255, magnitude);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function embossFilter() { 
            // Emboss filter
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const tempData = new Uint8ClampedArray(data);
            
            // Emboss kernel
            const kernel = [
                -2, -1, 0,
                -1, 1, 1,
                0, 1, 2
            ];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += tempData[idx] * kernel[kernelIdx];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        data[idx] = Math.min(255, Math.max(0, sum + 128));
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function pixelateFilter() { 
            const blockSize = parseInt(prompt('Enter pixelate block size (e.g., 10):', '10'));
            if (!blockSize) return;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let y = 0; y < canvas.height; y += blockSize) {
                for (let x = 0; x < canvas.width; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    // Average color in block
                    for (let by = 0; by < blockSize && y + by < canvas.height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < canvas.width; bx++) {
                            const idx = ((y + by) * canvas.width + (x + bx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }
                    
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    
                    // Apply to block
                    for (let by = 0; by < blockSize && y + by < canvas.height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < canvas.width; bx++) {
                            const idx = ((y + by) * canvas.width + (x + bx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function posterizeFilter() { 
            const levels = parseInt(prompt('Enter posterize levels (2-20):', '4'));
            if (!levels) return;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const step = 255 / (levels - 1);
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.round(data[i] / step) * step;
                data[i + 1] = Math.round(data[i + 1] / step) * step;
                data[i + 2] = Math.round(data[i + 2] / step) * step;
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function vignetteEffect() { 
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const factor = Math.max(0, 1 - (dist / maxDist) * 0.8);
                    
                    const idx = (y * width + x) * 4;
                    data[idx] *= factor;
                    data[idx + 1] *= factor;
                    data[idx + 2] *= factor;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }

        // ADJUSTMENTS
        function brightnessContrast() { 
            showToolPanel('Brightness & Contrast', {
                type: 'slider',
                controls: [
                    { id: 'tool_brightness', label: 'Brightness', min: -100, max: 100, default: 0 },
                    { id: 'tool_contrast', label: 'Contrast', min: -100, max: 100, default: 0 }
                ],
                applyFunction: function(values) {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const brightness = values.tool_brightness || 0;
                    const contrast = values.tool_contrast || 0;
                    const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                    
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i];
                        let g = data[i + 1];
                        let b = data[i + 2];
                        
                        // Apply brightness
                        r += brightness;
                        g += brightness;
                        b += brightness;
                        
                        // Apply contrast
                        r = factor * (r - 128) + 128;
                        g = factor * (g - 128) + 128;
                        b = factor * (b - 128) + 128;
                        
                        data[i] = Math.min(255, Math.max(0, r));
                        data[i + 1] = Math.min(255, Math.max(0, g));
                        data[i + 2] = Math.min(255, Math.max(0, b));
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }
            });
        }
        function hueSaturation() { 
            showToolPanel('Hue & Saturation', {
                type: 'slider',
                controls: [
                    { id: 'tool_hue', label: 'Hue', min: -180, max: 180, default: 0 },
                    { id: 'tool_saturation', label: 'Saturation', min: 0, max: 200, default: 100 }
                ],
                applyFunction: function(values) {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const hue = values.tool_hue || 0;
                    const saturation = (values.tool_saturation || 100) / 100;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i] / 255;
                        let g = data[i + 1] / 255;
                        let b = data[i + 2] / 255;
                        
                        // RGB to HSL
                        const max = Math.max(r, g, b), min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
                        
                        if (max === min) {
                            h = s = 0;
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                                case g: h = ((b - r) / d + 2) / 6; break;
                                case b: h = ((r - g) / d + 4) / 6; break;
                            }
                        }
                        
                        // Apply hue shift
                        h = (h * 360 + hue) / 360;
                        if (h < 0) h += 1;
                        if (h > 1) h -= 1;
                        
                        // Apply saturation
                        s *= saturation;
                        s = Math.max(0, Math.min(1, s));
                        
                        // HSL to RGB
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        
                        if (s === 0) {
                            r = g = b = l;
                        } else {
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1/3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1/3);
                        }
                        
                        data[i] = Math.round(r * 255);
                        data[i + 1] = Math.round(g * 255);
                        data[i + 2] = Math.round(b * 255);
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }
            });
        }
        
        function colorBalance() {
            const red = parseInt(prompt('Red adjustment (-100 to 100):', '0'));
            const green = parseInt(prompt('Green adjustment (-100 to 100):', '0'));
            const blue = parseInt(prompt('Blue adjustment (-100 to 100):', '0'));
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] + red));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + green));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + blue));
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function levels() { alert('Use Brightness/Contrast in Adjustments panel →'); }
        function curves() { alert('Advanced curve adjustment - coming soon!'); }
        
        function exposure() {
            const exp = parseFloat(prompt('Exposure adjustment (0.5 to 2.0):', '1.0'));
            if (exp) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * exp);
                    data[i + 1] = Math.min(255, data[i + 1] * exp);
                    data[i + 2] = Math.min(255, data[i + 2] * exp);
                }
                
                ctx.putImageData(imageData, 0, 0);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function vibrance() {
            // Increase vibrance
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const max = Math.max(data[i], data[i + 1], data[i + 2]);
                const min = Math.min(data[i], data[i + 1], data[i + 2]);
                const sat = max - min;
                const factor = 1 + (sat / 255) * 0.5;
                
                data[i] = Math.min(255, data[i] * factor);
                data[i + 1] = Math.min(255, data[i + 1] * factor);
                data[i + 2] = Math.min(255, data[i + 2] * factor);
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
        }
        
        function autoAdjust() {
            // Simple auto-adjust implementation
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Increase brightness and contrast
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.2 + 10);
                data[i + 1] = Math.min(255, data[i + 1] * 1.2 + 10);
                data[i + 2] = Math.min(255, data[i + 2] * 1.2 + 10);
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Auto-adjust applied!');
        }

        // LAYERS & MASKS
        function newLayer() {
            alert('Current canvas will be treated as new layer. Use Duplicate to create a copy.');
        }
        
        function duplicateLayer() {
            // Download a copy of current canvas
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'layer-copy-' + Date.now() + '.png';
                link.href = url;
                link.click();
                alert('Layer duplicated and downloaded! Open it to work on a separate copy.');
            });
        }
        
        function deleteLayer() {
            if (confirm('Clear current canvas?')) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function mergeDown() { alert('Single layer mode - all changes are on one layer'); }
        function mergeVisible() { alert('Single layer mode - all changes are on one layer'); }
        
        function flattenImage() {
            // Flatten transparency to white
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i + 3] / 255;
                data[i] = Math.round(data[i] * alpha + 255 * (1 - alpha));
                data[i + 1] = Math.round(data[i + 1] * alpha + 255 * (1 - alpha));
                data[i + 2] = Math.round(data[i + 2] * alpha + 255 * (1 - alpha));
                data[i + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Image flattened!');
        }
        
        function layerOpacity() { alert('Use Opacity slider in Adjustments panel →'); }
        function addLayerMask() { alert('Layer Mask - Advanced feature coming soon!'); }

        // TEXT & SHAPES
        function addText() {
            const text = prompt('Enter text:');
            const size = parseInt(prompt('Font size (px):', '40'));
            const color = prompt('Text color (hex):', '#000000');
            
            if (text) {
                ctx.font = `${size}px Arial`;
                ctx.fillStyle = color;
                ctx.fillText(text, 50, 100);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function verticalText() {
            const text = prompt('Enter text:');
            const size = parseInt(prompt('Font size (px):', '40'));
            
            if (text) {
                ctx.save();
                ctx.translate(100, 50);
                ctx.rotate(Math.PI / 2);
                ctx.font = `${size}px Arial`;
                ctx.fillStyle = '#000000';
                ctx.fillText(text, 0, 0);
                ctx.restore();
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addRectangle() {
            const x = parseInt(prompt('X position:', '50'));
            const y = parseInt(prompt('Y position:', '50'));
            const w = parseInt(prompt('Width:', '200'));
            const h = parseInt(prompt('Height:', '100'));
            const color = prompt('Fill color (hex):', '#4361ee');
            
            if (x !== null && y !== null && w && h) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, w, h);
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addCircle() {
            const cx = parseInt(prompt('Circle center X:', canvas.width / 2));
            const cy = parseInt(prompt('Circle center Y:', canvas.height / 2));
            const radius = parseInt(prompt('Circle radius:', '80'));
            const color = prompt('Fill color (hex):', '#4361ee');
            const filled = confirm('Fill circle? (Cancel for outline only)');
            
            if (cx !== null && cy !== null && radius) {
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                
                if (filled) {
                    ctx.fillStyle = color;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addLine() {
            const x1 = parseInt(prompt('Start X:', '50'));
            const y1 = parseInt(prompt('Start Y:', '50'));
            const x2 = parseInt(prompt('End X:', '250'));
            const y2 = parseInt(prompt('End Y:', '150'));
            const color = prompt('Line color (hex):', '#000000');
            const width = parseInt(prompt('Line width:', '3'));
            
            if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addPolygon() {
            const sides = parseInt(prompt('Number of sides (3-12):', '6'));
            const cx = parseInt(prompt('Center X:', canvas.width / 2));
            const cy = parseInt(prompt('Center Y:', canvas.height / 2));
            const radius = parseInt(prompt('Radius:', '80'));
            const color = prompt('Fill color (hex):', '#764ba2');
            
            if (sides && cx !== null && cy !== null && radius) {
                ctx.fillStyle = color;
                ctx.beginPath();
                
                for (let i = 0; i < sides; i++) {
                    const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addArrow() {
            const x1 = parseInt(prompt('Start X:', '50'));
            const y1 = parseInt(prompt('Start Y:', '50'));
            const x2 = parseInt(prompt('End X:', '200'));
            const y2 = parseInt(prompt('End Y:', '50'));
            
            if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Arrow head
                const angle = Math.atan2(y2 - y1, x2 - x1);
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 15 * Math.cos(angle - Math.PI / 6), y2 - 15 * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(x2 - 15 * Math.cos(angle + Math.PI / 6), y2 - 15 * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }
        
        function addStar() {
            const cx = parseInt(prompt('Center X:', '100'));
            const cy = parseInt(prompt('Center Y:', '100'));
            const spikes = parseInt(prompt('Number of spikes:', '5'));
            const outerR = parseInt(prompt('Outer radius:', '50'));
            const innerR = outerR * 0.5;
            
            if (cx !== null && cy !== null) {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const r = i % 2 === 0 ? outerR : innerR;
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const x = cx + r * Math.cos(angle);
                    const y = cy + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
            }
        }

        // AI TOOLS
        async function removeBackground() {
            // U2Net RemBG via Google Cloud Run (FREE & PROFESSIONAL)
            showLoadingOverlay('🎯 Removing background with AI...');
            
            try {
                const dataURL = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataURL)).blob();
                
                const formData = new FormData();
                formData.append('image', blob, 'image.png');
                formData.append('model', 'u2net'); // U2Net model for best quality
                formData.append('alpha_matting', 'true'); // Professional edge refinement
                formData.append('alpha_matting_foreground_threshold', '240');
                formData.append('alpha_matting_background_threshold', '10');
                
                // Google Cloud Run endpoint (U2Net RemBG)
                // Deploy using: gcloud run deploy rembg-service --source .
                const CLOUD_RUN_URL = 'https://rembg-service-XXXXX.run.app/remove'; // Replace with your URL
                
                let response = await fetch(CLOUD_RUN_URL, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Cloud Run service unavailable');
                }
                
                const resultBlob = await response.blob();
                const img = new Image();
                img.onload = function() {
                    // Create new layer with transparent background
                    addLayerFromImage(img, 'Background Removed');
                    hideLoadingOverlay();
                    updateImageInfo();
                    alert('✅ Background removed successfully!\n\nℹ️ New layer created. Original preserved.');
                };
                img.src = URL.createObjectURL(resultBlob);
                
            } catch (error) {
                console.error('U2Net RemBG error:', error);
                hideLoadingOverlay();
                alert('❌ Cloud Run service error. Please check deployment.\n\nSetup Guide:\n1. Deploy U2Net to Cloud Run\n2. Update CLOUD_RUN_URL in code\n3. Enable Cloud Run API');
            }
        }
        
        function removeBackgroundLocal() {
            // Smart background removal using edge detection and transparency
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Get background color from corners (average)
            const getBgColor = () => {
                const samples = [
                    [0, 0],
                    [canvas.width - 1, 0],
                    [0, canvas.height - 1],
                    [canvas.width - 1, canvas.height - 1]
                ];
                
                let r = 0, g = 0, b = 0;
                samples.forEach(([x, y]) => {
                    const idx = (y * canvas.width + x) * 4;
                    r += data[idx];
                    g += data[idx + 1];
                    b += data[idx + 2];
                });
                
                return [r / 4, g / 4, b / 4];
            };
            
            const [bgR, bgG, bgB] = getBgColor();
            const tolerance = parseInt(prompt('Tolerance (0-100, higher = more removal):', '30'));
            
            if (tolerance === null) return;
            
            // Remove similar colors to background
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Calculate color difference
                const diff = Math.sqrt(
                    Math.pow(r - bgR, 2) +
                    Math.pow(g - bgG, 2) +
                    Math.pow(b - bgB, 2)
                );
                
                // Make transparent if similar to background
                if (diff < tolerance) {
                    data[i + 3] = 0; // Set alpha to transparent
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Background removed! Download as PNG to preserve transparency.');
        }
        
        function changeBackground() {
            const choice = prompt('Background type:\n1 = Solid Color\n2 = Gradient\n3 = Pattern', '1');
            
            if (choice === '1') {
                const color = prompt('Enter background color (hex):', '#ffffff');
                if (color) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    tempCtx.fillStyle = color;
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    ctx.drawImage(tempCanvas, 0, 0);
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                }
            } else if (choice === '2') {
                const color1 = prompt('Gradient start color (hex):', '#667eea');
                const color2 = prompt('Gradient end color (hex):', '#764ba2');
                if (color1 && color2) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    const gradient = tempCtx.createLinearGradient(0, 0, 0, tempCanvas.height);
                    gradient.addColorStop(0, color1);
                    gradient.addColorStop(1, color2);
                    tempCtx.fillStyle = gradient;
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    ctx.drawImage(tempCanvas, 0, 0);
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                }
            } else if (choice === '3') {
                alert('Pattern backgrounds - select from library coming soon!');
            }
        }
        
        function addBackgroundDesign() {
            const design = prompt('Design type:\n1 = Dots Pattern\n2 = Grid Lines\n3 = Diagonal Stripes\n4 = Bokeh Circles', '1');
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Draw current image
            tempCtx.drawImage(canvas, 0, 0);
            
            if (design === '1') {
                // Dots pattern
                const color = prompt('Dots color (hex):', '#ffffff');
                const spacing = 30;
                tempCtx.fillStyle = color || '#ffffff';
                for (let x = 0; x < canvas.width; x += spacing) {
                    for (let y = 0; y < canvas.height; y += spacing) {
                        tempCtx.globalAlpha = 0.3;
                        tempCtx.beginPath();
                        tempCtx.arc(x, y, 3, 0, Math.PI * 2);
                        tempCtx.fill();
                    }
                }
            } else if (design === '2') {
                // Grid lines
                const color = prompt('Grid color (hex):', '#ffffff');
                tempCtx.strokeStyle = color || '#ffffff';
                tempCtx.lineWidth = 1;
                tempCtx.globalAlpha = 0.2;
                const spacing = 50;
                for (let x = 0; x < canvas.width; x += spacing) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(x, 0);
                    tempCtx.lineTo(x, canvas.height);
                    tempCtx.stroke();
                }
                for (let y = 0; y < canvas.height; y += spacing) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(0, y);
                    tempCtx.lineTo(canvas.width, y);
                    tempCtx.stroke();
                }
            } else if (design === '3') {
                // Diagonal stripes
                const color = prompt('Stripe color (hex):', '#ffffff');
                tempCtx.strokeStyle = color || '#ffffff';
                tempCtx.lineWidth = 2;
                tempCtx.globalAlpha = 0.15;
                const spacing = 20;
                for (let i = -canvas.height; i < canvas.width + canvas.height; i += spacing) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(i, 0);
                    tempCtx.lineTo(i - canvas.height, canvas.height);
                    tempCtx.stroke();
                }
            } else if (design === '4') {
                // Bokeh circles
                const color = prompt('Bokeh color (hex):', '#ffffff');
                tempCtx.fillStyle = color || '#ffffff';
                tempCtx.globalAlpha = 0.1;
                const count = 20;
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = Math.random() * 50 + 20;
                    tempCtx.beginPath();
                    tempCtx.arc(x, y, radius, 0, Math.PI * 2);
                    tempCtx.fill();
                }
            }
            
            tempCtx.globalAlpha = 1;
            ctx.drawImage(tempCanvas, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Background design added!');
        }
        
        function removeObject() {
            // Content-aware fill simulation using blur and clone
            const x = parseInt(prompt('Object center X position (0-' + canvas.width + '):', canvas.width / 2));
            const y = parseInt(prompt('Object center Y position (0-' + canvas.height + '):', canvas.height / 2));
            const radius = parseInt(prompt('Object radius to remove:', '50'));
            
            if (x === null || y === null || radius === null) return;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Sample surrounding pixels and fill the area
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= radius) {
                        const px = x + dx;
                        const py = y + dy;
                        
                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            // Sample from surrounding area
                            const sampleDist = radius + 10;
                            const angle = Math.random() * Math.PI * 2;
                            const sx = Math.floor(x + Math.cos(angle) * sampleDist);
                            const sy = Math.floor(y + Math.sin(angle) * sampleDist);
                            
                            if (sx >= 0 && sx < canvas.width && sy >= 0 && sy < canvas.height) {
                                const sourceIdx = (sy * canvas.width + sx) * 4;
                                const targetIdx = (py * canvas.width + px) * 4;
                                
                                data[targetIdx] = data[sourceIdx];
                                data[targetIdx + 1] = data[sourceIdx + 1];
                                data[targetIdx + 2] = data[sourceIdx + 2];
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Apply blur to blend
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(5px)';
            tempCtx.drawImage(canvas, 0, 0);
            
            // Blend blurred area only in removed region
            ctx.drawImage(tempCanvas, x - radius, y - radius, radius * 2, radius * 2, 
                         x - radius, y - radius, radius * 2, radius * 2);
            
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Object removed! Result may need manual touch-up.');
        }
        
        function enhancePhoto() {
            // Advanced photo enhancement
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Calculate histogram for auto-levels
            let minR = 255, maxR = 0, minG = 255, maxG = 0, minB = 255, maxB = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                minR = Math.min(minR, data[i]);
                maxR = Math.max(maxR, data[i]);
                minG = Math.min(minG, data[i + 1]);
                maxG = Math.max(maxG, data[i + 1]);
                minB = Math.min(minB, data[i + 2]);
                maxB = Math.max(maxB, data[i + 2]);
            }
            
            // Auto levels + saturation + sharpness
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i], g = data[i + 1], b = data[i + 2];
                
                // Auto levels
                r = ((r - minR) / (maxR - minR)) * 255;
                g = ((g - minG) / (maxG - minG)) * 255;
                b = ((b - minB) / (maxB - minB)) * 255;
                
                // Increase saturation
                const avg = (r + g + b) / 3;
                r = Math.min(255, Math.max(0, avg + (r - avg) * 1.4));
                g = Math.min(255, Math.max(0, avg + (g - avg) * 1.4));
                b = Math.min(255, Math.max(0, avg + (b - avg) * 1.4));
                
                // Slight contrast boost
                r = Math.min(255, Math.max(0, ((r - 128) * 1.1) + 128));
                g = Math.min(255, Math.max(0, ((g - 128) * 1.1) + 128));
                b = Math.min(255, Math.max(0, ((b - 128) * 1.1) + 128));
                
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Photo enhanced with AI-like auto-adjustment!');
        }
        
        function upscaleImage() {
            const factor = parseFloat(prompt('Upscale factor (1.5 to 4.0):', '2'));
            if (factor && factor >= 1.5 && factor <= 4) {
                const newWidth = Math.floor(canvas.width * factor);
                const newHeight = Math.floor(canvas.height * factor);
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                
                // Use bicubic interpolation (smoothing)
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
                
                canvas.width = newWidth;
                canvas.height = newHeight;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(tempCanvas, 0, 0);
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                saveToHistory();
                
                document.getElementById('imgDimensions').textContent = `${newWidth} × ${newHeight}px`;
                alert(`Image upscaled to ${newWidth} × ${newHeight}px!`);
            }
        }
        
        function colorizePhoto() {
            // Add color tinting to B&W photos
            const tintColor = prompt('Tint color (hex) for B&W photo:', '#d4a574');
            if (!tintColor) return;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert hex to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            };
            
            const tint = hexToRgb(tintColor);
            if (!tint) {
                alert('Invalid color format!');
                return;
            }
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const intensity = gray / 255;
                
                // Apply sepia-like tinting
                data[i] = Math.min(255, gray * (tint.r / 128));
                data[i + 1] = Math.min(255, gray * (tint.g / 128));
                data[i + 2] = Math.min(255, gray * (tint.b / 128));
            }
            
            ctx.putImageData(imageData, 0, 0);
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            saveToHistory();
            alert('Photo colorized with vintage tint!');
        }
        
        function restorePhoto() {
            // Photo restoration: noise reduction + sharpening + dust removal
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // First pass: Noise reduction (median filter)
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        const values = [];
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                                values.push(tempData[idx]);
                            }
                        }
                        values.sort((a, b) => a - b);
                        const median = values[4]; // Middle value
                        const idx = (y * width + x) * 4 + c;
                        data[idx] = median;
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Second pass: Sharpen
            sharpenFilter();
            
            alert('Photo restored! Noise reduced and details sharpened.');
        }

        // ========== ADDITIONAL AI TOOLS (42 NEW FUNCTIONS) ==========
        
        // Background Tools
        function blurBackground() {
            const blurAmount = parseInt(prompt('Blur amount (1-20):', '10'));
            if (blurAmount) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCtx.filter = `blur(${blurAmount}px)`;
                tempCtx.drawImage(canvas, 0, 0);
                ctx.drawImage(tempCanvas, 0, 0);
                saveToHistory();
                alert('Background blurred!');
            }
        }
        
        function replaceBackground() {
            alert('Upload a background image file to replace current background. Feature uses file picker - coming soon!');
        }
        
        // Enhancement Tools
        function autoColorCorrect() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Auto white balance
            let avgR = 0, avgG = 0, avgB = 0;
            for (let i = 0; i < data.length; i += 4) {
                avgR += data[i];
                avgG += data[i + 1];
                avgB += data[i + 2];
            }
            const count = data.length / 4;
            avgR /= count; avgG /= count; avgB /= count;
            const gray = (avgR + avgG + avgB) / 3;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * (gray / avgR));
                data[i + 1] = Math.min(255, data[i + 1] * (gray / avgG));
                data[i + 2] = Math.min(255, data[i + 2] * (gray / avgB));
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Auto color corrected!');
        }
        
        function denoisePic() {
            // Gaussian blur for noise reduction
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(1px)';
            tempCtx.drawImage(canvas, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0);
            saveToHistory();
            alert('Noise reduced!');
        }
        
        function sharpenAI() {
            sharpenFilter();
            sharpenFilter(); // Double sharpen
            alert('AI Sharpening applied!');
        }
        
        function hdrEffect() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const brightness = (r + g + b) / 3;
                
                // HDR tone mapping
                const factor = brightness < 128 ? 1.3 : 0.8;
                data[i] = Math.min(255, r * factor);
                data[i + 1] = Math.min(255, g * factor);
                data[i + 2] = Math.min(255, b * factor);
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('HDR effect applied!');
        }
        
        // Quality Tools
        function superResolution() {
            const newWidth = canvas.width * 4;
            const newHeight = canvas.height * 4;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = newWidth;
            tempCanvas.height = newHeight;
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';
            tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            ctx.drawImage(tempCanvas, 0, 0);
            saveToHistory();
            alert('Super Resolution 4K applied!');
        }
        
        function deblurImage() {
            sharpenFilter();
            alert('Deblur applied using sharpening!');
        }
        
        function enhanceDetails() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = Math.min(255, avg + (data[i] - avg) * 1.5);
                data[i + 1] = Math.min(255, avg + (data[i + 1] - avg) * 1.5);
                data[i + 2] = Math.min(255, avg + (data[i + 2] - avg) * 1.5);
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Details enhanced!');
        }
        
        // Restoration Tools
        function removeScratch() {
            alert('Select scratch area with mouse - healing brush simulation. Use Clone Stamp or Healing Brush from BRUSH menu.');
        }
        
        function faceRestore() {
            alert('Face restoration uses AI models to enhance facial features - advanced feature coming soon!');
        }
        
        // Object Tools
        function removeWatermark() {
            removeObject(); // Reuse object removal
        }
        
        function removePeople() {
            alert('Select person to remove, then AI will fill the area - use Remove Object tool!');
        }
        
        function cloneObject() {
            alert('Use Clone Stamp tool from BRUSH menu to duplicate objects!');
        }
        
        // Portrait Tools
        function portraitEnhance() {
            skinSmooth();
            eyeEnhance();
            alert('Portrait enhanced with skin smoothing and eye enhancement!');
        }
        
        // ==================== FACE DETECTION & BLUR ====================
        async function faceDetection() {
            showLoadingOverlay('🔍 Detecting faces with AI...');
            
            try {
                const dataURL = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataURL)).blob();
                
                const formData = new FormData();
                formData.append('image', blob, 'image.png');
                
                // Google Cloud Run - Face Detection API
                const response = await fetch(CLOUD_RUN_ENDPOINTS.face_detect || 'https://face-detect-xxxxx.run.app/detect', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error('Face detection service unavailable');
                
                const result = await response.json();
                hideLoadingOverlay();
                
                // Draw rectangles around detected faces
                if (result.faces && result.faces.length > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    
                    result.faces.forEach(face => {
                        ctx.strokeRect(face.x, face.y, face.width, face.height);
                    });
                    
                    alert(`✅ ${result.faces.length} face(s) detected!\\n\\nGreen boxes drawn around faces.\\nUse 'Blur Faces' to blur them.`);
                    saveToHistory();
                } else {
                    alert('ℹ️ No faces detected in image.');
                }
                
            } catch (error) {
                console.error('Face detection error:', error);
                hideLoadingOverlay();
                alert('❌ Face detection service unavailable.\\n\\nPlease deploy face-detect service to Cloud Run.');
            }
        }
        
        async function faceBlur() {
            showLoadingOverlay('🔒 Blurring faces with AI...');
            
            try {
                const dataURL = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataURL)).blob();
                
                const formData = new FormData();
                formData.append('image', blob, 'image.png');
                formData.append('blur_strength', '25'); // Adjustable blur
                
                // Google Cloud Run - Face Blur API
                const response = await fetch(CLOUD_RUN_ENDPOINTS.face_blur || 'https://face-blur-xxxxx.run.app/blur', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error('Face blur service unavailable');
                
                const resultBlob = await response.blob();
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    saveToHistory();
                    hideLoadingOverlay();
                    updateImageInfo();
                    alert('✅ All faces blurred for privacy!');
                };
                img.src = URL.createObjectURL(resultBlob);
                
            } catch (error) {
                console.error('Face blur error:', error);
                hideLoadingOverlay();
                
                // Fallback to local blur
                const useLocal = confirm('❌ Face blur service unavailable.\\n\\nUse basic blur on entire image?');
                if (useLocal) {
                    ctx.filter = 'blur(15px)';
                    ctx.drawImage(canvas, 0, 0);
                    ctx.filter = 'none';
                    saveToHistory();
                    alert('✅ Image blurred!');
                }
            }
        }
        
        // ==================== ADVANCED PHOTO REPAIR ====================
        async function photoRepairAdvanced() {
            showLoadingOverlay('🛠️ Repairing photo with AI...');
            
            try {
                const dataURL = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataURL)).blob();
                
                const formData = new FormData();
                formData.append('image', blob, 'image.png');
                formData.append('repair_type', 'full'); // full, scratches, color, clarity
                
                // Google Cloud Run - Photo Repair API (using GFPGAN or similar)
                const response = await fetch(CLOUD_RUN_ENDPOINTS.photo_repair || 'https://photo-repair-xxxxx.run.app/repair', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error('Photo repair service unavailable');
                
                const resultBlob = await response.blob();
                const img = new Image();
                img.onload = function() {
                    addLayerFromImage(img, 'Repaired Photo');
                    hideLoadingOverlay();
                    updateImageInfo();
                    alert('✅ Photo repaired successfully!\\n\\n• Scratches removed\\n• Colors restored\\n• Clarity enhanced\\n\\nNew layer created!');
                };
                img.src = URL.createObjectURL(resultBlob);
                
            } catch (error) {
                console.error('Photo repair error:', error);
                hideLoadingOverlay();
                
                // Fallback to basic repair
                const useBasic = confirm('❌ Advanced repair unavailable.\\n\\nUse basic repair (denoise + sharpen)?');
                if (useBasic) {
                    photoRepairBasic();
                }
            }
        }
        
        function photoRepairBasic() {
            showLoadingOverlay('Applying basic repair...');
            
            // Step 1: Denoise
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Simple median filter for noise reduction
            for (let i = 0; i < data.length; i += 4) {
                const neighbors = [];
                const x = (i / 4) % canvas.width;
                const y = Math.floor((i / 4) / canvas.width);
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                            const idx = (ny * canvas.width + nx) * 4;
                            neighbors.push({
                                r: data[idx],
                                g: data[idx + 1],
                                b: data[idx + 2]
                            });
                        }
                    }
                }
                
                // Median value
                neighbors.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));
                const median = neighbors[Math.floor(neighbors.length / 2)];
                
                data[i] = median.r;
                data[i + 1] = median.g;
                data[i + 2] = median.b;
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Step 2: Sharpen
            ctx.filter = 'contrast(1.1) brightness(1.05)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';
            
            saveToHistory();
            hideLoadingOverlay();
            alert('✅ Basic repair applied!\\n\\n• Noise reduced\\n• Sharpness enhanced');
        }
        
        // ==================== PERSPECTIVE CORRECTION ====================
        async function perspectiveCorrect() {
            showLoadingOverlay('📐 Correcting perspective...');
            
            try {
                const dataURL = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataURL)).blob();
                
                const formData = new FormData();
                formData.append('image', blob, 'image.png');
                formData.append('auto_detect', 'true'); // Auto-detect edges
                
                // Google Cloud Run - Perspective Correction API
                const response = await fetch(CLOUD_RUN_ENDPOINTS.perspective || 'https://perspective-xxxxx.run.app/correct', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error('Perspective service unavailable');
                
                const resultBlob = await response.blob();
                const img = new Image();
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    saveToHistory();
                    hideLoadingOverlay();
                    updateImageInfo();
                    alert('✅ Perspective corrected!\\n\\nTedhi image ab seedhi ho gayi!');
                };
                img.src = URL.createObjectURL(resultBlob);
                
            } catch (error) {
                console.error('Perspective error:', error);
                hideLoadingOverlay();
                
                // Manual correction
                const useManual = confirm('❌ Auto perspective unavailable.\\n\\nUse manual rotation?');
                if (useManual) {
                    const angle = parseFloat(prompt('Enter rotation angle (-45 to 45 degrees):', '0'));
                    if (angle !== null && !isNaN(angle)) {
                        rotateCanvas(angle);
                    }
                }
            }
        }
        
        function autoStraighten() {
            // Simple auto-straighten based on edge detection
            showLoadingOverlay('Detecting image orientation...');
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Edge detection (simplified Sobel)
            let angleSum = 0;
            let angleCount = 0;
            
            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    const i = (y * canvas.width + x) * 4;
                    
                    // Sobel X
                    const gx = (-data[i - 4 - canvas.width * 4] + data[i + 4 - canvas.width * 4] +
                               -2 * data[i - 4] + 2 * data[i + 4] +
                               -data[i - 4 + canvas.width * 4] + data[i + 4 + canvas.width * 4]);
                    
                    // Sobel Y
                    const gy = (-data[i - 4 - canvas.width * 4] - 2 * data[i - canvas.width * 4] - data[i + 4 - canvas.width * 4] +
                                data[i - 4 + canvas.width * 4] + 2 * data[i + canvas.width * 4] + data[i + 4 + canvas.width * 4]);
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    if (magnitude > 50) {
                        angleSum += Math.atan2(gy, gx);
                        angleCount++;
                    }
                }
            }
            
            if (angleCount > 0) {
                const avgAngle = angleSum / angleCount;
                const degrees = avgAngle * (180 / Math.PI);
                
                // Only apply if skew is significant (> 1 degree)
                if (Math.abs(degrees) > 1) {
                    rotateCanvas(-degrees);
                    hideLoadingOverlay();
                    alert(`✅ Image straightened by ${Math.abs(degrees).toFixed(2)}°`);
                } else {
                    hideLoadingOverlay();
                    alert('ℹ️ Image is already straight! No correction needed.');
                }
            } else {
                hideLoadingOverlay();
                alert('⚠️ Could not detect orientation. Try manual rotation.');
            }
        }
        
        function rotateCanvas(degrees) {
            const radians = degrees * Math.PI / 180;
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Calculate new dimensions
            const cos = Math.abs(Math.cos(radians));
            const sin = Math.abs(Math.sin(radians));
            const newWidth = canvas.width * cos + canvas.height * sin;
            const newHeight = canvas.width * sin + canvas.height * cos;
            
            tempCanvas.width = newWidth;
            tempCanvas.height = newHeight;
            
            // Rotate
            tempCtx.translate(newWidth / 2, newHeight / 2);
            tempCtx.rotate(radians);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            
            // Update main canvas
            canvas.width = newWidth;
            canvas.height = newHeight;
            ctx.clearRect(0, 0, newWidth, newHeight);
            ctx.drawImage(tempCanvas, 0, 0);
            
            saveToHistory();
            updateImageInfo();
        }
        
        function skinSmooth() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(3px)';
            tempCtx.drawImage(canvas, 0, 0);
            
            ctx.globalAlpha = 0.6;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1;
            saveToHistory();
            alert('Skin smoothed!');
        }
        
        function eyeEnhance() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < 100) {
                    data[i] = Math.min(255, data[i] * 1.2);
                    data[i + 1] = Math.min(255, data[i + 1] * 1.2);
                    data[i + 2] = Math.min(255, data[i + 2] * 1.2);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Eye enhancement applied!');
        }
        
        // =====================================================
        // ADVANCED FEATURES - FULLY WORKING IMPLEMENTATIONS
        // =====================================================
        
        /**
         * Advanced Automatic Face Detection
         * Uses Cloud Vision API (1,000 free detections/month)
         * Draws green boxes around detected faces
         */
        async function advancedFaceDetection() {
            showStatus('🔍 Detecting faces...');
            
            try {
                // Convert canvas to blob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                const formData = new FormData();
                formData.append('image', blob, 'image.jpg');
                
                // Call Cloud Vision API for face detection
                const response = await fetch(CLOUD_RUN_ENDPOINTS.face_detect, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Face detection service unavailable');
                }
                
                const result = await response.json();
                
                if (result.faces && result.faces.length > 0) {
                    // Draw boxes around detected faces
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    
                    result.faces.forEach((face, index) => {
                        const x = face.x * canvas.width;
                        const y = face.y * canvas.height;
                        const width = face.width * canvas.width;
                        const height = face.height * canvas.height;
                        
                        ctx.strokeRect(x, y, width, height);
                        
                        // Add face number label
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 20px Arial';
                        ctx.fillText(`Face ${index + 1}`, x, y - 5);
                    });
                    
                    saveToHistory();
                    showStatus(`✅ Detected ${result.faces.length} face(s)!`, 'success');
                } else {
                    showStatus('⚠️ No faces detected', 'warning');
                }
                
            } catch (error) {
                console.error('Face detection error:', error);
                
                // FALLBACK: Local face detection using skin tone
                showStatus('⚙️ Using local face detection...', 'info');
                localFaceDetection();
            }
        }
        
        /**
         * Local Face Detection (Fallback)
         * Uses skin tone analysis to find face-like regions
         */
        function localFaceDetection() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Detect skin tone regions
            const skinRegions = [];
            const gridSize = 50; // Check in 50x50 blocks
            
            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    let skinPixels = 0;
                    let totalPixels = 0;
                    
                    for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            // Skin tone detection (simplified)
                            if (isSkinTone(r, g, b)) {
                                skinPixels++;
                            }
                            totalPixels++;
                        }
                    }
                    
                    // If more than 60% skin tone, mark as potential face
                    if (skinPixels / totalPixels > 0.6) {
                        skinRegions.push({ x, y, width: gridSize, height: gridSize });
                    }
                }
            }
            
            // Merge nearby regions
            const faces = mergeRegions(skinRegions);
            
            // Draw detected faces
            if (faces.length > 0) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                
                faces.forEach((face, index) => {
                    ctx.strokeRect(face.x, face.y, face.width, face.height);
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText(`Face ${index + 1}`, face.x, face.y - 5);
                });
                
                saveToHistory();
                showStatus(`✅ Detected ${faces.length} face(s) locally!`, 'success');
            } else {
                showStatus('⚠️ No faces detected', 'warning');
            }
        }
        
        /**
         * Check if RGB values match skin tone
         */
        function isSkinTone(r, g, b) {
            // Skin tone ranges (simplified)
            return (
                r > 95 && g > 40 && b > 20 &&
                r > g && r > b &&
                Math.abs(r - g) > 15 &&
                r - b > 15 && r - b < 150
            );
        }
        
        /**
         * Merge nearby face regions
         */
        function mergeRegions(regions) {
            if (regions.length === 0) return [];
            
            const merged = [];
            const used = new Set();
            
            regions.forEach((region, i) => {
                if (used.has(i)) return;
                
                let minX = region.x;
                let minY = region.y;
                let maxX = region.x + region.width;
                let maxY = region.y + region.height;
                
                // Find overlapping regions
                regions.forEach((other, j) => {
                    if (i !== j && !used.has(j)) {
                        const distance = Math.sqrt(
                            Math.pow(region.x - other.x, 2) + 
                            Math.pow(region.y - other.y, 2)
                        );
                        
                        if (distance < 100) { // Merge if close
                            minX = Math.min(minX, other.x);
                            minY = Math.min(minY, other.y);
                            maxX = Math.max(maxX, other.x + other.width);
                            maxY = Math.max(maxY, other.y + other.height);
                            used.add(j);
                        }
                    }
                });
                
                merged.push({
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                });
                used.add(i);
            });
            
            return merged;
        }
        
        /**
         * Advanced Face Blur (Privacy Protection)
         * Automatically blurs all detected faces
         */
        async function advancedFaceBlur() {
            showStatus('😶‍🌫️ Blurring faces for privacy...');
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                const formData = new FormData();
                formData.append('image', blob, 'image.jpg');
                formData.append('blur_strength', '25'); // Strong blur for privacy
                
                const response = await fetch(CLOUD_RUN_ENDPOINTS.face_blur, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Face blur service unavailable');
                }
                
                const resultBlob = await response.blob();
                const img = await loadImage(URL.createObjectURL(resultBlob));
                
                // Replace canvas with blurred version
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                saveToHistory();
                showStatus('✅ Faces blurred successfully!', 'success');
                
            } catch (error) {
                console.error('Face blur error:', error);
                showStatus('⚙️ Using local face blur...', 'info');
                localFaceBlur();
            }
        }
        
        /**
         * Local Face Blur (Fallback)
         * Detects and blurs faces locally
         */
        async function localFaceBlur() {
            // First detect faces
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Simple skin tone detection for face regions
            const gridSize = 50;
            const faceRegions = [];
            
            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    let skinPixels = 0;
                    
                    for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            if (isSkinTone(data[i], data[i + 1], data[i + 2])) {
                                skinPixels++;
                            }
                        }
                    }
                    
                    if (skinPixels > (gridSize * gridSize * 0.6)) {
                        faceRegions.push({ x, y, width: gridSize, height: gridSize });
                    }
                }
            }
            
            // Blur each detected face region
            if (faceRegions.length > 0) {
                faceRegions.forEach(region => {
                    blurRegion(region.x, region.y, region.width, region.height, 15);
                });
                
                saveToHistory();
                showStatus(`✅ Blurred ${faceRegions.length} face region(s)!`, 'success');
            } else {
                showStatus('⚠️ No faces detected to blur', 'warning');
            }
        }
        
        /**
         * Blur specific region of canvas
         */
        function blurRegion(x, y, width, height, radius) {
            const regionData = ctx.getImageData(x, y, width, height);
            const blurred = gaussianBlur(regionData, radius);
            ctx.putImageData(blurred, x, y);
        }
        
        /**
         * Gaussian Blur Algorithm
         */
        function gaussianBlur(imageData, radius) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(data.length);
            
            // Horizontal pass
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;
                    
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = x + dx;
                        if (nx >= 0 && nx < width) {
                            const i = (y * width + nx) * 4;
                            r += data[i];
                            g += data[i + 1];
                            b += data[i + 2];
                            a += data[i + 3];
                            count++;
                        }
                    }
                    
                    const i = (y * width + x) * 4;
                    output[i] = r / count;
                    output[i + 1] = g / count;
                    output[i + 2] = b / count;
                    output[i + 3] = a / count;
                }
            }
            
            // Vertical pass
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        const ny = y + dy;
                        if (ny >= 0 && ny < height) {
                            const i = (ny * width + x) * 4;
                            r += output[i];
                            g += output[i + 1];
                            b += output[i + 2];
                            a += output[i + 3];
                            count++;
                        }
                    }
                    
                    const i = (y * width + x) * 4;
                    data[i] = r / count;
                    data[i + 1] = g / count;
                    data[i + 2] = b / count;
                    data[i + 3] = a / count;
                }
            }
            
            return new ImageData(data, width, height);
        }
        
        /**
         * Advanced Photo Repair & Restoration
         * Uses AI model for professional repair
         */
        async function advancedPhotoRepair() {
            showStatus('🔧 Repairing photo with AI...');
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                const formData = new FormData();
                formData.append('image', blob, 'image.jpg');
                formData.append('strength', 'medium'); // low, medium, high
                
                const response = await fetch(CLOUD_RUN_ENDPOINTS.photo_repair, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Photo repair service unavailable');
                }
                
                const resultBlob = await response.blob();
                const img = await loadImage(URL.createObjectURL(resultBlob));
                
                // Create new layer with repaired image
                addLayerFromImage(img, 'AI Repaired Photo');
                
                showStatus('✅ Photo repaired with AI!', 'success');
                
            } catch (error) {
                console.error('Photo repair error:', error);
                showStatus('⚙️ Using advanced local repair...', 'info');
                localPhotoRepair();
            }
        }
        
        /**
         * Local Photo Repair (Advanced Algorithm)
         * Multi-stage repair: Denoise → Enhance → Sharpen
         */
        function localPhotoRepair() {
            showStatus('🔧 Applying advanced local repair...');
            
            // Stage 1: Advanced Noise Removal
            const denoised = advancedDenoise(canvas);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(denoised, 0, 0);
            
            // Stage 2: Color Enhancement
            enhanceColors();
            
            // Stage 3: Edge Sharpening
            sharpenEdges();
            
            // Stage 4: Contrast Improvement
            improveContrast();
            
            saveToHistory();
            showStatus('✅ Photo repaired locally!', 'success');
        }
        
        /**
         * Advanced Noise Removal Algorithm
         * Uses Non-Local Means Denoising
         */
        function advancedDenoise(sourceCanvas) {
            const imageData = ctx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const output = new Uint8ClampedArray(data.length);
            
            const searchWindow = 11; // Search window size
            const templateWindow = 5; // Template window size
            const h = 10; // Filtering strength
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sumR = 0, sumG = 0, sumB = 0, sumWeight = 0;
                    
                    // Search in surrounding area
                    for (let sy = Math.max(0, y - searchWindow); sy < Math.min(height, y + searchWindow); sy++) {
                        for (let sx = Math.max(0, x - searchWindow); sx < Math.min(width, x + searchWindow); sx++) {
                            
                            // Calculate similarity between patches
                            let diff = 0;
                            let count = 0;
                            
                            for (let ty = -templateWindow; ty <= templateWindow; ty++) {
                                for (let tx = -templateWindow; tx <= templateWindow; tx++) {
                                    const y1 = y + ty;
                                    const x1 = x + tx;
                                    const y2 = sy + ty;
                                    const x2 = sx + tx;
                                    
                                    if (y1 >= 0 && y1 < height && x1 >= 0 && x1 < width &&
                                        y2 >= 0 && y2 < height && x2 >= 0 && x2 < width) {
                                        
                                        const i1 = (y1 * width + x1) * 4;
                                        const i2 = (y2 * width + x2) * 4;
                                        
                                        diff += Math.pow(data[i1] - data[i2], 2);
                                        diff += Math.pow(data[i1 + 1] - data[i2 + 1], 2);
                                        diff += Math.pow(data[i1 + 2] - data[i2 + 2], 2);
                                        count++;
                                    }
                                }
                            }
                            
                            diff = diff / count;
                            const weight = Math.exp(-diff / (h * h));
                            
                            const i = (sy * width + sx) * 4;
                            sumR += data[i] * weight;
                            sumG += data[i + 1] * weight;
                            sumB += data[i + 2] * weight;
                            sumWeight += weight;
                        }
                    }
                    
                    const i = (y * width + x) * 4;
                    output[i] = sumR / sumWeight;
                    output[i + 1] = sumG / sumWeight;
                    output[i + 2] = sumB / sumWeight;
                    output[i + 3] = data[i + 3];
                }
            }
            
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = width;
            resultCanvas.height = height;
            const resultCtx = resultCanvas.getContext('2d');
            resultCtx.putImageData(new ImageData(output, width, height), 0, 0);
            
            return resultCanvas;
        }
        
        /**
         * Enhance Colors (Advanced)
         */
        function enhanceColors() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Increase saturation
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = (max - min) / max;
                
                if (saturation < 0.5) {
                    const factor = 1.2;
                    data[i] = Math.min(255, r * factor);
                    data[i + 1] = Math.min(255, g * factor);
                    data[i + 2] = Math.min(255, b * factor);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        /**
         * Sharpen Edges (Advanced)
         */
        function sharpenEdges() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const output = new Uint8ClampedArray(data.length);
            
            // Sharpening kernel
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const i = ((y + ky) * width + (x + kx)) * 4 + c;
                                const ki = (ky + 1) * 3 + (kx + 1);
                                sum += data[i] * kernel[ki];
                            }
                        }
                        
                        const i = (y * width + x) * 4 + c;
                        output[i] = Math.max(0, Math.min(255, sum));
                    }
                    
                    const i = (y * width + x) * 4 + 3;
                    output[i] = data[i];
                }
            }
            
            ctx.putImageData(new ImageData(output, width, height), 0, 0);
        }
        
        /**
         * Improve Contrast (Advanced)
         */
        function improveContrast() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Calculate histogram
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
                const brightness = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                histogram[brightness]++;
            }
            
            // Calculate cumulative distribution
            const cdf = new Array(256);
            cdf[0] = histogram[0];
            for (let i = 1; i < 256; i++) {
                cdf[i] = cdf[i - 1] + histogram[i];
            }
            
            // Normalize
            const totalPixels = canvas.width * canvas.height;
            const cdfMin = cdf.find(v => v > 0);
            
            for (let i = 0; i < data.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    const oldValue = data[i + c];
                    const newValue = Math.round(((cdf[oldValue] - cdfMin) / (totalPixels - cdfMin)) * 255);
                    data[i + c] = newValue;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        /**
         * Perspective Correction (Tedhe Image Ko Barabar)
         * Auto-detects and corrects perspective distortion
         */
        async function perspectiveCorrection() {
            showStatus('📐 Correcting perspective...');
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                const formData = new FormData();
                formData.append('image', blob, 'image.jpg');
                
                const response = await fetch(CLOUD_RUN_ENDPOINTS.perspective, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Perspective correction service unavailable');
                }
                
                const resultBlob = await response.blob();
                const img = await loadImage(URL.createObjectURL(resultBlob));
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                saveToHistory();
                updateImageInfo();
                showStatus('✅ Perspective corrected!', 'success');
                
            } catch (error) {
                console.error('Perspective correction error:', error);
                showStatus('⚙️ Using auto-straighten...', 'info');
                autoStraighten();
            }
        }
        
        /**
         * Auto-Straighten (Local Algorithm)
         * Detects tilt and auto-rotates
         */
        function autoStraighten() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Detect edges using Sobel operator
            const edgeData = detectEdges(imageData);
            
            // Find dominant angles
            const angles = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    if (edgeData[i] > 100) { // Strong edge
                        // Calculate gradient direction
                        const dx = edgeData[i] - edgeData[i - 4];
                        const dy = edgeData[i] - edgeData[i - width * 4];
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        angles.push(angle);
                    }
                }
            }
            
            if (angles.length === 0) {
                showStatus('⚠️ Could not detect edges for straightening', 'warning');
                return;
            }
            
            // Calculate average angle
            const avgAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
            
            // Only rotate if tilt is significant
            if (Math.abs(avgAngle) > 1) {
                rotateCanvas(-avgAngle);
                showStatus(`✅ Image straightened by ${avgAngle.toFixed(2)}°`, 'success');
            } else {
                showStatus('✅ Image is already straight!', 'success');
            }
        }
        
        /**
         * Detect Edges using Sobel Operator
         */
        function detectEdges(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(data.length);
            
            // Sobel kernels
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const i = ((y + ky) * width + (x + kx)) * 4;
                            const ki = (ky + 1) * 3 + (kx + 1);
                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            
                            gx += brightness * sobelX[ki];
                            gy += brightness * sobelY[ki];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const i = (y * width + x) * 4;
                    output[i] = output[i + 1] = output[i + 2] = Math.min(255, magnitude);
                    output[i + 3] = 255;
                }
            }
            
            return output;
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Eyes enhanced!');
        }
        
        function teethWhiten() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (avg > 180) {
                    data[i] = Math.min(255, data[i] + 10);
                    data[i + 1] = Math.min(255, data[i + 1] + 10);
                    data[i + 2] = Math.min(255, data[i + 2] + 10);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Teeth whitened!');
        }
        
        function beautifyFace() {
            portraitEnhance();
            alert('Face beautified!');
        }
        
        // Lighting Tools
        function autoExposure() {
            autoAdjust();
        }
        
        function shadowRecovery() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < 128) {
                    const boost = 1.5;
                    data[i] = Math.min(255, data[i] * boost);
                    data[i + 1] = Math.min(255, data[i + 1] * boost);
                    data[i + 2] = Math.min(255, data[i + 2] * boost);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Shadows recovered!');
        }
        
        function highlightFix() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness > 200) {
                    const reduce = 0.8;
                    data[i] = Math.max(0, data[i] * reduce);
                    data[i + 1] = Math.max(0, data[i + 1] * reduce);
                    data[i + 2] = Math.max(0, data[i + 2] * reduce);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Highlights fixed!');
        }
        
        function lowLightBoost() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.8);
                data[i + 1] = Math.min(255, data[i + 1] * 1.8);
                data[i + 2] = Math.min(255, data[i + 2] * 1.8);
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Low light boosted!');
        }
        
        // Style Transfer
        function artisticStyle() {
            alert('Apply artistic styles like Van Gogh, Monet - advanced AI feature coming soon!');
        }
        
        function cartoonize() {
            posterizeFilter();
            edgeDetect();
            alert('Cartoonized with posterize + edge detect!');
        }
        
        function sketchEffect() {
            applyFilter('grayscale');
            applyFilter('invert');
            edgeDetect();
            applyFilter('invert');
            alert('Sketch effect applied!');
        }
        
        function oilPainting() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(2px)';
            tempCtx.drawImage(canvas, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0);
            saveToHistory();
            alert('Oil painting effect applied!');
        }
        
        function watercolor() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(4px) saturate(1.5)';
            tempCtx.drawImage(canvas, 0, 0);
            ctx.globalAlpha = 0.7;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1;
            saveToHistory();
            alert('Watercolor effect applied!');
        }
        
        // Sky & Scene
        function skyReplacement() {
            alert('Select sky area and replace with new sky - advanced AI feature!');
        }
        
        function weatherChange() {
            alert('Add rain, snow, fog effects - weather simulation coming soon!');
        }
        
        function seasonChange() {
            const season = prompt('Change to season: summer, autumn, winter, spring', 'autumn');
            if (season === 'autumn') {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * 1.2);
                    data[i + 1] = Math.min(255, data[i + 1] * 0.9);
                }
                ctx.putImageData(imageData, 0, 0);
                saveToHistory();
                alert('Autumn tone applied!');
            } else {
                alert('Season change for ' + season + ' coming soon!');
            }
        }
        
        function dayToNight() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = data[i] * 0.3;
                data[i + 1] = data[i + 1] * 0.3;
                data[i + 2] = Math.min(255, data[i + 2] * 0.5);
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Converted to night mode!');
        }
        
        // Effects
        function vintageLook() {
            presetEffect('vintage');
        }
        
        function glowEffect() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(10px) brightness(1.5)';
            tempCtx.drawImage(canvas, 0, 0);
            
            ctx.globalAlpha = 0.5;
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
            saveToHistory();
            alert('Glow effect applied!');
        }
        
        function bokehEffect() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.filter = 'blur(15px)';
            tempCtx.drawImage(canvas, 0, 0);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
            saveToHistory();
            alert('Bokeh effect applied!');
        }
        
        function cinematicLook() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.1);
                data[i + 1] = Math.max(0, data[i + 1] * 0.95);
                data[i + 2] = Math.min(255, data[i + 2] * 1.05);
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Cinematic color grade applied!');
        }
        
        // Smart Tools
        function smartCrop() {
            alert('AI detects main subject and crops automatically - advanced feature!');
        }
        
        function autoStraighten() {
            const angle = parseFloat(prompt('Auto-straighten angle (-10 to 10):', '0'));
            if (angle !== null) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                tempCtx.translate(canvas.width / 2, canvas.height / 2);
                tempCtx.rotate((angle * Math.PI) / 180);
                tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                saveToHistory();
                alert('Image straightened!');
            }
        }
        
        function perspectiveFix() {
            alert('Use Perspective tool from TRANSFORM menu!');
        }
        
        function redEyeRemoval() {
            const x = parseInt(prompt('Eye X position:', canvas.width / 2));
            const y = parseInt(prompt('Eye Y position:', canvas.height / 3));
            const radius = 20;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const px = x + dx;
                        const py = y + dy;
                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            const idx = (py * canvas.width + px) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            if (r > g * 1.5 && r > b * 1.5) {
                                data[idx] = (g + b) / 2;
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            saveToHistory();
            alert('Red eye removed!');
        }
        
        // Advanced AI
        function depthMap() {
            applyFilter('grayscale');
            alert('Depth map generated (grayscale)! Use for 3D effects.');
        }
        
        function edgeDetectAI() {
            edgeDetect();
        }
        
        function imageToImage() {
            alert('AI Image-to-Image generation - transform your photo with AI prompts. Advanced feature!');
        }
        
        function inpaintAI() {
            alert('Select area to inpaint and AI will fill intelligently - use Remove Object for now!');
        }

        // IMAGE UTILITIES
        function compressImage() {
            const quality = parseFloat(prompt('Quality (0.1 to 1.0):', '0.8'));
            if (quality) {
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = 'compressed-' + Date.now() + '.jpg';
                    link.href = url;
                    link.click();
                    alert('Compressed image downloaded!');
                }, 'image/jpeg', quality);
            }
        }
        
        /**
         * Advanced Noise Removal (Fully Working)
         * Multi-level denoise with edge preservation
         */
        async function advancedNoiseRemoval() {
            showStatus('🧹 Removing noise (advanced algorithm)...');
            
            try {
                // Try Cloud Run service first (if available)
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                const formData = new FormData();
                formData.append('image', blob, 'image.jpg');
                formData.append('strength', 'medium'); // low, medium, high
                
                const response = await fetch(CLOUD_RUN_ENDPOINTS.denoise || 'https://YOUR_PROJECT-denoise-XXXXX.run.app/denoise', {
                    method: 'POST',
                    body: formData,
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });
                
                if (response.ok) {
                    const resultBlob = await response.blob();
                    const img = await loadImage(URL.createObjectURL(resultBlob));
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    saveToHistory();
                    showStatus('✅ Noise removed with AI!', 'success');
                    return;
                }
            } catch (error) {
                console.log('Cloud service unavailable, using local denoise');
            }
            
            // Fallback to local advanced denoise
            localAdvancedDenoise();
        }
        
        /**
         * Local Advanced Denoise (Fully Working Fallback)
         * Combination of Bilateral Filter + Median Filter
         */
        function localAdvancedDenoise() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const output = new Uint8ClampedArray(data.length);
            
            // Bilateral filter parameters
            const radius = 5;
            const sigmaSpace = 10;
            const sigmaColor = 50;
            
            showStatus('⚙️ Processing... (This may take a moment)', 'info');
            
            // Use setTimeout to avoid blocking UI
            setTimeout(() => {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        
                        let sumR = 0, sumG = 0, sumB = 0, sumWeight = 0;
                        
                        // Sample neighborhood
                        for (let dy = -radius; dy <= radius; dy += 2) {
                            for (let dx = -radius; dx <= radius; dx += 2) {
                                const ny = y + dy;
                                const nx = x + dx;
                                
                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const ni = (ny * width + nx) * 4;
                                    
                                    // Spatial weight
                                    const spatialDist = dx * dx + dy * dy;
                                    const spatialWeight = Math.exp(-spatialDist / (2 * sigmaSpace * sigmaSpace));
                                    
                                    // Color weight
                                    const colorDiff = Math.pow(data[i] - data[ni], 2) +
                                                     Math.pow(data[i + 1] - data[ni + 1], 2) +
                                                     Math.pow(data[i + 2] - data[ni + 2], 2);
                                    const colorWeight = Math.exp(-colorDiff / (2 * sigmaColor * sigmaColor));
                                    
                                    const weight = spatialWeight * colorWeight;
                                    
                                    sumR += data[ni] * weight;
                                    sumG += data[ni + 1] * weight;
                                    sumB += data[ni + 2] * weight;
                                    sumWeight += weight;
                                }
                            }
                        }
                        
                        output[i] = sumR / sumWeight;
                        output[i + 1] = sumG / sumWeight;
                        output[i + 2] = sumB / sumWeight;
                        output[i + 3] = data[i + 3];
                    }
                    
                    // Update progress
                    if (y % 50 === 0) {
                        showStatus(`⚙️ Processing... ${Math.round((y / height) * 100)}%`, 'info');
                    }
                }
                
                // Apply result
                ctx.putImageData(new ImageData(output, width, height), 0, 0);
                saveToHistory();
                showStatus('✅ Advanced noise removal complete!', 'success');
            }, 100);
        }
        
        /**
         * Helper function to load image from URL
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }
        
        /**
         * Show status message with type
         */
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message') || createStatusDiv();
            
            statusDiv.textContent = message;
            statusDiv.className = 'status-message status-' + type;
            statusDiv.style.display = 'block';
            
            // Auto-hide after 3 seconds for success/info
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }
        
        /**
         * Create status message div if not exists
         */
        function createStatusDiv() {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'status-message';
            statusDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                border-radius: 8px;
                font-weight: 600;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                display: none;
                max-width: 400px;
            `;
            document.body.appendChild(statusDiv);
            
            // Add CSS for different status types
            const style = document.createElement('style');
            style.textContent = `
                .status-info {
                    background: #3498db;
                    color: white;
                }
                .status-success {
                    background: #2ecc71;
                    color: white;
                }
                .status-warning {
                    background: #f39c12;
                    color: white;
                }
                .status-error {
                    background: #e74c3c;
                    color: white;
                }
            `;
            document.head.appendChild(style);
            
            return statusDiv;
        }
        
        function convertFormat() {
            const format = prompt('Convert to format (png, jpg, webp):', 'png');
            if (format) {
                exportAs(); // Reuse export function
            }
        }
    </script>
</body>
</html>

