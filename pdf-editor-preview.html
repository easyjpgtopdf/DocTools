<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>PDF Editor Online Free - Edit PDF Files Online Without Installation | easyjpgtopdf</title>
    <meta name="description" content="Edit PDF files online for free. Add text, images, annotations, modify PDF documents, highlight content, OCR text extraction - all without software installation. Best free online PDF editor 2024.">
    <meta name="keywords" content="pdf editor online free, edit pdf online, free pdf editor, online pdf editor, edit pdf files, pdf editing tool, modify pdf, edit pdf documents, pdf editor free online, best pdf editor online, edit pdf online free no download, pdf editor website, free online pdf editor, edit pdf text, pdf editor tool, pdf editor with ocr, edit pdf online free, pdf editor no download, online pdf editor free, edit pdf online tool">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://easyjpgtopdf.com/pdf-editor-preview.html">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
    <!-- Preload Critical CSS -->
    <link rel="preload" href="css/header.css" as="style">
    <link rel="preload" href="css/footer.css" as="style">
    
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/theme-modern.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PDF.js for rendering (Fast, Lightweight) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- pdf-lib for real PDF editing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    
    <!-- Professional PDF Editor using enhanced pdf.js + pdf-lib -->
    
    <!-- Schema Markup for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "PDF Editor Online Free",
      "description": "Free online PDF editor to edit PDF files, add text, images, annotations, and extract text with OCR. No software installation required.",
      "url": "https://easyjpgtopdf.com/pdf-editor-preview.html",
      "applicationCategory": "UtilityApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "Edit PDF text online",
        "Add images to PDF",
        "Highlight and annotate PDFs",
        "OCR text extraction",
        "Export to Word, Excel, PowerPoint",
        "Cloud storage integration",
        "No software installation required"
      ],
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "2024",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "1250"
      }
    }
    </script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "PDF Editor Online",
      "applicationCategory": "MultimediaApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free online PDF editor with OCR, text editing, image insertion, annotations, and cloud storage. Edit PDFs without installation.",
      "featureList": [
        "Text editing",
        "Image insertion",
        "Highlighting and annotations",
        "OCR text extraction",
        "Export to multiple formats",
        "Cloud storage"
      ]
    }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #f5f7ff;
            color: #0b1630;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        main {
            flex: 1;
            padding: 30px 0;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .page-header h1 {
            font-size: 2.2rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Professional Editor Workspace */
        .editor-workspace {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 800px;
            background: #2b2b2b;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        /* Left Tools Panel */
        .tools-panel {
            width: 240px;
            min-width: 240px;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .tool-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .tool-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 5px;
        }
        
        .tool-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: #e5e5e5;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-item:hover {
            background: #2d2d2d;
        }
        
        .tool-item.active {
            background: #0078d4;
            color: white;
        }
        
        .tool-item i {
            width: 20px;
            text-align: center;
        }
        
        /* Center Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            overflow: hidden;
        }
        
        .preview-toolbar {
            background: #2b2b2b;
            border-bottom: 1px solid #3a3a3a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .preview-toolbar-btn {
            padding: 6px 12px;
            background: transparent;
            color: #e5e5e5;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .preview-toolbar-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }
        
        .preview-toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
            background: #525252;
            padding: 20px;
            min-height: 100%;
        }
        
        .pdf-page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 0 auto;
        }
        
        .pdf-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        
        /* Overlay system removed - using native PDF editing only */
        
        .deletion-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .deletion-rect {
            position: absolute;
            background: white;
            border: none;
            pointer-events: auto;
            z-index: 6;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #0b1630;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            width: 300px;
            max-width: 80%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .loading-percentage {
            color: #4361ee;
            font-size: 14px;
            margin-top: 8px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile Optimization - Touch Gestures & Responsive UI */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tool-group {
                min-width: 120px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .tool-item {
                min-height: 60px;
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item i {
                font-size: 20px;
                margin-bottom: 4px;
            }
            
            .preview-panel {
                flex: 1;
                min-height: 60vh;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-left: none;
                border-top: 1px solid #3a3a3a;
            }
            
            .property-group {
                min-width: 150px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .pdf-canvas {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            .preview-toolbar-btn {
                min-width: 60px;
                min-height: 44px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            .editable-text {
                min-height: 24px;
                min-width: 30px;
                padding: 4px 6px;
            }
        }
        
        /* Touch Gesture Support */
        .pdf-canvas {
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Larger Touch Targets for Mobile */
        @media (max-width: 768px) {
            button, .tool-item, .preview-toolbar-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            input[type="number"],
            input[type="color"],
            select {
                min-height: 44px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        
        /* Right Properties Panel */
        .properties-panel {
            width: 160px;
            min-width: 160px;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .property-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .property-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 8px;
        }
        
        .property-item {
            padding: 8px 12px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-label {
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .property-input {
            width: 100%;
            padding: 4px 8px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        /* Performance indicators */
        .performance-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        /* Performance Optimizations */
        .pdf-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Lazy loading for pages */
        .pdf-page-wrapper[data-loaded="false"] {
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .pdf-page-wrapper[data-loaded="true"] {
            opacity: 1;
        }
        
        /* Cache optimization */
        .tool-item {
            will-change: transform;
        }
        
        /* Smooth scrolling */
        .tools-panel, .properties-panel {
            scroll-behavior: smooth;
        }
        
        /* Mobile Support - Full Responsive */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: auto;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                flex-direction: row;
                overflow-x: auto;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
                -webkit-overflow-scrolling: touch;
            }
            
            .tool-group {
                min-width: 200px;
                flex-shrink: 0;
            }
            
            .preview-panel {
                order: 2;
                min-height: 500px;
            }
            
            .preview-container {
                min-height: 400px !important;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                order: 3;
                border-left: none;
                border-top: 1px solid #3a3a3a;
                max-height: 300px;
            }
            
            .tool-item {
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item span {
                display: block;
                margin-top: 4px;
            }
            
            /* Touch-friendly buttons */
            .preview-toolbar-btn {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Mobile gestures */
            .pdf-page-wrapper {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            /* Enhanced mobile touch targets */
            .tool-item {
                min-width: 50px;
                min-height: 50px;
            }
            
            /* Mobile-friendly zoom controls */
            .zoom-controls {
                position: fixed;
                bottom: 20px;
                right: 20px;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .zoom-btn {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: #4361ee;
                color: white;
                border: none;
                font-size: 20px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }
        }
        
        /* Real-time Collaboration Styles */
        .collaboration-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 300px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .collaboration-panel.active {
            display: block;
        }
        
        .collaboration-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .collaboration-title {
            font-size: 16px;
            font-weight: 600;
            color: #e5e5e5;
        }
        
        .collaboration-user {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
        }
        
        .collaboration-user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4361ee;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .collaboration-user-name {
            color: #e5e5e5;
            font-size: 14px;
        }
        
        .collaboration-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-left: auto;
        }
        
        .collaboration-chat {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }
        
        .collaboration-message {
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
            font-size: 12px;
            color: #e5e5e5;
        }
        
        .collaboration-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <script src="js/global-components.js"></script>
    <div id="global-header-placeholder"></div>
    <div id="global-breadcrumb-placeholder"></div>
    
    <main>
        <div class="container">
            <div class="page-header">
                <h1>PDF Editor Online Free - Edit PDF Files Without Installation <span class="performance-badge">‚ö° Instant</span></h1>
                <p>Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required - edit PDFs directly in your browser.</p>
            </div>
            
            <!-- Professional Editor Workspace -->
            <div class="editor-workspace">
                <!-- Left Tools Panel -->
                <div class="tools-panel">
                    <div class="tool-group">
                        <div class="tool-group-title">File</div>
                        <div class="tool-item" id="upload-btn" title="Upload PDF">
                            <i class="fas fa-upload"></i>
                            <span>Upload</span>
                        </div>
                        <div class="tool-item" id="download-btn" title="Download PDF">
                            <i class="fas fa-download"></i>
                            <span>Download</span>
                        </div>
                        <div class="tool-item" id="save-cloud-btn" title="Save to Cloud">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <span>Save to Cloud</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Edit</div>
                        <div class="tool-item" id="select-tool" title="Select Tool" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i>
                            <span>Select</span>
                        </div>
                        <div class="tool-item" id="add-text-btn" title="Add Text" data-tool="text">
                            <i class="fas fa-font"></i>
                            <span>Add Text</span>
                        </div>
                        <div class="tool-item" id="add-image-btn" title="Add Image" data-tool="image">
                            <i class="fas fa-image"></i>
                            <span>Add Image</span>
                        </div>
                        <div class="tool-item" id="highlight-btn" title="Highlight" data-tool="highlight">
                            <i class="fas fa-highlighter"></i>
                            <span>Highlight</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">OCR <span class="performance-badge">‚ö° Fast</span></div>
                        <div class="tool-item" id="ocr-btn" title="Google Cloud Vision OCR">
                            <i class="fas fa-language"></i>
                            <span>OCR</span>
                        </div>
                        <div class="tool-item" id="ocr-server-btn" title="Server-Side Fast OCR">
                            <i class="fas fa-server"></i>
                            <span>Fast Server OCR</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Page Management</div>
                        <div class="tool-item" id="rotate-page-btn" title="Rotate Page">
                            <i class="fas fa-redo"></i>
                            <span>Rotate</span>
                        </div>
                        <div class="tool-item" id="delete-page-btn" title="Delete Page">
                            <i class="fas fa-trash"></i>
                            <span>Delete Page</span>
                        </div>
                        <div class="tool-item" id="reorder-pages-btn" title="Reorder Pages">
                            <i class="fas fa-sort"></i>
                            <span>Reorder</span>
                        </div>
                        <div class="tool-item" id="extract-page-btn" title="Extract Page">
                            <i class="fas fa-file-export"></i>
                            <span>Extract</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Forms</div>
                        <div class="tool-item" id="fill-form-btn" title="Fill Form Fields">
                            <i class="fas fa-edit"></i>
                            <span>Fill Form</span>
                        </div>
                        <div class="tool-item" id="detect-form-btn" title="Detect Form Fields">
                            <i class="fas fa-search"></i>
                            <span>Detect Fields</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Annotations</div>
                        <div class="tool-item" id="comment-btn" title="Add Comment">
                            <i class="fas fa-comment"></i>
                            <span>Comment</span>
                        </div>
                        <div class="tool-item" id="stamp-btn" title="Add Stamp">
                            <i class="fas fa-stamp"></i>
                            <span>Stamp</span>
                        </div>
                        <div class="tool-item" id="shape-btn" title="Add Shape">
                            <i class="fas fa-shapes"></i>
                            <span>Shape</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Export</div>
                        <div class="tool-item" id="export-word-btn" title="Export to Word">
                            <i class="fas fa-file-word"></i>
                            <span>Word</span>
                        </div>
                        <div class="tool-item" id="export-excel-btn" title="Export to Excel">
                            <i class="fas fa-file-excel"></i>
                            <span>Excel</span>
                        </div>
                        <div class="tool-item" id="export-ppt-btn" title="Export to PowerPoint">
                            <i class="fas fa-file-powerpoint"></i>
                            <span>PowerPoint</span>
                        </div>
                        <div class="tool-item" id="export-image-btn" title="Export to Images">
                            <i class="fas fa-image"></i>
                            <span>Images</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Collaboration</div>
                        <div class="tool-item" id="collaboration-btn" title="Real-time Collaboration">
                            <i class="fas fa-users"></i>
                            <span>Share</span>
                        </div>
                        <div class="tool-item" id="add-page-btn" title="Add New Page">
                            <i class="fas fa-plus-square"></i>
                            <span>Add Page</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Tools</div>
                        <div class="tool-item" id="compress-btn" title="Compress PDF">
                            <i class="fas fa-compress"></i>
                            <span>Compress</span>
                        </div>
                        <div class="tool-item" id="merge-btn" title="Merge PDFs">
                            <i class="fas fa-layer-group"></i>
                            <span>Merge</span>
                        </div>
                        <div class="tool-item" id="split-btn" title="Split PDF">
                            <i class="fas fa-cut"></i>
                            <span>Split</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Security & Extra</div>
                        <div class="tool-item" id="watermark-btn" title="Add Watermark">
                            <i class="fas fa-tint"></i>
                            <span>Watermark</span>
                        </div>
                        <div class="tool-item" id="sign-btn" title="Digital Signature">
                            <i class="fas fa-signature"></i>
                            <span>Sign</span>
                        </div>
                        <div class="tool-item" id="redact-btn" title="Redact Text">
                            <i class="fas fa-eye-slash"></i>
                            <span>Redact</span>
                        </div>
                        <div class="tool-item" id="protect-btn" title="Protect PDF">
                            <i class="fas fa-lock"></i>
                            <span>Protect</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">History</div>
                        <div class="tool-item" id="undo-btn" title="Undo" disabled>
                            <i class="fas fa-undo"></i>
                            <span>Undo</span>
                        </div>
                        <div class="tool-item" id="redo-btn" title="Redo" disabled>
                            <i class="fas fa-redo"></i>
                            <span>Redo</span>
                        </div>
                    </div>
                </div>
                
                <!-- Center Preview Panel -->
                <div class="preview-panel">
                    <div class="preview-toolbar">
                        <button class="preview-toolbar-btn" id="prev-page" disabled>
                            <i class="fas fa-chevron-left"></i> Prev
                        </button>
                        <span class="page-info" style="color: #e5e5e5; font-size: 12px; padding: 0 10px;">
                            Page <span id="page-num">1</span> of <span id="page-count">1</span>
                        </span>
                        <button class="preview-toolbar-btn" id="next-page" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <div style="flex: 1;"></div>
                        <button class="preview-toolbar-btn" id="zoom-out-btn">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span style="color: #e5e5e5; font-size: 12px; padding: 0 10px;" id="zoom-level">100%</span>
                        <button class="preview-toolbar-btn" id="zoom-in-btn">
                            <i class="fas fa-search-plus"></i>
                        </button>
                    </div>
                    
                    <div class="preview-container" id="preview-container" style="display: flex; visibility: visible; min-height: 600px;">
                        <div class="loading-overlay" id="loading-overlay" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="loading-text">Processing...</div>
                            <div class="loading-progress">
                                <div class="loading-progress-bar" id="loading-progress-bar"></div>
                            </div>
                            <div class="loading-percentage" id="loading-percentage">0%</div>
                        </div>
                        <div id="pdf-page-wrapper" class="pdf-page-wrapper" style="display: block; visibility: visible; position: relative;">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="deletion-layer" class="deletion-layer"></div>
                            <div id="text-layer" class="text-layer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Properties Panel -->
                <div class="properties-panel">
                    <div class="property-group">
                        <div class="property-group-title">Text Properties</div>
                        <div class="property-item">
                            <div class="property-label">Font Size</div>
                            <input type="number" class="property-input" id="font-size-input" value="12" min="8" max="72">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Font Family</div>
                            <select class="property-input" id="font-family-select">
                                <option value="Helvetica">Helvetica</option>
                                <option value="Times-Roman">Times Roman</option>
                                <option value="Courier">Courier</option>
                                <option value="Arial">Arial</option>
                            </select>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Color</div>
                            <input type="color" class="property-input" id="text-color-input" value="#000000">
                        </div>
                        <div class="property-item" style="margin-top: 15px;">
                            <button class="property-input" id="delete-text-btn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-trash"></i> Delete Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Page Actions</div>
                        <div class="property-item">
                            <button class="property-input" id="rotate-90-btn" style="width: 100%; padding: 6px; background: #2d2d2d; color: #e5e5e5; border: 1px solid #3a3a3a; border-radius: 4px; cursor: pointer; font-size: 11px; margin-bottom: 5px;">
                                <i class="fas fa-redo"></i> Rotate 90¬∞
                            </button>
                            <button class="property-input" id="delete-current-page-btn" style="width: 100%; padding: 6px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                <i class="fas fa-trash"></i> Delete Page
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Export Format</div>
                        <div class="property-item">
                            <select class="property-input" id="export-format-select" style="margin-bottom: 5px;">
                                <option value="pdf">PDF</option>
                                <option value="word">Word (DOCX)</option>
                                <option value="excel">Excel (XLSX)</option>
                                <option value="powerpoint">PowerPoint (PPTX)</option>
                                <option value="image">Images (PNG)</option>
                            </select>
                            <button class="property-input" id="export-btn" style="width: 100%; padding: 8px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Compression</div>
                        <div class="property-item">
                            <select class="property-input" id="compression-quality" style="margin-bottom: 5px;">
                                <option value="low">Low (Smaller Size)</option>
                                <option value="medium" selected>Medium (Balanced)</option>
                                <option value="high">High (Better Quality)</option>
                            </select>
                            <button class="property-input" id="compress-pdf-btn" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-compress"></i> Compress
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Performance</div>
                        <div class="property-item">
                            <div class="property-label">Rendering</div>
                            <div style="color: #28a745; font-size: 11px;">‚ö° PDF.js (Fast)</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Processing</div>
                            <div style="color: #28a745; font-size: 11px;">‚òÅÔ∏è Server-Side</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">OCR Engine</div>
                            <div style="color: #28a745; font-size: 11px;">üîç OCR Ready</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- SSL Security & Trust Section -->
    <section class="ssl-security-section" style="background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%); padding: 60px 20px; margin-top: 40px;">
        <div class="container">
            <h2 style="text-align: center; font-size: 2rem; color: #0b1630; margin-bottom: 40px;">üîí Secure & Trusted PDF Editor</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 30px; max-width: 1200px; margin: 0 auto;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üîê</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">SSL Encrypted</h3>
                    <p style="color: #64748b; line-height: 1.6;">256-bit SSL encryption ensures your PDF files are secure during upload and processing. All data is encrypted in transit.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üõ°Ô∏è</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Privacy Protected</h3>
                    <p style="color: #64748b; line-height: 1.6;">Your PDF files are processed securely and automatically deleted after processing. We never store or share your documents.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚úÖ</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">100% Free</h3>
                    <p style="color: #64748b; line-height: 1.6;">No hidden costs, no subscriptions, no credit card required. Edit PDFs online completely free with unlimited usage.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ö°</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Fast Processing</h3>
                    <p style="color: #64748b; line-height: 1.6;">Edit PDFs instantly in your browser. No waiting, no upload delays. Fast and efficient PDF editing experience.</p>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Features & Tools Description Section -->
    <section class="features-feedback-section" style="background: #ffffff; padding: 60px 20px; margin-top: 20px;">
        <div class="container">
            <h2 style="text-align: center; font-size: 2rem; color: #0b1630; margin-bottom: 50px;">üìù PDF Editor Features & Tools</h2>
            
            <div style="max-width: 1000px; margin: 0 auto;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; margin-bottom: 40px;">
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-edit" style="color: #4361ee;"></i> Text Editing
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Add, edit, and delete text in your PDF documents. Change font size, color, and style. Native PDF text editing ensures your changes are permanent.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-image" style="color: #4361ee;"></i> Image Insertion
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Insert images into your PDF files. Add logos, photos, or graphics to enhance your documents. Supports JPG, PNG, and other image formats.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-highlighter" style="color: #4361ee;"></i> Highlighting & Annotations
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Highlight important text, add comments, stamps, and shapes. Annotate your PDFs for review, collaboration, or personal notes.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-eye" style="color: #4361ee;"></i> OCR Text Extraction
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Extract text from scanned PDFs and images using OCR technology. Make scanned documents searchable and editable.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-cloud-upload-alt" style="color: #4361ee;"></i> Cloud Storage
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Save your edited PDFs directly to cloud storage. Access your documents from anywhere, anytime.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-file-export" style="color: #4361ee;"></i> Export Formats
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Export your PDFs to Word, Excel, PowerPoint, or images. Convert PDFs to various formats for easy editing.</p>
                    </div>
                </div>
                
                <!-- Feedback Section -->
                <div style="background: linear-gradient(135deg, #4361ee 0%, #3a56d4 100%); padding: 40px; border-radius: 12px; color: white; text-align: center;">
                    <h3 style="font-size: 1.5rem; margin-bottom: 15px;">üí¨ We Value Your Feedback</h3>
                    <p style="font-size: 1.1rem; margin-bottom: 25px; opacity: 0.95;">Help us improve our PDF editor. Share your experience, suggestions, or report any issues.</p>
                    <a href="index.html#contact" style="display: inline-block; background: white; color: #4361ee; padding: 12px 30px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: transform 0.2s;">
                        Share Feedback <i class="fas fa-arrow-right" style="margin-left: 8px;"></i>
                    </a>
                </div>
            </div>
        </div>
    </section>
    
    <div id="global-footer-placeholder"></div>
    
    <input type="file" id="file-input" accept="application/pdf,.pdf" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
    <script src="js/mobile-menu-init.js"></script>
    <script>
        // Get API base URL helper
        function getApiBaseUrl() {
            if (window.location.protocol === 'file:') {
                return 'http://localhost:3000';
            }
            return '';
        }
        // Professional PDF Editor Implementation
        // Features: PDF.js rendering, Server processing, Fast OCR, Native editing, Cloud integration
        
        // Set PDF.js worker for performance
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
        
        // Global variables
        if (typeof window.pdfEditorVars === 'undefined') {
            window.pdfEditorVars = {
                pdfDoc: null,
                currentPage: 1,
                totalPages: 1,
                scale: 1.5,
                textAnnotations: [],
                annotationHistory: [],
                redoHistory: [],
                selectedTextElement: null,
                activeTool: 'select',
                ocrTextsForPDF: [],
                annotations: {
                    highlights: [],
                    comments: [],
                    stamps: [],
                    shapes: []
                },
                highlightStart: null,
                highlightEnd: null,
                isDrawing: false
            };
        }
        
        // DOM elements
        const previewContainer = document.getElementById('preview-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const pdfPageWrapper = document.getElementById('pdf-page-wrapper');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const textLayer = document.getElementById('text-layer');
        const deletionLayer = document.getElementById('deletion-layer');
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const downloadBtn = document.getElementById('download-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const saveCloudBtn = document.getElementById('save-cloud-btn');
        const ocrBtn = document.getElementById('ocr-btn');
        const ocrServerBtn = document.getElementById('ocr-server-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const highlightBtn = document.getElementById('highlight-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const imageInput = document.getElementById('image-input');
        const fileInput = document.getElementById('file-input');
        const selectTool = document.getElementById('select-tool');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomLevel = document.getElementById('zoom-level');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorInput = document.getElementById('text-color-input');
        const deleteTextBtn = document.getElementById('delete-text-btn');
        
        // Direct file upload with server processing (Fast)
        if (uploadBtn && fileInput) {
            uploadBtn.addEventListener('click', function() {
                console.log('Upload button clicked');
                fileInput.click();
            });
        } else {
            console.error('Upload button or file input not found!', { uploadBtn, fileInput });
        }
        
        if (fileInput) {
            fileInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                    alert('Please select a valid PDF file');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Option 1: Direct server upload for processing (Fast)
                    const formData = new FormData();
                    formData.append('pdfFile', file);
                    
                    let uploadUrl = '/api/pdf/upload';
                    if (window.location.protocol === 'file:') {
                        uploadUrl = 'http://localhost:3000/api/pdf/upload';
                    }
                    
                    try {
                        updateProgress(20, 'Uploading to server...');
                        const uploadResponse = await fetch(uploadUrl, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (uploadResponse.ok) {
                            const result = await uploadResponse.json();
                            if (result.success && result.fileId) {
                                updateProgress(60, 'Loading PDF from server...');
                                
                                // Store file ID and server URL
                                const apiBaseUrl = getApiBaseUrl();
                                const serverUrl = `${apiBaseUrl}/api/pdf/load/${result.fileId}`;
                                
                                sessionStorage.setItem('pdfFileId', result.fileId);
                                sessionStorage.setItem('pdfServerUrl', serverUrl);
                                sessionStorage.setItem('pdfFileName', result.filename || file.name);
                                sessionStorage.setItem('pdfFileSize', (result.size || file.size).toString());
                                
                                window.pdfEditorVars.currentFileId = result.fileId;
                                
                                // Load PDF from server using file ID
                                const loadResponse = await fetch(serverUrl);
                                if (loadResponse.ok) {
                                    const pdfArrayBuffer = await loadResponse.arrayBuffer();
                                    
                                    // Store PDF data
                                    const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                    window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                                    
                                    // Store in sessionStorage for fallback
                                    const blob = new Blob([pdfArrayBuffer], { type: 'application/pdf' });
                                    const blobURL = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', blobURL);
                                    
                                    updateProgress(90, 'Rendering PDF...');
                                    await renderPDF(pdfArrayBuffer);
                                    hideLoading();
                                    
                                    console.log('PDF uploaded and loaded successfully. File ID:', result.fileId);
                                    return;
                                } else {
                                    throw new Error('Failed to load PDF from server');
                                }
                            } else {
                                throw new Error(result.error || 'Upload failed');
                            }
                        } else {
                            const errorData = await uploadResponse.json().catch(() => ({}));
                            throw new Error(errorData.error || `Upload failed: ${uploadResponse.status}`);
                        }
                    } catch (uploadError) {
                        console.warn('Server upload failed, using client-side processing:', uploadError);
                        // Continue with client-side processing - no error shown to user
                    }
                    
                    // Option 2: Client-side processing (Fallback)
                    // This always runs if server upload fails or is skipped
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        try {
                            const pdfData = e.target.result;
                            
                            // Store PDF data
                            const arrayBuffer = pdfData;
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for persistence
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            sessionStorage.setItem('pdfFileName', file.name);
                            
                            await renderPDF(pdfData);
                            hideLoading();
                        } catch (renderError) {
                            console.error('PDF rendering error:', renderError);
                            hideLoading();
                            showError('Error loading PDF: ' + renderError.message);
                        }
                    };
                    reader.onerror = function() {
                        hideLoading();
                        showError('Error reading PDF file. Please try again.');
                    };
                    reader.readAsArrayBuffer(file);
                    
                } catch (error) {
                    console.error('File upload error:', error);
                    hideLoading();
                    alert('Error uploading PDF: ' + error.message);
                }
            });
        }
        
        // Check for PDF from edit-pdf.html on page load
        async function checkForStoredPDF() {
            try {
                // Check for PDF server URL first (from edit-pdf.html upload)
                const pdfServerUrl = sessionStorage.getItem('pdfServerUrl');
                const pdfFileId = sessionStorage.getItem('pdfFileId');
                
                if (pdfServerUrl) {
                    console.log('Found PDF server URL:', pdfServerUrl);
                    showLoading('Loading PDF from server...', 20);
                    
                    try {
                        const response = await fetch(pdfServerUrl);
                        if (response.ok) {
                            const arrayBuffer = await response.arrayBuffer();
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for fallback
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            
                            if (pdfFileId) {
                                window.pdfEditorVars.currentFileId = pdfFileId;
                            }
                            
                            await renderPDF(arrayBuffer);
                            hideLoading();
                            console.log('PDF loaded from server successfully');
                            return;
                        } else {
                            console.warn('Failed to load PDF from server URL:', response.status);
                        }
                    } catch (serverError) {
                        console.warn('Server URL load failed, trying file ID:', serverError);
                        hideLoading();
                    }
                }
                
                // Fallback: Check for PDF file ID from server upload
                if (pdfFileId && !pdfServerUrl) {
                    console.log('Found PDF file ID:', pdfFileId);
                    showLoading('Loading PDF from server...', 20);
                    
                    try {
                        // Load PDF from backend using file ID
                        const apiBaseUrl = getApiBaseUrl();
                        const loadUrl = `${apiBaseUrl}/api/pdf/load/${pdfFileId}`;
                        
                        const response = await fetch(loadUrl);
                        
                        if (!response.ok) {
                            throw new Error(`Failed to load PDF: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        
                        // Store as current PDF data
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                        window.pdfEditorVars.currentFileId = pdfFileId;
                        
                        // Store in sessionStorage for fallback
                        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                        const blobURL = URL.createObjectURL(blob);
                        sessionStorage.setItem('pdfFileURL', blobURL);
                        
                        // Render PDF
                        await renderPDF(arrayBuffer);
                        hideLoading();
                        return;
                    } catch (error) {
                        console.error('Error loading PDF from server:', error);
                        hideLoading();
                        // Fall through to blob URL fallback
                    }
                }
                
                // Fallback: Check sessionStorage for PDF blob URL
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                const pdfFileName = sessionStorage.getItem('pdfFileName');
                
                if (pdfFileURL && pdfFileName) {
                    console.log('Found PDF from blob URL:', pdfFileName);
                    showLoading('Loading PDF...', 20);
                    
                    try {
                        // Fetch PDF from blob URL
                        const response = await fetch(pdfFileURL);
                        const pdfBlob = await response.blob();
                        const arrayBuffer = await pdfBlob.arrayBuffer();
                        
                        // Store as current PDF data
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                        
                        // Render PDF
                        await renderPDF(arrayBuffer);
                        hideLoading();
                    } catch (error) {
                        console.error('Error loading stored PDF:', error);
                        hideLoading();
                    }
                }
            } catch (error) {
                console.error('Error checking for stored PDF:', error);
            }
        }
        
        // Load PDF from Base64 string
        async function loadPDFFromBase64(base64String) {
            try {
                showLoading('Loading PDF...', 10);
                
                // Remove data URL prefix if present
                let base64 = base64String;
                if (base64String.startsWith('data:application/pdf;base64,')) {
                    base64 = base64String.split(',')[1];
                }
                
                // Convert base64 to ArrayBuffer
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const arrayBuffer = bytes.buffer;
                
                updateProgress(50, 'Rendering PDF...');
                await renderPDF(arrayBuffer);
                
                // Store in sessionStorage for persistence
                const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                const blobURL = URL.createObjectURL(blob);
                sessionStorage.setItem('pdfFileURL', blobURL);
                
                hideLoading();
                return true;
            } catch (error) {
                console.error('Error loading PDF from base64:', error);
                hideLoading();
                showError('Failed to load PDF: ' + error.message);
                return false;
            }
        }
        
        // Reload PDF after edits (refreshes display with updated PDF)
        async function reloadPDF() {
            try {
                if (!window.pdfEditorVars.currentPdfData) {
                    throw new Error('No PDF data available to reload');
                }
                
                showLoading('Reloading PDF...', 20);
                
                // Load from stored base64 data
                const success = await loadPDFFromBase64(window.pdfEditorVars.currentPdfData);
                
                if (success) {
                    hideLoading();
                    return true;
                } else {
                    hideLoading();
                    return false;
                }
            } catch (error) {
                console.error('Error reloading PDF:', error);
                hideLoading();
                showError('Failed to reload PDF: ' + error.message);
                return false;
            }
        }
        
        // Show error message to user
        function showError(message) {
            hideLoading();
            alert('Error: ' + message);
            console.error('PDF Editor Error:', message);
        }
        
        // Render PDF (Fast PDF.js rendering)
        async function renderPDF(pdfData) {
            try {
                if (!pdfjsLib) {
                    throw new Error('PDF.js library not loaded');
                }
                
                // Ensure preview container is visible FIRST
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                    previewContainer.style.minHeight = '600px';
                }
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                    pdfPageWrapper.setAttribute('data-loaded', 'true');
                }
                
                console.log('Rendering PDF...', { 
                    previewContainer: !!previewContainer, 
                    pdfPageWrapper: !!pdfPageWrapper,
                    pdfCanvas: !!pdfCanvas 
                });
                
                const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                const pdfDoc = await loadingTask.promise;
                window.pdfEditorVars.pdfDoc = pdfDoc;
                window.pdfEditorVars.totalPages = pdfDoc.numPages;
                
                // Store PDF data for editing
                if (pdfData instanceof ArrayBuffer) {
                    const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                    window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                } else if (typeof pdfData === 'string') {
                    window.pdfEditorVars.currentPdfData = pdfData;
                }
                
                if (pageCount) pageCount.textContent = pdfDoc.numPages;
                
                await renderPage(1);
                updatePageButtons();
                
                if (downloadBtn) downloadBtn.disabled = false;
                
                console.log('PDF rendered successfully');
                
            } catch (error) {
                console.error('Error rendering PDF:', error);
                showError('Error rendering PDF: ' + error.message);
            }
        }
        
        // Render specific page (with memory leak fix)
        let currentPageRenderTask = null;
        async function renderPage(pageNumber) {
            try {
                const pdfDoc = window.pdfEditorVars.pdfDoc;
                if (!pdfDoc) return;
                
                // Cancel previous render task to prevent memory leaks
                if (currentPageRenderTask) {
                    currentPageRenderTask.cancel();
                    currentPageRenderTask = null;
                }
                
                // Clear canvas and layers
                const context = pdfCanvas.getContext('2d');
                context.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                if (textLayer) textLayer.innerHTML = '';
                if (deletionLayer) deletionLayer.innerHTML = '';
                
                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                
                // Create render task
                const renderTask = page.render({
                    canvasContext: context,
                    viewport: viewport
                });
                currentPageRenderTask = renderTask;
                
                await renderTask.promise;
                currentPageRenderTask = null;
                
                // Extract and render text layer
                const textContent = await page.getTextContent();
                renderTextLayer(textContent, viewport, pageNumber);
                
                // Update page number
                if (pageNum) pageNum.textContent = pageNumber;
                
                // Clean up page object (help with memory)
                if (page.cleanup) {
                    page.cleanup();
                }
                
                // Initialize deletion layer
                if (deletionLayer) {
                    deletionLayer.style.width = viewport.width + 'px';
                    deletionLayer.style.height = viewport.height + 'px';
                }
                
                window.pdfEditorVars.currentPage = pageNumber;
                if (pageNum) pageNum.textContent = pageNumber;
                
                if (zoomLevel) {
                    zoomLevel.textContent = Math.round(window.pdfEditorVars.scale * 100) + '%';
                }
                
            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }
        
        // Render text layer (with page tracking for multi-page editing)
        // Render text layer - NO HTML overlays, only invisible click zones for native editing
        function renderTextLayer(textContent, viewport, pageNumber = 1) {
            if (!textLayer) return;
            
            // Clear text layer - NO HTML overlays
            textLayer.innerHTML = '';
            textLayer.style.width = viewport.width + 'px';
            textLayer.style.height = viewport.height + 'px';
            
            // Create invisible click zones for native editing (NO visual HTML overlays)
            textContent.items.forEach((item, index) => {
                if (item.str && item.str.trim()) {
                    const words = item.str.split(/(\s+)/);
                    let currentX = item.transform[4];
                    const baseY = viewport.height - item.transform[5];
                    const fontSize = Math.abs(item.transform[0]) || 12;
                    const fontFamily = item.fontName || 'Arial';
                    
                    words.forEach((word, wordIndex) => {
                        if (word.trim()) {
                            // Invisible click zone (NO visual HTML overlay)
                            const clickZone = document.createElement('div');
                            clickZone.style.position = 'absolute';
                            clickZone.style.left = currentX + 'px';
                            clickZone.style.top = (baseY - fontSize) + 'px';
                            clickZone.style.width = (word.length * fontSize * 0.6) + 'px';
                            clickZone.style.height = fontSize + 'px';
                            clickZone.style.pointerEvents = 'auto';
                            clickZone.style.cursor = 'text';
                            clickZone.style.opacity = '0'; // Completely invisible
                            clickZone.dataset.text = word;
                            clickZone.dataset.page = pageNumber;
                            clickZone.title = 'Click to edit (Native PDF editing)';
                            
                            // Click triggers native PDF editing (NO HTML overlay)
                            clickZone.addEventListener('click', function(e) {
                                e.stopPropagation();
                                const newText = prompt('Edit text (Native PDF editing):', word);
                                if (newText && newText !== word) {
                                    applyNativeTextEdit({
                                        pageIndex: pageNumber - 1,
                                        oldText: word,
                                        newText: newText,
                                        x: currentX,
                                        y: baseY
                                    });
                                }
                            });
                            
                            textLayer.appendChild(clickZone);
                            currentX += word.length * (fontSize * 0.6);
                        } else if (word) {
                            currentX += fontSize * 0.3;
                        }
                    });
                }
            });
        }
        
        // Apply OCR texts to PDF natively
        async function applyOCRTextsToPDF() {
            try {
                if (!window.pdfEditorVars.ocrTextsForPDF || window.pdfEditorVars.ocrTextsForPDF.length === 0) {
                    return;
                }
                
                const currentPdfData = window.pdfEditorVars.currentPdfData;
                if (!currentPdfData) {
                    throw new Error('No PDF loaded');
                }
                
                let apiUrl = '/api/pdf/edit';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit';
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: currentPdfData,
                        edits: {
                            ocrTexts: window.pdfEditorVars.ocrTextsForPDF
                        }
                    })
                });
                
                if (response.success) {
                    const result = response;
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    window.pdfEditorVars.ocrTextsForPDF = []; // Clear after embedding
                } else {
                    throw new Error(result.error || 'Failed to embed OCR text');
                }
            } catch (error) {
                console.error('Error applying OCR texts:', error);
                showError('Failed to embed OCR text: ' + error.message);
            }
        }
        
        // Apply native text edit (NO HTML overlays - direct PDF editing)
        async function applyNativeTextEdit(editData) {
            try {
                const { pageIndex, oldText, newText, x, y } = editData;
                
                // Get current PDF data
                const currentPdfData = window.pdfEditorVars.currentPdfData;
                if (!currentPdfData) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return false;
                }
                
                showLoading('Applying native text edit...', 30);
                
                updateProgress(50, 'Sending edit to server...');
                
                // Send native edit to backend using helper function
                const response = await callBackendAPI('/api/pdf/edit', {
                    method: 'POST',
                    body: JSON.stringify({
                        pdfData: currentPdfData,
                        edits: {
                            textEdits: [{
                                pageIndex: pageIndex,
                                x: x,
                                y: y,
                                text: newText,
                                fontSize: 12,
                                fontName: 'Helvetica',
                                fontColor: [0, 0, 0]
                            }]
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Server error: ' + response.status);
                }
                
                updateProgress(70, 'Processing edit...');
                const result = await response.json();
                
                if (result.success) {
                    updateProgress(90, 'Reloading PDF...');
                    // Update PDF data and reload (native changes)
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    hideLoading();
                    return true;
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Native text edit error:', error);
                showError('Error applying text edit: ' + error.message);
                return false;
            }
        }
        
        /* Overlay functions removed - using native PDF editing only */
        
        // Delete text element - Native PDF editing (NO HTML overlay)
        async function deleteTextElement(element) {
            if (!element) return;
            
            const x = parseFloat(element.style.left) || 0;
            const y = parseFloat(element.style.top) || 0;
            const fontSize = parseFloat(element.style.fontSize) || 12;
            const textWidth = element.offsetWidth || Math.max(element.textContent.length * fontSize * 0.6, 20);
            const textHeight = Math.max(fontSize * 1.2, fontSize);
            
            // Apply deletion directly to PDF (native editing)
            try {
                showLoading('Deleting text from PDF...', 10);
                
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(30, 'Loading PDF...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                updateProgress(50, 'Deleting text from PDF...');
                let apiUrl = '/api/pdf/edit-native';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                }
                
                const deleteResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                        edit: {
                            type: 'deleteText',
                            data: {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                width: Math.max(textWidth + 4, 20),
                                height: Math.max(textHeight + 2, fontSize)
                            }
                        }
                    })
                });
                
                updateProgress(80, 'Updating PDF...');
                
                if (deleteResponse.ok) {
                    const result = await deleteResponse.json();
                    if (result.success) {
                        updateProgress(90, 'Rendering updated PDF...');
                        // Update PDF data and reload
                        window.pdfEditorVars.currentPdfData = result.pdfData;
                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                        
                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                        const newUrl = URL.createObjectURL(blob);
                        sessionStorage.setItem('pdfFileURL', newUrl);
                        
                        await reloadPDF();
                        
                        updateProgress(100, 'Text deleted!');
                        setTimeout(() => hideLoading(), 300);
                    }
                }
            } catch (error) {
                console.error('Error deleting text:', error);
                hideLoading();
            }
            
            // Remove element from view
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            
            if (window.pdfEditorVars.selectedTextElement === element) {
                window.pdfEditorVars.selectedTextElement = null;
            }
        }
        
        // Fast Server-Side OCR
        if (ocrBtn) {
            ocrBtn.addEventListener('click', async function() {
                console.log('OCR button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Starting OCR...', 5);
                    updateProgress(10, 'Rendering page to image...');
                    
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    updateProgress(30, 'Converting to image...');
                    const imageData = canvas.toDataURL('image/png');
                    
                    updateProgress(40, 'Sending to OCR service...');
                    
                    let result = null;
                    let useClientSideOCR = false;
                    
                    // Try server-side OCR first (using new backend API)
                    try {
                        updateProgress(50, 'Processing with server OCR...');
                        
                        // Convert PDF page to base64 for OCR
                        const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage).getPageInfo().data)));
                        
                        result = await callBackendAPI('/api/pdf/ocr', {
                            method: 'POST',
                            body: JSON.stringify({
                                pdfData: window.pdfEditorVars.currentPdfData,
                                pageIndex: window.pdfEditorVars.currentPage - 1
                            })
                        });
                        
                        if (result.success) {
                            updateProgress(80, 'Receiving OCR results...');
                            // Transform result to match expected format
                            result = {
                                success: true,
                                text: result.text,
                                words: result.words || [],
                                method: result.method || 'Google Cloud Vision API'
                            };
                            updateProgress(95, 'Processing results...');
                            console.log('Server-side OCR successful');
                        } else {
                            throw new Error(result.error || 'OCR failed');
                        }
                    } catch (fetchError) {
                        // Network error or server not available, use client-side OCR
                        console.warn('Server OCR unavailable, using client-side OCR fallback:', fetchError.message);
                        useClientSideOCR = true;
                    }
                    
                    // Fallback to client-side OCR
                    if (useClientSideOCR || !result) {
                        if (typeof Tesseract === 'undefined') {
                            hideLoading();
                            alert('OCR service unavailable. Please ensure you have an internet connection or start the server.');
                            return;
                        }
                        
                        updateProgress(50, 'Using client-side OCR...');
                        console.log('Starting client-side OCR...');
                        try {
                            const { data } = await Tesseract.recognize(imageData, 'eng', {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        const progress = 50 + (m.progress * 40); // 50-90%
                                        updateProgress(progress, `OCR progress: ${Math.round(m.progress * 100)}%`);
                                        console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                                    }
                                }
                            });
                            updateProgress(95, 'Processing OCR results...');
                            
                            result = {
                                success: true,
                                text: data.text,
                                words: data.words.map(word => ({
                                    text: word.text,
                                    boundingBox: {
                                        x: word.bbox.x0,
                                        y: word.bbox.y0,
                                        width: word.bbox.x1 - word.bbox.x0,
                                        height: word.bbox.y1 - word.bbox.y0
                                    },
                                    confidence: word.confidence
                                })),
                                confidence: data.confidence,
                                method: 'client-side'
                            };
                        } catch (ocrError) {
                            console.error('Client-side OCR error:', ocrError);
                            hideLoading();
                            alert('OCR processing failed. Please try again or check your internet connection.');
                            return;
                        }
                    }
                    
                    if (result && result.success && result.words) {
                        // Process OCR results
                        const currentViewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                        const scaleX = pdfCanvas.width / (viewport.width);
                        const scaleY = pdfCanvas.height / (viewport.height);
                            
                            result.words.forEach((word) => {
                                if (word.text && word.boundingBox) {
                                    // OCR text is stored for native PDF embedding - NO HTML overlays
                                    // Text will be embedded directly into PDF structure
                                    
                                    // Store for PDF embedding
                                    if (!window.pdfEditorVars.ocrTextsForPDF) {
                                        window.pdfEditorVars.ocrTextsForPDF = [];
                                    }
                                    window.pdfEditorVars.ocrTextsForPDF.push({
                                        pageIndex: window.pdfEditorVars.currentPage - 1,
                                        text: word.text,
                                        x: word.boundingBox.x * scaleX,
                                        y: word.boundingBox.y * scaleY,
                                        fontSize: 12,
                                        fontColor: [0, 0, 0],
                                        fontName: 'Helvetica'
                                    });
                                }
                            });
                            
                            alert('OCR completed! Extracted ' + result.words.length + ' words.');
                        } else {
                            alert('OCR completed but no text found.');
                        }
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('OCR error:', error);
                    hideLoading();
                    alert('Error performing OCR: ' + error.message);
                }
            });
        }
        
        // Fast Server-Side OCR (Alternative fast processing)
        if (ocrServerBtn) {
            ocrServerBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) return;
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Use fast server-side processing
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    const imageData = canvas.toDataURL('image/png');
                    
                    // Fast server OCR endpoint
                    let apiUrl = '/api/pdf-ocr/process-fast';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf-ocr/process-fast';
                    }
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: imageData.split(',')[1],
                            language: 'en',
                            fast: true
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Determine which service was actually used
                        let serviceName = 'Fast Server OCR';
                        if (result.method) {
                            if (result.method.includes('google-cloud') || result.method.includes('vision')) {
                                serviceName = 'Server OCR (Fast)';
                            } else if (result.method === 'client-side' || result.method.includes('client')) {
                                serviceName = 'Client-side OCR';
                            } else {
                                serviceName = result.method || 'OCR';
                            }
                        }
                        
                        alert('Fast OCR completed! ' + (result.words ? result.words.length : 0) + ' words extracted.');
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Fast OCR error:', error);
                    hideLoading();
                    alert('Error performing fast OCR: ' + error.message);
                }
            });
        }
        
        // Download with server processing - Returns edited PDF
        if (downloadBtn) {
            downloadBtn.addEventListener('click', async function() {
                console.log('Download button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Preparing download...', 10);
                    
                    // Get file ID from sessionStorage
                    const fileId = sessionStorage.getItem('pdfFileId') || window.pdfEditorVars.currentFileId;
                    
                    if (fileId) {
                        // Use fileId-based download endpoint (returns edited PDF)
                        updateProgress(30, 'Fetching edited PDF from server...');
                        
                        const apiBaseUrl = getApiBaseUrl();
                        const downloadUrl = `${apiBaseUrl}/api/pdf/download/${fileId}`;
                        
                        const response = await fetch(downloadUrl);
                        
                        if (!response.ok) {
                            throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                        }
                        
                        updateProgress(70, 'Receiving PDF data...');
                        
                        // Get PDF as blob
                        const pdfBlob = await response.blob();
                        
                        updateProgress(90, 'Preparing download...');
                        
                        // Create download link
                        const url = URL.createObjectURL(pdfBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        
                        // Get filename from response headers or use default
                        const contentDisposition = response.headers.get('Content-Disposition');
                        let filename = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        if (contentDisposition) {
                            const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                            if (filenameMatch) {
                                filename = filenameMatch[1];
                            }
                        }
                        
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully:', filename);
                        }, 500);
                    } else {
                        // Fallback: Use direct PDF data if no fileId
                        updateProgress(20, 'Collecting PDF data...');
                        
                        // Get current PDF data (should already have edits applied)
                        if (!window.pdfEditorVars.currentPdfData) {
                            throw new Error('PDF data not available');
                        }
                        
                        updateProgress(50, 'Processing PDF...');
                        
                        // Extract base64 from data URL
                        let pdfBase64 = window.pdfEditorVars.currentPdfData;
                        if (pdfBase64.startsWith('data:application/pdf;base64,')) {
                            pdfBase64 = pdfBase64.split(',')[1];
                        }
                        
                        updateProgress(80, 'Preparing download...');
                        
                        // Convert to blob and download
                        const pdfBytes = Uint8Array.from(atob(pdfBase64), c => c.charCodeAt(0));
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully');
                        }, 500);
                    }
                } catch (error) {
                    console.error('Download error:', error);
                    hideLoading();
                    alert('Error downloading PDF: ' + error.message);
                }
            });
        }
        
        // Save to Cloud
        if (saveCloudBtn) {
            saveCloudBtn.addEventListener('click', async function() {
                alert('Cloud save feature - Coming soon! This will save your PDF to Google Drive/Dropbox.');
            });
        }
        
        // Page navigation
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage > 1) {
                    window.pdfEditorVars.currentPage--;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage < window.pdfEditorVars.totalPages) {
                    window.pdfEditorVars.currentPage++;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        function updatePageButtons() {
            if (prevPageBtn) prevPageBtn.disabled = window.pdfEditorVars.currentPage <= 1;
            if (nextPageBtn) nextPageBtn.disabled = window.pdfEditorVars.currentPage >= window.pdfEditorVars.totalPages;
        }
        
        // Delete text button
        if (deleteTextBtn) {
            deleteTextBtn.addEventListener('click', function() {
                if (window.pdfEditorVars.selectedTextElement) {
                    deleteTextElement(window.pdfEditorVars.selectedTextElement);
                } else {
                    alert('Please select a text element to delete.');
                }
            });
        }
        
        // Add Text button
        if (addTextBtn) {
            addTextBtn.addEventListener('click', function() {
                console.log('Add Text button clicked');
                window.pdfEditorVars.activeTool = 'text';
                if (addTextBtn) addTextBtn.classList.add('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                // Add text on canvas click
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                    pdfCanvas.addEventListener('click', addTextOnCanvas, { once: true });
                }
            });
        }
        
        // Add Image button
        if (addImageBtn) {
            addImageBtn.addEventListener('click', function() {
                console.log('Add Image button clicked');
                window.pdfEditorVars.activeTool = 'image';
                if (addImageBtn) addImageBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (imageInput) {
                    imageInput.click();
                }
            });
        }
        
        // Highlight button
        if (highlightBtn) {
            highlightBtn.addEventListener('click', function() {
                console.log('Highlight button clicked');
                window.pdfEditorVars.activeTool = 'highlight';
                if (highlightBtn) highlightBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
            });
        }
        
        // Select tool
        if (selectTool) {
            selectTool.addEventListener('click', function() {
                console.log('Select tool clicked');
                window.pdfEditorVars.activeTool = 'select';
                if (selectTool) selectTool.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                }
            });
        }
        
        // Native PDF Text Editing - No HTML Overlays!
        // Edits are applied directly to PDF and re-rendered
        async function addTextOnCanvas(e) {
            if (window.pdfEditorVars.activeTool !== 'text') return;
            
            const rect = pdfCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const text = prompt('Enter text:');
            if (!text) return;
            
            const fontSize = fontSizeInput ? parseInt(fontSizeInput.value) || 12 : 12;
            const fontFamily = fontFamilySelect ? fontFamilySelect.value || 'Helvetica' : 'Helvetica';
            const textColor = textColorInput ? textColorInput.value || '#000000' : '#000000';
            
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255
                ] : [0, 0, 0];
            };
            
            try {
                showLoading('Adding text to PDF...', 10);
                
                // Get current PDF
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(30, 'Loading PDF...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                // Apply edit directly to PDF using native editing
                updateProgress(50, 'Applying text to PDF...');
                let apiUrl = '/api/pdf/edit-native';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                }
                
                const editResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                        edit: {
                            type: 'addText',
                            data: {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: text,
                                fontSize: fontSize,
                                fontName: fontFamily,
                                fontColor: hexToRgb(textColor)
                            }
                        }
                    })
                });
                
                updateProgress(80, 'Updating PDF...');
                
                if (editResponse.ok) {
                    const result = await editResponse.json();
                    if (result.success) {
                        // Update PDF data and reload
                        updateProgress(90, 'Reloading PDF...');
                        window.pdfEditorVars.currentPdfData = result.pdfData;
                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                        
                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                        const newUrl = URL.createObjectURL(blob);
                        sessionStorage.setItem('pdfFileURL', newUrl);
                        
                        await reloadPDF();
                        
                        updateProgress(100, 'Text added!');
                        setTimeout(() => {
                            hideLoading();
                        }, 300);
                    } else {
                        throw new Error(result.error || 'Failed to add text');
                    }
                } else {
                    throw new Error('Server error: ' + editResponse.status);
                }
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                alert('Error adding text: ' + error.message);
            }
            
            // Reset tool
            window.pdfEditorVars.activeTool = 'select';
            if (pdfCanvas) pdfCanvas.style.cursor = 'default';
            if (addTextBtn) addTextBtn.classList.remove('active');
            if (selectTool) selectTool.classList.add('active');
        }
        
        // Handle image input
        if (imageInput) {
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Add image to canvas at click position
                        if (window.pdfEditorVars.activeTool === 'image' && pdfCanvas) {
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = (window.pdfEditorVars.lastClickX || 100) - rect.left;
                            const y = (window.pdfEditorVars.lastClickY || 100) - rect.top;
                            
                            const imgElement = document.createElement('img');
                            imgElement.src = e.target.result;
                            imgElement.style.position = 'absolute';
                            imgElement.style.left = x + 'px';
                            imgElement.style.top = y + 'px';
                            imgElement.style.maxWidth = '200px';
                            imgElement.style.maxHeight = '200px';
                            
                            if (textLayer) {
                                textLayer.appendChild(imgElement);
                            }
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Track canvas clicks for image placement
        if (pdfCanvas) {
            pdfCanvas.addEventListener('click', function(e) {
                if (window.pdfEditorVars.activeTool === 'image') {
                    window.pdfEditorVars.lastClickX = e.clientX;
                    window.pdfEditorVars.lastClickY = e.clientY;
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && 
                window.pdfEditorVars.selectedTextElement && 
                !window.pdfEditorVars.selectedTextElement.classList.contains('editing')) {
                e.preventDefault();
                deleteTextElement(window.pdfEditorVars.selectedTextElement);
            }
        });
        
        // ========== NEW FEATURES IMPLEMENTATION ==========
        
        // Page Management - Complete Implementation
        const rotate90Btn = document.getElementById('rotate-90-btn');
        const deleteCurrentPageBtn = document.getElementById('delete-current-page-btn');
        const rotatePageBtn = document.getElementById('rotate-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const reorderPagesBtn = document.getElementById('reorder-pages-btn');
        const extractPageBtn = document.getElementById('extract-page-btn');
        
        // Rotate Current Page 90¬∞
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Rotating page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Rotating page...');
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Page rotated!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Rotation failed');
                        }
                    } else {
                        throw new Error('Rotation request failed');
                    }
                } catch (error) {
                    console.error('Error rotating page:', error);
                    hideLoading();
                    showError('Failed to rotate page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                if (!confirm(`Delete page ${window.pdfEditorVars.currentPage}?`)) {
                    return;
                }
                
                try {
                    showLoading('Deleting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Deleting page...');
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Adjust current page if needed
                            if (window.pdfEditorVars.currentPage > window.pdfEditorVars.totalPages - 1) {
                                window.pdfEditorVars.currentPage = Math.max(1, window.pdfEditorVars.totalPages - 1);
                            }
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Page deleted!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Deletion failed');
                        }
                    } else {
                        throw new Error('Deletion request failed');
                    }
                } catch (error) {
                    console.error('Error deleting page:', error);
                    hideLoading();
                    showError('Failed to delete page: ' + error.message);
                }
            });
        }
        
        // Reorder Pages
        if (reorderPagesBtn) {
            reorderPagesBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                const totalPages = window.pdfEditorVars.totalPages;
                const currentOrder = Array.from({ length: totalPages }, (_, i) => i);
                const newOrderStr = prompt(`Enter new page order (comma-separated, 1-${totalPages}):\nExample: 3,1,2,4`, currentOrder.map(i => i + 1).join(','));
                
                if (!newOrderStr) return;
                
                try {
                    const newOrder = newOrderStr.split(',').map(s => parseInt(s.trim()) - 1).filter(n => !isNaN(n) && n >= 0 && n < totalPages);
                    
                    if (newOrder.length !== totalPages) {
                        throw new Error('Invalid page order');
                    }
                    
                    showLoading('Reordering pages...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Reordering pages...');
                    let apiUrl = '/api/pdf/pages/reorder';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/reorder';
                    }
                    
                    const reorderResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            newOrder: newOrder
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (reorderResponse.ok) {
                        const result = await reorderResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Pages reordered!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Reordering failed');
                        }
                    } else {
                        throw new Error('Reordering request failed');
                    }
                } catch (error) {
                    console.error('Error reordering pages:', error);
                    hideLoading();
                    showError('Failed to reorder pages: ' + error.message);
                }
            });
        }
        
        // Extract Page
        if (extractPageBtn) {
            extractPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                const pageNum = window.pdfEditorVars.currentPage;
                if (!confirm(`Extract page ${pageNum} as a new PDF?`)) {
                    return;
                }
                
                try {
                    showLoading('Extracting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Extracting page...');
                    let apiUrl = '/api/pdf/pages/extract';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/extract';
                    }
                    
                    const extractResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    updateProgress(80, 'Preparing download...');
                    
                    if (extractResponse.ok) {
                        const result = await extractResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Downloading...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `page-${pageNum}.pdf`;
                            a.click();
                            URL.revokeObjectURL(url);
                            
                            updateProgress(100, 'Page extracted!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Extraction failed');
                        }
                    } else {
                        throw new Error('Extraction request failed');
                    }
                } catch (error) {
                    console.error('Error extracting page:', error);
                    hideLoading();
                    showError('Failed to extract page: ' + error.message);
                }
            });
        }
        
        // Forms - Complete Implementation
        const fillFormBtn = document.getElementById('fill-form-btn');
        const detectFormBtn = document.getElementById('detect-form-btn');
        
        // Detect Form Fields
        if (detectFormBtn) {
            detectFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (detectResponse.ok) {
                        const result = await detectResponse.json();
                        if (result.success && result.formFields) {
                            updateProgress(100, 'Form fields detected!');
                            setTimeout(() => hideLoading(), 300);
                            
                            const fieldsList = result.formFields.map(f => 
                                `- ${f.name} (${f.type}): ${f.value || '(empty)'}`
                            ).join('\n');
                            
                            alert(`Found ${result.formFields.length} form field(s):\n\n${fieldsList}`);
                        } else {
                            alert('No form fields found in this PDF.');
                            hideLoading();
                        }
                    } else {
                        throw new Error('Form detection failed');
                    }
                } catch (error) {
                    console.error('Error detecting form fields:', error);
                    hideLoading();
                    showError('Failed to detect form fields: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    // First detect form fields
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(20, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(40, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    if (!detectResponse.ok) {
                        throw new Error('Form detection failed');
                    }
                    
                    const detectResult = await detectResponse.json();
                    if (!detectResult.success || !detectResult.formFields || detectResult.formFields.length === 0) {
                        alert('No form fields found in this PDF.');
                        hideLoading();
                        return;
                    }
                    
                    // Collect form field values from user
                    const formFields = [];
                    for (const field of detectResult.formFields) {
                        let value = prompt(`Enter value for "${field.name}" (${field.type}):`, field.value || '');
                        if (value !== null) {
                            formFields.push({
                                fieldName: field.name,
                                value: value
                            });
                        }
                    }
                    
                    if (formFields.length === 0) {
                        hideLoading();
                        return;
                    }
                    
                    updateProgress(60, 'Filling form fields...');
                    apiUrl = '/api/pdf/forms/fill';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/fill';
                    }
                    
                    const fillResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            formFields: formFields
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (fillResponse.ok) {
                        const result = await fillResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Form filled!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Form filling failed');
                        }
                    } else {
                        throw new Error('Form filling request failed');
                    }
                } catch (error) {
                    console.error('Error filling form:', error);
                    hideLoading();
                    showError('Failed to fill form: ' + error.message);
                }
            });
        }
        
        // Annotations - Complete Implementation
        const commentBtn = document.getElementById('comment-btn');
        const stampBtn = document.getElementById('stamp-btn');
        const shapeBtn = document.getElementById('shape-btn');
        
        // Comment Button
        if (commentBtn) {
            commentBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'comment';
                if (commentBtn) commentBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (stampBtn) stampBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Add click handler for comment placement
                pdfCanvas.addEventListener('click', function addCommentHandler(e) {
                    if (window.pdfEditorVars.activeTool === 'comment') {
                        pdfCanvas.removeEventListener('click', addCommentHandler);
                        const rect = pdfCanvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const commentText = prompt('Enter your comment:');
                        if (commentText) {
                            const comment = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: commentText,
                                author: 'User'
                            };
                            
                            // Apply comment directly to PDF (native editing - NO HTML overlay)
                            try {
                                showLoading('Adding comment to PDF...', 10);
                                
                                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                if (!pdfFileURL) throw new Error('PDF file not found');
                                
                                updateProgress(30, 'Loading PDF...');
                                const response = await fetch(pdfFileURL);
                                const pdfArrayBuffer = await response.arrayBuffer();
                                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                
                                updateProgress(50, 'Applying comment...');
                                let apiUrl = '/api/pdf/edit-native';
                                if (window.location.protocol === 'file:') {
                                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                                }
                                
                                const commentResponse = await fetch(apiUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        edit: {
                                            type: 'comment',
                                            data: comment
                                        }
                                    })
                                });
                                
                                updateProgress(80, 'Updating PDF...');
                                
                                if (commentResponse.ok) {
                                    const result = await commentResponse.json();
                                    if (result.success) {
                                        updateProgress(90, 'Rendering...');
                                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                        
                                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                                        const newUrl = URL.createObjectURL(blob);
                                        sessionStorage.setItem('pdfFileURL', newUrl);
                                        
                                        await renderPDF(pdfData);
                                        
                                        updateProgress(100, 'Comment added!');
                                        setTimeout(() => hideLoading(), 300);
                                        
                                        // Store in annotations
                                        window.pdfEditorVars.annotations.comments.push(comment);
                                    }
                                }
                            } catch (error) {
                                console.error('Error adding comment:', error);
                                hideLoading();
                            }
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (commentBtn) commentBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }
                }, { once: true });
            });
        }
        
        // Stamp Button
        if (stampBtn) {
            stampBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'stamp';
                if (stampBtn) stampBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (commentBtn) commentBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Show stamp type selection
                const stampType = prompt('Enter stamp type (APPROVED, REJECTED, CONFIDENTIAL, DRAFT, or custom):', 'APPROVED');
                if (stampType) {
                    pdfCanvas.addEventListener('click', function addStampHandler(e) {
                        if (window.pdfEditorVars.activeTool === 'stamp') {
                            pdfCanvas.removeEventListener('click', addStampHandler);
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const stamp = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                stampType: stampType,
                                width: 100,
                                height: 50
                            };
                            
                            window.pdfEditorVars.annotations.stamps.push(stamp);
                            
                            // Store in sessionStorage
                            const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                            if (!storedEdits.stamps) storedEdits.stamps = [];
                            storedEdits.stamps.push(stamp);
                            sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                            
                            // Apply stamp directly to PDF (native editing)
                            try {
                                showLoading('Adding stamp to PDF...', 10);
                                
                                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                if (!pdfFileURL) throw new Error('PDF file not found');
                                
                                updateProgress(30, 'Loading PDF...');
                                const response = await fetch(pdfFileURL);
                                const pdfArrayBuffer = await response.arrayBuffer();
                                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                
                                updateProgress(50, 'Applying stamp...');
                                let apiUrl = '/api/pdf/edit';
                                if (window.location.protocol === 'file:') {
                                    apiUrl = 'http://localhost:3000/api/pdf/edit';
                                }
                                
                                // Use standard edit endpoint for stamps
                                const stampResponse = await fetch(apiUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        edits: {
                                            stamps: [stamp]
                                        }
                                    })
                                });
                                
                                updateProgress(80, 'Updating PDF...');
                                
                                if (stampResponse.ok) {
                                    const result = await stampResponse.json();
                                    if (result.success) {
                                        updateProgress(90, 'Rendering...');
                                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                        
                                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                                        const newUrl = URL.createObjectURL(blob);
                                        sessionStorage.setItem('pdfFileURL', newUrl);
                                        
                                        await renderPDF(pdfData);
                                        
                                        updateProgress(100, 'Stamp added!');
                                        setTimeout(() => hideLoading(), 300);
                                    }
                                }
                            } catch (error) {
                                console.error('Error adding stamp:', error);
                                hideLoading();
                            }
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (stampBtn) stampBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }, { once: true });
                } else {
                    window.pdfEditorVars.activeTool = 'select';
                    if (stampBtn) stampBtn.classList.remove('active');
                }
            });
        }
        
        // Shape Button
        if (shapeBtn) {
            shapeBtn.addEventListener('click', function() {
                const shapeType = prompt('Enter shape type (rectangle, circle, line):', 'rectangle');
                if (shapeType && ['rectangle', 'circle', 'line'].includes(shapeType.toLowerCase())) {
                    window.pdfEditorVars.activeTool = 'shape';
                    window.pdfEditorVars.shapeType = shapeType.toLowerCase();
                    if (shapeBtn) shapeBtn.classList.add('active');
                    if (highlightBtn) highlightBtn.classList.remove('active');
                    if (commentBtn) commentBtn.classList.remove('active');
                    if (stampBtn) stampBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.remove('active');
                    
                    if (pdfCanvas) {
                        pdfCanvas.style.cursor = 'crosshair';
                    }
                }
            });
        }
        
        // Shape drawing (similar to highlight)
        let shapeStartX = null;
        let shapeStartY = null;
        let shapeRect = null;
        
        if (pdfCanvas) {
            const shapeMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    shapeStartX = e.clientX - rect.left;
                    shapeStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Shape will be added to PDF on mouseup
                }
            };
            
            const shapeMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Shape will be drawn directly in PDF on mouseup
                }
            };
            
            const shapeMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - shapeStartX);
                    const height = Math.abs(currentY - shapeStartY);
                    const left = Math.min(shapeStartX, currentX);
                    const top = Math.min(shapeStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const shape = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            shapeType: window.pdfEditorVars.shapeType,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            color: [0, 0, 0],
                            strokeWidth: 2
                        };
                        
                        // Apply shape directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Adding shape to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying shape...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const shapeResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'shape',
                                        data: shape
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (shapeResponse.ok) {
                                const result = await shapeResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Shape added!');
                                    setTimeout(() => hideLoading(), 300);
                                    
                                    // Store in annotations
                                    window.pdfEditorVars.annotations.shapes.push(shape);
                                }
                            }
                        } catch (error) {
                            console.error('Error adding shape:', error);
                            hideLoading();
                        }
                    }
                    
                    // Reset tool
                    window.pdfEditorVars.activeTool = 'select';
                    if (shapeBtn) shapeBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    shapeStartX = null;
                    shapeStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', shapeMouseDown);
            pdfCanvas.addEventListener('mousemove', shapeMouseMove);
            pdfCanvas.addEventListener('mouseup', shapeMouseUp);
        }
        
        // Export - Complete Implementation
        const exportBtn = document.getElementById('export-btn');
        const exportFormatSelect = document.getElementById('export-format-select');
        const exportWordBtn = document.getElementById('export-word-btn');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const exportPptBtn = document.getElementById('export-ppt-btn');
        const exportImageBtn = document.getElementById('export-image-btn');
        
        // Export Function
        async function exportToFormat(format) {
            if (!window.pdfEditorVars.pdfDoc) {
                alert('No PDF loaded');
                return;
            }
            
            try {
                showLoading(`Exporting to ${format.toUpperCase()}...`, 10);
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(20, 'Loading PDF data...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                let apiUrl = '';
                let mimeType = '';
                let fileExtension = '';
                
                switch(format) {
                    case 'word':
                        apiUrl = '/api/pdf/export/word';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        fileExtension = 'docx';
                        break;
                    case 'excel':
                        apiUrl = '/api/pdf/export/excel';
                        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                        fileExtension = 'xlsx';
                        break;
                    case 'powerpoint':
                        apiUrl = '/api/pdf/export/powerpoint';
                        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
                        fileExtension = 'pptx';
                        break;
                    case 'image':
                        apiUrl = '/api/pdf/export/images';
                        mimeType = 'image/png';
                        fileExtension = 'zip';
                        break;
                    default:
                        throw new Error('Unsupported export format');
                }
                
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000' + apiUrl;
                }
                
                updateProgress(40, `Sending to ${format} converter...`);
                const exportResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                });
                
                updateProgress(70, 'Processing export...');
                
                if (exportResponse.ok) {
                    const result = await exportResponse.json();
                    if (result.success) {
                        updateProgress(90, 'Preparing download...');
                        
                        if (format === 'image' && result.images) {
                            alert('Image export creates multiple files. Downloading first image as example.');
                            if (result.images[0]) {
                                const imgBase64 = Buffer.from(result.images[0].image).toString('base64');
                                const imgBytes = Uint8Array.from(atob(imgBase64), c => c.charCodeAt(0));
                                const blob = new Blob([imgBytes], { type: 'image/png' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `page-1.png`;
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                        } else if (result.fileData) {
                            const fileBase64 = result.fileData.split(',')[1] || result.fileData;
                            const fileBytes = Uint8Array.from(atob(fileBase64), c => c.charCodeAt(0));
                            const blob = new Blob([fileBytes], { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `exported-document.${fileExtension}`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                        
                        updateProgress(100, 'Export complete!');
                        setTimeout(() => {
                            hideLoading();
                            alert(`Successfully exported to ${format.toUpperCase()}!`);
                        }, 500);
                    } else {
                        throw new Error(result.error || 'Export failed');
                    }
                } else {
                    throw new Error('Export server error: ' + exportResponse.status);
                }
            } catch (error) {
                console.error('Export error:', error);
                hideLoading();
                alert(`Error exporting to ${format}: ${error.message}`);
            }
        }
        
        // Export Button Event Listeners
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    // Use download function
                    if (downloadBtn) downloadBtn.click();
                } else {
                    await exportToFormat(format);
                }
            });
        }
        
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compression & Merge/Split
        const compressPdfBtn = document.getElementById('compress-pdf-btn');
        const compressionQuality = document.getElementById('compression-quality');
        const compressBtn = document.getElementById('compress-btn');
        const mergeBtn = document.getElementById('merge-btn');
        const splitBtn = document.getElementById('split-btn');
        
        // Extra Functions - Security & Advanced
        const watermarkBtn = document.getElementById('watermark-btn');
        const signBtn = document.getElementById('sign-btn');
        const redactBtn = document.getElementById('redact-btn');
        const protectBtn = document.getElementById('protect-btn');
        
        // Watermark Implementation
        if (watermarkBtn) {
            watermarkBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const watermarkText = prompt('Enter watermark text:', 'CONFIDENTIAL');
                if (!watermarkText) return;
                
                const opacity = prompt('Enter opacity (0.1 to 1.0):', '0.3');
                const opacityValue = parseFloat(opacity) || 0.3;
                
                try {
                    showLoading('Adding watermark...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Applying watermark to all pages...');
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    const watermarkEdits = {
                        textEdits: []
                    };
                    
                    for (let i = 0; i < window.pdfEditorVars.totalPages; i++) {
                        watermarkEdits.textEdits.push({
                            pageIndex: i,
                            x: 200,
                            y: 400,
                            text: watermarkText,
                            fontSize: 48,
                            fontName: 'Helvetica',
                            fontColor: [0.7, 0.7, 0.7]
                        });
                    }
                    
                    const watermarkResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: watermarkEdits
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (watermarkResponse.ok) {
                        const result = await watermarkResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading watermarked PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Watermark added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Watermark added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Watermark failed');
                    }
                } catch (error) {
                    console.error('Watermark error:', error);
                    hideLoading();
                    alert('Error adding watermark: ' + error.message);
                }
            });
        }
        
        // Sign Implementation
        if (signBtn) {
            signBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const signerName = prompt('Enter signer name:', 'Your Name');
                if (!signerName) return;
                
                try {
                    showLoading('Adding digital signature...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Creating signature...');
                    const signatureEdits = {
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 100,
                            text: `Digitally Signed by: ${signerName}\nDate: ${new Date().toLocaleDateString()}`,
                            fontSize: 12,
                            fontName: 'Helvetica',
                            fontColor: [0, 0, 0]
                        }],
                        stamps: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 50,
                            stampType: 'SIGNED',
                            width: 150,
                            height: 50
                        }]
                    };
                    
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    updateProgress(70, 'Applying signature...');
                    const signResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: signatureEdits
                        })
                    });
                    
                    updateProgress(90, 'Processing...');
                    
                    if (signResponse.ok) {
                        const result = await signResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Signature added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Digital signature added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Signature failed');
                    }
                } catch (error) {
                    console.error('Sign error:', error);
                    hideLoading();
                    alert('Error adding signature: ' + error.message);
                }
            });
        }
        
        // Redact Implementation
        if (redactBtn) {
            redactBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'redact';
                if (redactBtn) redactBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                alert('Redact mode activated. Click and drag to select text to redact (black out).');
            });
        }
        
        // Redact drawing
        let redactStartX = null;
        let redactStartY = null;
        let redactRect = null;
        
        if (pdfCanvas && redactBtn) {
            const redactMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    redactStartX = e.clientX - rect.left;
                    redactStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Redaction will be added to PDF on mouseup
                }
            };
            
            const redactMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Redaction will be drawn directly in PDF on mouseup
                }
            };
            
            const redactMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - redactStartX);
                    const height = Math.abs(currentY - redactStartY);
                    const left = Math.min(redactStartX, currentX);
                    const top = Math.min(redactStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const redaction = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            type: 'redaction'
                        };
                        
                        // Apply redaction directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Applying redaction to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying redaction...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const redactResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'redaction',
                                        data: redaction
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (redactResponse.ok) {
                                const result = await redactResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Redaction applied!');
                                    setTimeout(() => hideLoading(), 300);
                                }
                            }
                        } catch (error) {
                            console.error('Error applying redaction:', error);
                            hideLoading();
                        }
                    }
                    
                    window.pdfEditorVars.activeTool = 'select';
                    if (redactBtn) redactBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    redactStartX = null;
                    redactStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', redactMouseDown);
            pdfCanvas.addEventListener('mousemove', redactMouseMove);
            pdfCanvas.addEventListener('mouseup', redactMouseUp);
        }
        
        // Protect PDF Implementation
        if (protectBtn) {
            protectBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const password = prompt('Enter password to protect PDF:', '');
                if (!password) return;
                
                const confirmPassword = prompt('Confirm password:', '');
                if (password !== confirmPassword) {
                    alert('Passwords do not match!');
                    return;
                }
                
                alert('PDF password protection requires server-side encryption. This feature will be available in the next update with /api/pdf/protect endpoint.');
            });
        }
        
        // Rotate Page 90 degrees
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page rotated successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Rotate error:', error);
                    hideLoading();
                    alert('Error rotating page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                if (!confirm('Are you sure you want to delete this page?')) return;
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page deleted successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Delete page error:', error);
                    hideLoading();
                    alert('Error deleting page: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                // First detect form fields
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const fieldsResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                    });
                    
                    if (fieldsResponse.ok) {
                        const result = await fieldsResponse.json();
                        if (result.success && result.formFields && result.formFields.length > 0) {
                            // Show form fill dialog
                            let formHtml = '<div style="padding: 20px;"><h3>Fill Form Fields</h3>';
                            result.formFields.forEach(field => {
                                formHtml += `<div style="margin: 10px 0;">
                                    <label>${field.name} (${field.type}):</label>
                                    <input type="text" id="field-${field.name}" value="${field.value || ''}" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>`;
                            });
                            formHtml += '<button onclick="fillFormSubmit()" style="margin-top: 15px; padding: 10px 20px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer;">Fill Form</button></div>';
                            
                            const formDialog = document.createElement('div');
                            formDialog.id = 'form-fill-dialog';
                            formDialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;';
                            formDialog.innerHTML = formHtml;
                            document.body.appendChild(formDialog);
                            
                            window.fillFormSubmit = async function() {
                                const formFields = result.formFields.map(field => ({
                                    fieldName: field.name,
                                    value: document.getElementById(`field-${field.name}`).value
                                }));
                                
                                let fillUrl = '/api/pdf/forms/fill';
                                if (window.location.protocol === 'file:') {
                                    fillUrl = 'http://localhost:3000/api/pdf/forms/fill';
                                }
                                
                                const fillResponse = await fetch(fillUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        formFields: formFields
                                    })
                                });
                                
                                if (fillResponse.ok) {
                                    const fillResult = await fillResponse.json();
                                    if (fillResult.success) {
                                        const pdfData = await fetch(fillResult.pdfData).then(r => r.arrayBuffer());
                                        await renderPDF(pdfData);
                                        document.body.removeChild(formDialog);
                                        alert('Form filled successfully!');
                                    }
                                }
                                hideLoading();
                            };
                        } else {
                            alert('No form fields found in this PDF.');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Form fill error:', error);
                    hideLoading();
                    alert('Error filling form: ' + error.message);
                }
            });
        }
        
        // Export to Different Formats - Enhanced with Progress
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    if (downloadBtn) downloadBtn.click();
                    return;
                }
                
                await exportToFormat(format);
            });
        }
        
        // Individual Export Buttons
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compress PDF
        if (compressPdfBtn) {
            compressPdfBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            options: { quality: compressionQuality.value }
                        })
                    });
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert(`PDF compressed! Size reduced by ${result.compressionRatio}%`);
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Compress error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Initialize all button event listeners
        function initButtonEventListeners() {
            console.log('Initializing button event listeners...');
            
            // Re-get all button elements to ensure they exist
            const uploadBtn = document.getElementById('upload-btn');
            const downloadBtn = document.getElementById('download-btn');
            const ocrBtn = document.getElementById('ocr-btn');
            const addTextBtn = document.getElementById('add-text-btn');
            const addImageBtn = document.getElementById('add-image-btn');
            const highlightBtn = document.getElementById('highlight-btn');
            const selectTool = document.getElementById('select-tool');
            const fileInput = document.getElementById('file-input');
            const imageInput = document.getElementById('image-input');
            
            // Upload button
            if (uploadBtn && fileInput) {
                uploadBtn.addEventListener('click', function() {
                    console.log('Upload button clicked');
                    fileInput.click();
                });
                console.log('‚úÖ Upload button listener added');
            } else {
                console.error('‚ùå Upload button or file input not found!', { uploadBtn, fileInput });
            }
            
            // Download button - already has listener, but verify
            if (downloadBtn) {
                console.log('‚úÖ Download button found');
            } else {
                console.error('‚ùå Download button not found!');
            }
            
            // OCR button - already has listener, but verify
            if (ocrBtn) {
                console.log('‚úÖ OCR button found');
            } else {
                console.error('‚ùå OCR button not found!');
            }
            
            // Add Text button - already has listener, but verify
            if (addTextBtn) {
                console.log('‚úÖ Add Text button found');
            } else {
                console.error('‚ùå Add Text button not found!');
            }
            
            // Add Image button - already has listener, but verify
            if (addImageBtn) {
                console.log('‚úÖ Add Image button found');
            } else {
                console.error('‚ùå Add Image button not found!');
            }
            
            // Highlight button - already has listener, but verify
            if (highlightBtn) {
                console.log('‚úÖ Highlight button found');
            } else {
                console.error('‚ùå Highlight button not found!');
            }
            
            // Select tool - already has listener, but verify
            if (selectTool) {
                console.log('‚úÖ Select tool found');
            } else {
                console.error('‚ùå Select tool not found!');
            }
            
            console.log('Button event listeners initialization complete!');
        }
        
        // Initialize - ensure DOM is ready
        async function initPDFEditor() {
            // Check for PDF from edit-pdf.html on page load
            await checkForStoredPDF();
            
            // Initialize button event listeners
            initButtonEventListeners();
            
            // Try to load PDF from storage
            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
            if (pdfFileURL) {
                fetch(pdfFileURL)
                    .then(r => r.arrayBuffer())
                    .then(data => renderPDF(data))
                    .catch(e => console.warn('Could not load PDF from storage:', e));
            }
            
            // Ensure preview container is visible
            if (previewContainer) {
                previewContainer.style.display = 'flex';
                previewContainer.style.visibility = 'visible';
            }
            if (pdfPageWrapper) {
                pdfPageWrapper.style.display = 'block';
                pdfPageWrapper.style.visibility = 'visible';
            }
        }
        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPDFEditor);
        } else {
            // DOM already loaded
            initPDFEditor();
        }
    </script>
</body>
</html>

