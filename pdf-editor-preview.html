<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Advanced PDF Editor Online Free - Real-Time PDF Editing | easyjpgtopdf</title>
    <meta name="description" content="Advanced PDF editor online free with real-time editing, full A4 preview, text editing, image insertion, OCR, and professional editing tools. Edit PDF files online without installation. Best free online PDF editor 2024.">
    <meta name="keywords" content="advanced pdf editor online free, real-time pdf editing, online pdf editor, edit pdf files, pdf editor tool, edit pdf documents, pdf editor software, edit pdf text, pdf editor free online, best pdf editor online, edit pdf online free no download, pdf editor website, free online pdf editor, real-time pdf editor, pdf editor with ocr">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
    <!-- Preload Critical CSS -->
    <link rel="preload" href="css/header.css" as="style">
    <link rel="preload" href="css/footer.css" as="style">
    
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/theme-modern.css">
    <!-- Defer Font Awesome to prevent render blocking -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></noscript>
    
    <!-- PDF.js for rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- pdf-lib for real PDF editing (Adobe Acrobat Pro style) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    
    <!-- Tesseract.js for client-side OCR fallback -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Advanced PDF Editor Online Free",
      "description": "Advanced PDF editor online free with real-time editing, full A4 preview, text editing, image insertion, OCR, and professional editing tools. Edit PDF files online without installation. Best free online PDF editor 2024.",
      "url": "https://easyjpgtopdf.com/pdf-editor-preview.html",
      "applicationCategory": "ProductivityApplication",
      "operatingSystem": "Any",
      "browserRequirements": "Requires HTML5 support",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "Real-time PDF text editing",
        "Add and manipulate images in PDF",
        "Advanced OCR text recognition",
        "Full A4 size document preview",
        "Professional editing toolbar",
        "No software installation required",
        "Multiple save options (Edited PDF, OCR-Only, Selectable PDF)"
      ],
      "inLanguage": "en-US",
      "isPartOf": {
        "@type": "WebSite",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com"
      },
      "publisher": {
        "@type": "Organization",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com"
      },
      "author": {
        "@type": "Person",
        "name": "Riyaz Mohammad"
      }
    }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #f5f7ff;
            color: #0b1630;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        main {
            flex: 1;
            padding: 30px 0;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .page-header h1 {
            font-size: 2.2rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Adobe Acrobat Pro-like Layout */
        .editor-workspace {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 800px;
            background: #2b2b2b;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        /* Left Tools Panel (3 inches / ~240px) */
        .tools-panel {
            width: 240px;
            min-width: 240px;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .tool-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .tool-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 5px;
        }
        
        .tool-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: #e5e5e5;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-item:hover {
            background: #2d2d2d;
        }
        
        .tool-item.active {
            background: #0078d4;
            color: white;
        }
        
        .tool-item i {
            width: 20px;
            text-align: center;
        }
        
        /* Center Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            overflow: hidden;
        }
        
        .preview-toolbar {
            background: #2b2b2b;
            border-bottom: 1px solid #3a3a3a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .preview-toolbar-btn {
            padding: 6px 12px;
            background: transparent;
            color: #e5e5e5;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .preview-toolbar-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }
        
        .preview-toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .editor-toolbar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        
        .toolbar-btn {
            padding: 10px 20px;
            background: #4361ee;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toolbar-btn:hover:not(:disabled) {
            background: #3a0ca3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }
        
        .toolbar-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .toolbar-btn.secondary {
            background: #f8f9ff;
            color: #4361ee;
            border: 2px solid #4361ee;
        }
        
        .toolbar-btn.secondary:hover:not(:disabled) {
            background: #eef2ff;
        }
        
        .preview-section {
            background: white;
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            min-height: 600px;
            overflow: hidden;
        }
        
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
            background: #525252;
            padding: 20px;
            min-height: 100%;
        }
        
        /* Right Properties Panel (2 inches / ~160px) */
        .properties-panel {
            width: 160px;
            min-width: 160px;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .property-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .property-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 8px;
        }
        
        .property-item {
            padding: 8px 12px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-label {
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .property-input {
            width: 100%;
            padding: 4px 8px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        .pdf-page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 0 auto;
        }
        
        .pdf-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        
        /* OCR extracted text styling - Adobe Acrobat Pro style - NO SHADOWS */
        .editable-text.ocr-extracted-text {
            background: transparent !important;
            border: 1px solid transparent;
            box-shadow: none !important;
        }
        
        .editable-text.ocr-extracted-text:hover {
            background: rgba(67, 97, 238, 0.05) !important;
            border-color: rgba(67, 97, 238, 0.3);
            box-shadow: none !important;
        }
        
        .editable-text.ocr-extracted-text.selected {
            background: rgba(67, 97, 238, 0.1) !important;
            border-color: #4361ee;
            box-shadow: none !important;
        }
        
        /* Deletion layer to cover underlying PDF text */
        .deletion-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .deletion-rect {
            position: absolute;
            background: white;
            border: none;
            pointer-events: auto;
            z-index: 6;
        }
        
        .editable-text {
            position: absolute;
            cursor: text;
            padding: 2px 4px;
            border: 1px dashed transparent;
            user-select: text;
            white-space: pre-wrap;
            pointer-events: auto;
            min-width: 20px;
            min-height: 16px;
        }
        
        .editable-text.selected {
            border-color: #4361ee;
            background: rgba(67, 97, 238, 0.1);
        }
        
        .editable-text.editing {
            border: 2px solid #4361ee;
            background: white;
            z-index: 10;
            outline: none;
        }
        
        /* Image editing styles */
        .editable-image {
            position: absolute;
            cursor: move;
            border: 2px dashed transparent;
            user-select: none;
            z-index: 10;
        }
        
        .editable-image.selected {
            border-color: #4361ee;
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.3);
        }
        
        .editable-image:hover {
            border-color: #4361ee;
        }
        
        .image-controls {
            position: absolute;
            top: -35px;
            left: 0;
            background: #4361ee;
            padding: 6px 10px;
            border-radius: 6px;
            display: flex;
            gap: 8px;
            z-index: 20;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .image-controls.visible {
            display: flex !important;
            opacity: 1;
        }
        
        .image-control-btn {
            background: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            color: #4361ee;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .image-control-btn:hover {
            background: #eef2ff;
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .image-control-btn:active {
            transform: translateY(0);
        }
        
        /* Real-time text input box - Adobe Acrobat Pro style */
        .text-input-overlay {
            position: absolute;
            border: 2px solid #4361ee;
            background: white;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 200px;
            cursor: move;
            user-select: none;
        }
        
        .text-input-overlay .text-input-header {
            background: #4361ee;
            color: white;
            padding: 4px 8px;
            margin: -8px -8px 8px -8px;
            border-radius: 4px 4px 0 0;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        
        .text-input-overlay .text-input-header .drag-handle {
            cursor: move;
        }
        
        .text-input-overlay input {
            border: none;
            outline: none;
            font-size: 16px;
            width: 100%;
            padding: 4px;
            font-family: inherit;
            background: transparent;
        }
        
        .text-input-overlay .text-input-actions {
            display: flex;
            gap: 5px;
            margin-top: 5px;
            justify-content: flex-end;
        }
        
        .text-input-overlay .text-input-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .text-input-overlay .text-input-btn:hover {
            transform: translateY(-1px);
        }
        
        .text-input-overlay .text-input-btn.confirm {
            background: #4361ee;
            color: white;
        }
        
        .text-input-overlay .text-input-btn.cancel {
            background: #e2e6ff;
            color: #4361ee;
        }
        
        /* Editable text box - draggable like Adobe Acrobat Pro */
        .editable-text-box {
            position: absolute;
            border: 2px solid #4361ee;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            cursor: move;
            min-width: 150px;
            min-height: 30px;
        }
        
        .editable-text-box.selected {
            border-color: #3a0ca3;
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .editable-text-box .text-content {
            width: 100%;
            min-height: 20px;
            border: none;
            outline: none;
            background: transparent;
            resize: both;
            overflow: auto;
            font-family: inherit;
        }
        
        /* Cursor styles for tools */
        .cursor-crosshair {
            cursor: crosshair !important;
        }
        
        .cursor-text {
            cursor: text !important;
        }
        
        .page-navigation {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 8px;
        }
        
        .page-btn {
            padding: 8px 15px;
            background: #4361ee;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .page-btn:hover:not(:disabled) {
            background: #3a0ca3;
        }
        
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-info {
            font-weight: 600;
            color: #0b1630;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 12px;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .tools-roadmap, .user-feedback {
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .tools-roadmap h2, .user-feedback h2 {
            font-size: 2rem;
            color: #0b1630;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .roadmap-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .roadmap-card {
            background: linear-gradient(135deg, #f8f9ff, #ffffff);
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #e2e6ff;
            transition: all 0.3s ease;
        }
        
        .roadmap-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(67, 97, 238, 0.15);
            border-color: #4361ee;
        }
        
        .roadmap-icon {
            font-size: 36px;
            color: #4361ee;
            margin-bottom: 15px;
        }
        
        .roadmap-card h3 {
            font-size: 1.3rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .roadmap-card p {
            color: #56607a;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        
        .feedback-form {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #0b1630;
            font-weight: 600;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e2e6ff;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #4361ee;
        }
        
        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }
        
        .submit-btn {
            padding: 12px 30px;
            background: #4361ee;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .submit-btn:hover {
            background: #3a0ca3;
            transform: translateY(-2px);
        }
        
        .ssl-badges {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #f8f9ff, #ffffff);
            border-radius: 12px;
            margin: 30px 0;
            border: 2px solid #e2e6ff;
        }
        
        .ssl-badges-grid {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            flex-wrap: wrap;
        }
        
        .ssl-badge {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ssl-badge i {
            font-size: 2rem;
            color: #4361ee;
        }
        
        .ssl-badge-text h4 {
            color: #0b1630;
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 3px;
        }
        
        .ssl-badge-text p {
            color: #56607a;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .page-header h1 {
                font-size: 1.6rem;
            }
            
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: auto;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                flex-direction: row;
                overflow-x: auto;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tool-group {
                border-bottom: none;
                border-right: 1px solid #3a3a3a;
                min-width: 120px;
            }
            
            .preview-panel {
                order: 2;
                min-height: 500px;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                order: 3;
                border-left: none;
                border-top: 1px solid #3a3a3a;
                max-height: 300px;
            }
            
            .preview-container {
                padding: 10px;
            }
            
            .roadmap-grid {
                grid-template-columns: 1fr;
            }
            
            .ssl-badges-grid {
                flex-direction: column;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <script src="js/global-components.js"></script>
    <script>
        // Prevent duplicate headers - ensure only one header is loaded
        (function() {
            // Remove any existing headers before loading new one
            const existingHeaders = document.querySelectorAll('header');
            if (existingHeaders.length > 1) {
                // Keep only the first header, remove others
                for (let i = 1; i < existingHeaders.length; i++) {
                    existingHeaders[i].remove();
                }
            }
            
            // Wait for global-components to load, then ensure single header
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(ensureSingleHeader, 100);
                });
            } else {
                setTimeout(ensureSingleHeader, 100);
            }
            
            function ensureSingleHeader() {
                const headers = document.querySelectorAll('header');
                if (headers.length > 1) {
                    // Keep the first one (from global-components), remove duplicates
                    for (let i = 1; i < headers.length; i++) {
                        console.warn('Removing duplicate header #' + (i + 1));
                        headers[i].remove();
                    }
                }
                
                // Also check for duplicate breadcrumbs
                const breadcrumbs = document.querySelectorAll('nav[aria-label="Breadcrumb"]');
                if (breadcrumbs.length > 1) {
                    for (let i = 1; i < breadcrumbs.length; i++) {
                        console.warn('Removing duplicate breadcrumb #' + (i + 1));
                        breadcrumbs[i].remove();
                    }
                }
            }
        })();
    </script>
    <div id="global-header-placeholder"></div>
    <div id="global-breadcrumb-placeholder"></div>
    
    <main>
        <div class="container">
            <div class="page-header">
                <h1>Advanced PDF Editor Online Free - Real-Time PDF Editing</h1>
            </div>
            
            <!-- Adobe Acrobat Pro-like 3-Panel Layout -->
            <div class="editor-workspace">
                <!-- Left Tools Panel (3 inches) -->
                <div class="tools-panel">
                    <div class="tool-group">
                        <div class="tool-group-title">File</div>
                        <div class="tool-item" id="download-btn" title="Download PDF">
                            <i class="fas fa-download"></i>
                            <span>Download</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Edit</div>
                        <div class="tool-item" id="select-tool" title="Select Tool" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i>
                            <span>Select</span>
                        </div>
                        <div class="tool-item" id="add-text-btn" title="Add Text" data-tool="text">
                            <i class="fas fa-font"></i>
                            <span>Add Text</span>
                        </div>
                        <div class="tool-item" id="add-image-btn" title="Add Image" data-tool="image">
                            <i class="fas fa-image"></i>
                            <span>Add Image</span>
                        </div>
                        <div class="tool-item" id="highlight-btn" title="Highlight" data-tool="highlight">
                            <i class="fas fa-highlighter"></i>
                            <span>Highlight</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">OCR</div>
                        <div class="tool-item" id="ocr-btn" title="OCR Edit">
                            <i class="fas fa-language"></i>
                            <span>OCR Edit</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">History</div>
                        <div class="tool-item" id="undo-btn" title="Undo" disabled>
                            <i class="fas fa-undo"></i>
                            <span>Undo</span>
                        </div>
                        <div class="tool-item" id="redo-btn" title="Redo" disabled>
                            <i class="fas fa-redo"></i>
                            <span>Redo</span>
                        </div>
                    </div>
                </div>
                
                <!-- Center Preview Panel -->
                <div class="preview-panel">
                    <div class="preview-toolbar">
                        <button class="preview-toolbar-btn" id="prev-page" disabled>
                            <i class="fas fa-chevron-left"></i> Prev
                        </button>
                        <span class="page-info" style="color: #e5e5e5; font-size: 12px; padding: 0 10px;">
                            Page <span id="page-num">1</span> of <span id="page-count">1</span>
                        </span>
                        <button class="preview-toolbar-btn" id="next-page" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <div style="flex: 1;"></div>
                        <button class="preview-toolbar-btn" id="zoom-out-btn">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span style="color: #e5e5e5; font-size: 12px; padding: 0 10px;" id="zoom-level">100%</span>
                        <button class="preview-toolbar-btn" id="zoom-in-btn">
                            <i class="fas fa-search-plus"></i>
                        </button>
                    </div>
                    
                    <div class="preview-container" id="preview-container" style="display: flex; visibility: visible; min-height: 600px;">
                        <div class="loading-overlay" id="loading-overlay" style="display: flex;">
                            <div class="loading-spinner"></div>
                        </div>
                        <div id="pdf-page-wrapper" class="pdf-page-wrapper" style="display: block; visibility: visible; position: relative;">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="deletion-layer" class="deletion-layer"></div>
                            <div id="text-layer" class="text-layer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Properties Panel (2 inches) -->
                <div class="properties-panel">
                    <div class="property-group">
                        <div class="property-group-title">Text Properties</div>
                        <div class="property-item">
                            <div class="property-label">Font Size</div>
                            <input type="number" class="property-input" id="font-size-input" value="12" min="8" max="72">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Font Family</div>
                            <select class="property-input" id="font-family-select">
                                <option value="Helvetica">Helvetica</option>
                                <option value="Times-Roman">Times Roman</option>
                                <option value="Courier">Courier</option>
                                <option value="Arial">Arial</option>
                            </select>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Color</div>
                            <input type="color" class="property-input" id="text-color-input" value="#000000">
                        </div>
                        <div class="property-item" style="margin-top: 15px;">
                            <button class="property-input" id="delete-text-btn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-trash"></i> Delete Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Image Properties</div>
                        <div class="property-item">
                            <div class="property-label">Width</div>
                            <input type="number" class="property-input" id="image-width-input" value="200" min="50" max="1000">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Height</div>
                            <input type="number" class="property-input" id="image-height-input" value="150" min="50" max="1000">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Opacity</div>
                            <input type="range" class="property-input" id="image-opacity-input" min="0" max="100" value="100">
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Page</div>
                        <div class="property-item">
                            <div class="property-label">Scale</div>
                            <input type="range" class="property-input" id="page-scale-input" min="50" max="200" value="150">
                            <span style="color: #9ca3af; font-size: 11px;" id="scale-value">150%</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tools-roadmap">
                <h2>How Our PDF Editor Works</h2>
                <div class="roadmap-grid">
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-edit"></i>
                        </div>
                        <h3>Edit Every Word</h3>
                        <p>Click on any text in your PDF to edit it directly. Every word is fully editable with real-time preview, just like Adobe Acrobat Pro. Simply click, edit, and see changes instantly.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-magic"></i>
                        </div>
                        <h3>Advanced OCR</h3>
                        <p>Extract text from scanned PDFs using Google Cloud Vision API. Our OCR technology supports multiple languages and provides 100% accurate text recognition.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-paint-brush"></i>
                        </div>
                        <h3>Professional Tools</h3>
                        <p>Add text, images, highlights, annotations, change fonts, adjust colors, and more. All changes are visible in real-time with full A4 size preview.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-download"></i>
                        </div>
                        <h3>Download & Save</h3>
                        <p>Once you're done editing, download your modified PDF instantly. Your original file remains untouched, and all edits are preserved.</p>
                    </div>
                </div>
            </div>
            
            <div class="tools-roadmap">
                <h2>Key Features & Characteristics</h2>
                <div class="roadmap-grid">
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-check-circle"></i>
                        </div>
                        <h3>100% Free</h3>
                        <p>No hidden charges, no registration required. Edit PDFs completely free with unlimited usage and all features available.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <h3>Secure & Private</h3>
                        <p>Your files are processed securely using Google Cloud infrastructure. All files are automatically deleted after processing.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-mobile-alt"></i>
                        </div>
                        <h3>Mobile Friendly</h3>
                        <p>Works perfectly on desktop, tablet, and mobile devices. Edit PDFs on the go from any device with responsive design.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-bolt"></i>
                        </div>
                        <h3>Fast Processing</h3>
                        <p>Powered by Google Cloud infrastructure for lightning-fast editing and OCR processing with 100% accuracy and real-time updates.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-language"></i>
                        </div>
                        <h3>Multi-Language OCR</h3>
                        <p>Extract text from scanned PDFs in multiple languages using advanced Google Cloud Vision API OCR technology with high accuracy.</p>
                    </div>
                    <div class="roadmap-card">
                        <div class="roadmap-icon">
                            <i class="fas fa-eye"></i>
                        </div>
                        <h3>Real-Time Preview</h3>
                        <p>See all your changes in real-time as you edit. Full A4 size preview with zoom controls for precise editing.</p>
                    </div>
                </div>
            </div>
            
            <div class="user-feedback">
                <h2>Share Your Feedback</h2>
                <div class="feedback-form">
                    <div class="form-group">
                        <label for="feedback-name">Your Name</label>
                        <input type="text" id="feedback-name" class="form-control" placeholder="Enter your name">
                    </div>
                    <div class="form-group">
                        <label for="feedback-email">Email Address</label>
                        <input type="email" id="feedback-email" class="form-control" placeholder="Enter your email">
                    </div>
                    <div class="form-group">
                        <label for="feedback-message">Your Feedback</label>
                        <textarea id="feedback-message" class="form-control" placeholder="Share your experience with our PDF editor"></textarea>
                    </div>
                    <button class="submit-btn" onclick="submitFeedback()">
                        <i class="fas fa-paper-plane"></i> Submit Feedback
                    </button>
                </div>
            </div>
            
            <div class="ssl-badges">
                <div class="ssl-badges-grid">
                    <div class="ssl-badge">
                        <i class="fas fa-shield-alt"></i>
                        <div class="ssl-badge-text">
                            <h4>SSL Secured</h4>
                            <p>256-bit Encryption</p>
                        </div>
                    </div>
                    <div class="ssl-badge">
                        <i class="fas fa-lock"></i>
                        <div class="ssl-badge-text">
                            <h4>100% Secure</h4>
                            <p>Files Auto-Deleted</p>
                        </div>
                    </div>
                    <div class="ssl-badge">
                        <i class="fas fa-check-circle"></i>
                        <div class="ssl-badge-text">
                            <h4>Privacy Protected</h4>
                            <p>No Data Storage</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="global-footer-placeholder"></div>
    
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
    <script src="js/mobile-menu-init.js"></script>
    <script>
        // Load auth.js only if we're not in file:// protocol (to avoid CORS errors)
        if (window.location.protocol !== 'file:') {
            const authScript = document.createElement('script');
            authScript.src = 'js/auth.js';
            authScript.type = 'module';
            authScript.onerror = function() {
                console.warn('Could not load auth.js - this is OK if you are not logged in');
            };
            document.head.appendChild(authScript);
        }
    </script>
    <script>
        // Prevent duplicate execution - wrap everything in IIFE
        (function() {
            if (window.pdfEditorInitialized) {
                console.warn('PDF Editor already initialized, skipping duplicate execution');
                return;
            }
            window.pdfEditorInitialized = true;
            
            // Set PDF.js worker
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            
            // Global variables - use window object to prevent scope issues
            // Check if already declared to prevent duplicate declaration error
            if (typeof window.pdfEditorVars === 'undefined') {
                window.pdfEditorVars = {
                    pdfDoc: null,
                    currentPage: 1,
                    totalPages: 1,
                    scale: 1.5,
                    textAnnotations: [],
                    annotationHistory: [],
                    redoHistory: [],
                    selectedTextElement: null,
                    activeTool: 'select'
                };
            }
            
            // Create local references for easier access (use const/let only once)
            const pdfDocRef = () => window.pdfEditorVars.pdfDoc;
            const setPdfDoc = (val) => { window.pdfEditorVars.pdfDoc = val; };
            const getCurrentPage = () => window.pdfEditorVars.currentPage;
            const setCurrentPage = (val) => { window.pdfEditorVars.currentPage = val; };
            const getTotalPages = () => window.pdfEditorVars.totalPages;
            const setTotalPages = (val) => { window.pdfEditorVars.totalPages = val; };
            const getScale = () => window.pdfEditorVars.scale;
            const setScale = (val) => { window.pdfEditorVars.scale = val; };
            const getTextAnnotations = () => window.pdfEditorVars.textAnnotations;
            const getAnnotationHistory = () => window.pdfEditorVars.annotationHistory;
            const getRedoHistory = () => window.pdfEditorVars.redoHistory;
            const getSelectedTextElement = () => window.pdfEditorVars.selectedTextElement;
            const setSelectedTextElement = (val) => { window.pdfEditorVars.selectedTextElement = val; };
            const getActiveTool = () => window.pdfEditorVars.activeTool;
            const setActiveTool = (val) => { window.pdfEditorVars.activeTool = val; };
            
            // For backward compatibility, create aliases
            let pdfDoc = pdfDocRef();
            let currentPage = getCurrentPage();
            let totalPages = getTotalPages();
            let scale = getScale();
            let textAnnotations = getTextAnnotations();
            let annotationHistory = getAnnotationHistory();
            let redoHistory = getRedoHistory();
            let selectedTextElement = getSelectedTextElement();
            let activeTool = getActiveTool();
        
        // DOM elements
        const previewContainer = document.getElementById('preview-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const pdfPageWrapper = document.getElementById('pdf-page-wrapper');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const textLayer = document.getElementById('text-layer');
        const deletionLayer = document.getElementById('deletion-layer');
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const downloadBtn = document.getElementById('download-btn');
        
        // Ensure preview container is visible immediately
        if (previewContainer) {
            previewContainer.style.display = 'flex';
            previewContainer.style.visibility = 'visible';
        }
        if (pdfPageWrapper) {
            pdfPageWrapper.style.display = 'block';
            pdfPageWrapper.style.visibility = 'visible';
        }
        const ocrBtn = document.getElementById('ocr-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const highlightBtn = document.getElementById('highlight-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const imageInput = document.getElementById('image-input');
        const selectTool = document.getElementById('select-tool');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomLevel = document.getElementById('zoom-level');
        const pageScaleInput = document.getElementById('page-scale-input');
        const scaleValue = document.getElementById('scale-value');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorInput = document.getElementById('text-color-input');
        const deleteTextBtn = document.getElementById('delete-text-btn');
        const imageWidthInput = document.getElementById('image-width-input');
        const imageHeightInput = document.getElementById('image-height-input');
        
        // Additional DOM elements with null checks
        const imageScaleValue = document.getElementById('image-scale-value'); // For future image scale feature
        const highlightColorBtns = document.querySelectorAll('.highlight-color-btn'); // For future highlight colors feature
        
        // Load PDF from IndexedDB or sessionStorage
        async function loadPDF() {
            try {
                console.log('Starting PDF load process...');
                console.log('sessionStorage pdfFileURL:', sessionStorage.getItem('pdfFileURL') ? 'Found' : 'Not found');
                
                // Ensure preview container is visible immediately
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                }
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                }
                if (loadingOverlay) loadingOverlay.style.display = 'flex';
                
                let pdfData = null;
                let fileName = 'document.pdf';
                
                // Try IndexedDB first
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('PDFEditorDB', 1);
                    
                    request.onerror = function() {
                        console.warn('IndexedDB error, trying sessionStorage');
                        loadFromSessionStorage().then(resolve).catch(reject);
                    };
                    
                    request.onsuccess = async function() {
                        try {
                            const db = request.result;
                            if (db.objectStoreNames.contains('pdfFiles')) {
                                const transaction = db.transaction(['pdfFiles'], 'readonly');
                                const store = transaction.objectStore('pdfFiles');
                                const getAllRequest = store.getAll();
                                
                                getAllRequest.onsuccess = async function() {
                                    try {
                                        const allFiles = getAllRequest.result;
                                        if (allFiles && allFiles.length > 0) {
                                            const latestFile = allFiles.sort((a, b) => {
                                                const idA = a.id || a.timestamp || 0;
                                                const idB = b.id || b.timestamp || 0;
                                                return idB - idA;
                                            })[0];
                                            
                                            if (latestFile && latestFile.data) {
                                                pdfData = latestFile.data;
                                                fileName = latestFile.name || 'document.pdf';
                                                await renderPDF(pdfData);
                                                resolve();
                                                return;
                                            }
                                        }
                                        // Fallback to sessionStorage
                                        await loadFromSessionStorage();
                                        resolve();
                                    } catch (error) {
                                        console.error('Error processing IndexedDB files:', error);
                                        await loadFromSessionStorage();
                                        resolve();
                                    }
                                };
                                
                                getAllRequest.onerror = function() {
                                    console.warn('Error getting files from IndexedDB, trying sessionStorage');
                                    loadFromSessionStorage().then(resolve).catch(reject);
                                };
                            } else {
                                // No object store, try sessionStorage
                                await loadFromSessionStorage();
                                resolve();
                            }
                        } catch (error) {
                            console.error('Error in IndexedDB success handler:', error);
                            loadFromSessionStorage().then(resolve).catch(reject);
                        }
                    };
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfFiles')) {
                            db.createObjectStore('pdfFiles', { keyPath: 'id', autoIncrement: true });
                        }
                    };
                });
            } catch (error) {
                console.error('Error loading PDF:', error);
                if (loadingOverlay) loadingOverlay.style.display = 'none';
                alert('Error loading PDF. Please upload a file again.');
                window.location.href = 'edit-pdf.html';
            }
        }
        
        async function loadFromSessionStorage() {
            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
            console.log('Loading from sessionStorage, URL:', pdfFileURL ? 'Found' : 'Not found');
            
            if (pdfFileURL) {
                try {
                    console.log('Fetching PDF from Blob URL:', pdfFileURL);
                    
                    // Ensure preview is visible immediately
                    if (previewContainer) {
                        previewContainer.style.display = 'flex';
                        previewContainer.style.visibility = 'visible';
                    }
                    if (pdfPageWrapper) {
                        pdfPageWrapper.style.display = 'block';
                        pdfPageWrapper.style.visibility = 'visible';
                    }
                    
                    // Show loading overlay
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'flex';
                    }
                    
                    const response = await fetch(pdfFileURL);
                    if (!response.ok) {
                        throw new Error('Failed to fetch PDF from Blob URL: ' + response.status);
                    }
                    const data = await response.arrayBuffer();
                    console.log('PDF data fetched successfully, size:', data.byteLength, 'bytes');
                    
                    // Render PDF immediately
                    await renderPDF(data);
                } catch (error) {
                    console.error('Error loading from sessionStorage:', error);
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    
                    // Try to show helpful error message
                    const errorMsg = error.message || 'Unknown error';
                    console.error('PDF loading error details:', errorMsg);
                    
                    // Don't redirect immediately - let user try again or upload new file
                    if (previewContainer) {
                        previewContainer.innerHTML = `
                            <div style="text-align: center; padding: 50px; color: #666;">
                                <h3>PDF Load Error</h3>
                                <p>${errorMsg}</p>
                                <button onclick="window.location.href='edit-pdf.html'" style="padding: 10px 20px; background: #4361ee; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">
                                    Upload New PDF
                                </button>
                            </div>
                        `;
                    }
                }
            } else {
                console.error('No pdfFileURL found in sessionStorage');
                console.log('Available sessionStorage keys:', Object.keys(sessionStorage));
                if (loadingOverlay) loadingOverlay.style.display = 'none';
                
                // Show helpful message
                if (previewContainer) {
                    previewContainer.innerHTML = `
                        <div style="text-align: center; padding: 50px; color: #666;">
                            <h3>No PDF Found</h3>
                            <p>Please upload a PDF file first.</p>
                            <button onclick="window.location.href='edit-pdf.html'" style="padding: 10px 20px; background: #4361ee; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">
                                Upload PDF
                            </button>
                        </div>
                    `;
                }
            }
        }
        
        // Render PDF
        async function renderPDF(pdfData) {
            try {
                if (!pdfjsLib) {
                    throw new Error('PDF.js library not loaded');
                }
                
                console.log('Starting PDF render, data size:', pdfData.byteLength || pdfData.length);
                
                // Ensure preview container is visible immediately
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                }
                
                const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                pdfDoc = await loadingTask.promise;
                setPdfDoc(pdfDoc);
                totalPages = pdfDoc.numPages;
                setTotalPages(totalPages);
                
                console.log('PDF loaded successfully, total pages:', totalPages);
                
                if (pageCount) pageCount.textContent = totalPages;
                
                // Render first page immediately
                await renderPage(currentPage);
                
                // Ensure everything is visible
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                }
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                }
                
                // Hide loading overlay after a brief moment to ensure smooth transition
                setTimeout(() => {
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                }, 100);
                
                if (downloadBtn) downloadBtn.disabled = false;
                
                updatePageButtons();
                
                console.log('PDF rendered successfully and visible');
            } catch (error) {
                console.error('Error rendering PDF:', error);
                if (loadingOverlay) loadingOverlay.style.display = 'none';
                alert('Error rendering PDF: ' + error.message);
            }
        }
        
        // Render specific page
        async function renderPage(pageNumber) {
            try {
                if (!pdfDoc) {
                    console.error('PDF document not loaded');
                    return;
                }
                
                if (!pdfCanvas || !textLayer) {
                    console.error('Canvas or text layer not found');
                    return;
                }
                
                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: scale });
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                
                const context = pdfCanvas.getContext('2d');
                
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                
                // Initialize deletion layer dimensions
                if (deletionLayer) {
                    deletionLayer.style.width = viewport.width + 'px';
                    deletionLayer.style.height = viewport.height + 'px';
                }
                
                // Extract and render text layer for editing - make every word editable
                const textContent = await page.getTextContent();
                renderTextLayer(textContent, viewport);
                
                // Extract fonts from PDF and update font selector (Adobe Acrobat Pro style)
                // Only do this once per PDF load, not on every page render
                if (pageNumber === 1 && !window.pdfFontsExtracted) {
                    window.pdfFontsExtracted = true;
                    setTimeout(async () => {
                        try {
                            await extractAndSetPDFFonts();
                        } catch (e) {
                            console.warn('Could not extract PDF fonts:', e);
                        }
                    }, 500); // Small delay to ensure PDF is fully loaded
                }
                
                // Update current page number
                currentPage = pageNumber;
                setCurrentPage(pageNumber);
                window.currentPage = pageNumber; // Sync with window object
                updatePageButtons();
                
                // Update zoom level display
                if (zoomLevel) {
                    zoomLevel.textContent = Math.round(scale * 100) + '%';
                }
                if (scaleValue) {
                    scaleValue.textContent = Math.round(scale * 100) + '%';
                }
                if (pageScaleInput) {
                    pageScaleInput.value = Math.round(scale * 100);
                }
            } catch (error) {
                console.error('Error rendering page:', error);
                if (loadingOverlay) loadingOverlay.style.display = 'none';
            }
        }
        
        // Render text layer for editing - Adobe Acrobat Pro style (every word editable)
        function renderTextLayer(textContent, viewport) {
            if (!textLayer) return;
            
            textLayer.innerHTML = '';
            textLayer.style.width = viewport.width + 'px';
            textLayer.style.height = viewport.height + 'px';
            
            // Initialize deletion layer
            if (deletionLayer) {
                deletionLayer.style.width = viewport.width + 'px';
                deletionLayer.style.height = viewport.height + 'px';
            }
            
            textContent.items.forEach((item, index) => {
                if (item.str && item.str.trim()) {
                    // Split text into words for individual editing (Adobe Acrobat Pro style)
                    const words = item.str.split(/(\s+)/);
                    let currentX = item.transform[4];
                    const baseY = viewport.height - item.transform[5];
                    const fontSize = Math.abs(item.transform[0]) || 12;
                    const fontFamily = item.fontName || 'Arial';
                    
                    words.forEach((word, wordIndex) => {
                        if (word.trim()) {
                            const wordDiv = document.createElement('div');
                            wordDiv.className = 'editable-text';
                            wordDiv.textContent = word;
                            wordDiv.dataset.wordIndex = wordIndex;
                            wordDiv.dataset.itemIndex = index;
                            
                            // Calculate position for each word
                            const wordWidth = word.length * (fontSize * 0.6); // Approximate width
                            wordDiv.style.left = currentX + 'px';
                            wordDiv.style.top = (baseY - fontSize) + 'px';
                            wordDiv.style.fontSize = fontSize + 'px';
                            wordDiv.style.fontFamily = fontFamily;
                            wordDiv.style.cursor = 'text';
                            wordDiv.style.color = '#000000';
                            wordDiv.style.lineHeight = '1.2';
                            
                            // Make word editable on click (Adobe Acrobat Pro style)
                            wordDiv.addEventListener('click', function(e) {
                                e.stopPropagation();
                                selectTextElement(wordDiv);
                            });
                            
                            wordDiv.addEventListener('dblclick', function(e) {
                                e.stopPropagation();
                                editTextElement(wordDiv);
                            });
                            
                            // Show edit indicator on hover
                            wordDiv.addEventListener('mouseenter', function() {
                                if (!wordDiv.classList.contains('editing')) {
                                    wordDiv.style.borderColor = '#4361ee';
                                    wordDiv.style.backgroundColor = 'rgba(67, 97, 238, 0.05)';
                                }
                            });
                            
                            wordDiv.addEventListener('mouseleave', function() {
                                if (!wordDiv.classList.contains('editing') && !wordDiv.classList.contains('selected')) {
                                    wordDiv.style.borderColor = 'transparent';
                                    wordDiv.style.backgroundColor = 'transparent';
                                }
                            });
                            
                            textLayer.appendChild(wordDiv);
                            currentX += wordWidth + (fontSize * 0.2); // Add spacing
                        } else if (word) {
                            // Handle spaces
                            currentX += fontSize * 0.3;
                        }
                    });
                }
            });
        }
        
        // Select text element
        function selectTextElement(element) {
            if (selectedTextElement) {
                selectedTextElement.classList.remove('selected');
            }
            selectedTextElement = element;
            setSelectedTextElement(element);
            element.classList.add('selected');
            
            // Update property panel with selected text properties
            if (fontSizeInput && element.style.fontSize) {
                const fontSize = parseFloat(element.style.fontSize);
                if (!isNaN(fontSize)) {
                    fontSizeInput.value = Math.round(fontSize);
                }
            }
            if (fontFamilySelect && element.style.fontFamily) {
                fontFamilySelect.value = element.style.fontFamily;
            }
            if (textColorInput && element.style.color) {
                textColorInput.value = rgbToHex(element.style.color) || '#000000';
            }
        }
        
        // Helper function to convert RGB to hex
        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb;
            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return '#' + [1, 2, 3].map(i => 
                    ('0' + parseInt(match[i]).toString(16)).slice(-2)
                ).join('');
            }
            return null;
        }
        
        // Extract fonts from PDF and update font selector (Adobe Acrobat Pro style)
        async function extractAndSetPDFFonts() {
            if (!pdfDoc || !fontFamilySelect) return;
            
            try {
                // Get PDF data
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) return;
                
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                // Call API to extract fonts
                let apiUrl = '/api/pdf/get-fonts';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/get-fonts';
                }
                
                const fontResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        pdfData: pdfBase64
                    })
                });
                
                if (fontResponse.ok) {
                    const fontData = await fontResponse.json();
                    if (fontData.success && fontData.fonts && fontData.fonts.length > 0) {
                        // Clear existing options
                        fontFamilySelect.innerHTML = '';
                        
                        // Add extracted fonts
                        fontData.fonts.forEach(fontName => {
                            const option = document.createElement('option');
                            option.value = fontName;
                            option.textContent = fontName;
                            fontFamilySelect.appendChild(option);
                        });
                        
                        // Add standard fonts if not present
                        const standardFonts = ['Helvetica', 'Times-Roman', 'Courier', 'Arial'];
                        standardFonts.forEach(fontName => {
                            if (!fontData.fonts.includes(fontName)) {
                                const option = document.createElement('option');
                                option.value = fontName;
                                option.textContent = fontName;
                                fontFamilySelect.appendChild(option);
                            }
                        });
                        
                        console.log('PDF fonts extracted and loaded:', fontData.fonts);
                    }
                }
            } catch (error) {
                console.warn('Font extraction failed:', error);
            }
        }
        
        // Store original text for replacement tracking
        const originalTexts = new WeakMap();
        
        // Edit text element with replacement tracking (Adobe Acrobat Pro style)
        function editTextElement(element) {
            // Store original text for replacement
            if (!originalTexts.has(element)) {
                originalTexts.set(element, element.textContent);
            }
            
            element.contentEditable = true;
            element.classList.add('editing');
            element.focus();
            
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            // Handle delete key to remove text and cover underlying PDF text
            const handleKeyDown = function(e) {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (element.textContent.trim() === '' || 
                        (element.textContent.length === 1 && element.textContent === element.textContent.trim())) {
                        e.preventDefault();
                        deleteTextElement(element);
                        return;
                    }
                }
            };
            
            element.addEventListener('keydown', handleKeyDown);
            
            element.addEventListener('blur', function() {
                element.removeEventListener('keydown', handleKeyDown);
                element.contentEditable = false;
                element.classList.remove('editing');
                
                // Track text replacement (Adobe Acrobat Pro style)
                const originalText = originalTexts.get(element);
                const newText = element.textContent;
                if (originalText && originalText !== newText) {
                    element.dataset.originalText = originalText;
                    element.dataset.isReplacement = 'true';
                }
                
                saveAnnotation();
            }, { once: true });
        }
        
        // Delete text element and cover underlying PDF text (Adobe Acrobat Pro style)
        // This function removes the overlay text AND covers the underlying PDF text with a white rectangle
        // This ensures the original PDF text doesn't show through after deletion
        function deleteTextElement(element) {
            if (!element || !deletionLayer) return;
            
            // Get element position and size relative to PDF canvas
            const x = parseFloat(element.style.left) || 0;
            const y = parseFloat(element.style.top) || 0;
            const fontSize = parseFloat(element.style.fontSize) || 12;
            
            // Calculate text dimensions more accurately
            const textWidth = element.offsetWidth || Math.max(element.textContent.length * fontSize * 0.6, 20);
            const textHeight = element.offsetHeight || Math.max(fontSize * 1.2, fontSize);
            
            // Create white rectangle to cover underlying PDF text (Adobe Acrobat Pro style)
            // This ensures deleted text doesn't show through from the original PDF
            const deletionRect = document.createElement('div');
            deletionRect.className = 'deletion-rect';
            deletionRect.style.left = x + 'px';
            deletionRect.style.top = y + 'px';
            deletionRect.style.width = Math.max(textWidth + 4, 20) + 'px'; // Add padding
            deletionRect.style.height = Math.max(textHeight + 2, fontSize) + 'px'; // Add padding
            deletionRect.dataset.deletedTextId = element.dataset.wordIndex || Date.now();
            deletionRect.dataset.pageNumber = currentPage;
            
            deletionLayer.appendChild(deletionRect);
            
            // Remove the text element (overlay)
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            
            // Update selection
            if (selectedTextElement === element) {
                selectedTextElement = null;
                setSelectedTextElement(null);
            }
            
            saveAnnotation();
        }
        
        // Save annotation
        function saveAnnotation() {
            // Collect current text annotations
            const currentAnnotations = [];
            if (textLayer) {
                const textElements = textLayer.querySelectorAll('.editable-text');
                textElements.forEach(el => {
                    currentAnnotations.push({
                        text: el.textContent,
                        x: parseFloat(el.style.left) || 0,
                        y: parseFloat(el.style.top) || 0,
                        fontSize: parseFloat(el.style.fontSize) || 12,
                        fontFamily: el.style.fontFamily || 'Arial',
                        color: el.style.color || '#000000'
                    });
                });
            }
            
            const history = getAnnotationHistory();
            history.push(JSON.parse(JSON.stringify(currentAnnotations)));
            window.pdfEditorVars.redoHistory = [];
            updateUndoRedoButtons();
        }
        
        // Update undo/redo buttons
        function updateUndoRedoButtons() {
            if (undoBtn) undoBtn.disabled = getAnnotationHistory().length === 0;
            if (redoBtn) redoBtn.disabled = getRedoHistory().length === 0;
            // Update visual state
            if (undoBtn) {
                undoBtn.style.opacity = getAnnotationHistory().length === 0 ? '0.5' : '1';
                undoBtn.style.cursor = getAnnotationHistory().length === 0 ? 'not-allowed' : 'pointer';
            }
            if (redoBtn) {
                redoBtn.style.opacity = getRedoHistory().length === 0 ? '0.5' : '1';
                redoBtn.style.cursor = getRedoHistory().length === 0 ? 'not-allowed' : 'pointer';
            }
        }
        
        // Page navigation
        function updatePageButtons() {
            prevPageBtn.disabled = currentPage <= 1;
            nextPageBtn.disabled = currentPage >= totalPages;
            pageNum.textContent = currentPage;
        }
        
        // Page navigation event listeners (with null checks to prevent duplicate registration)
        if (prevPageBtn && !prevPageBtn.hasAttribute('data-listener-attached')) {
            prevPageBtn.setAttribute('data-listener-attached', 'true');
            prevPageBtn.addEventListener('click', async function() {
                if (currentPage > 1) {
                    currentPage--;
                    setCurrentPage(currentPage);
                    window.currentPage = currentPage;
                    await renderPage(currentPage);
                }
            });
        }
        
        if (nextPageBtn && !nextPageBtn.hasAttribute('data-listener-attached')) {
            nextPageBtn.setAttribute('data-listener-attached', 'true');
            nextPageBtn.addEventListener('click', async function() {
                if (currentPage < totalPages) {
                    currentPage++;
                    setCurrentPage(currentPage);
                    window.currentPage = currentPage;
                    await renderPage(currentPage);
                }
            });
        }
        
        // Tool selection (Adobe Acrobat Pro style)
        if (selectTool && !selectTool.hasAttribute('data-listener-attached')) {
            selectTool.setAttribute('data-listener-attached', 'true');
            selectTool.addEventListener('click', function() {
                // Remove active class from all tools
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                selectTool.classList.add('active');
                activeTool = 'select';
                setActiveTool('select');
                if (pdfCanvas) pdfCanvas.style.cursor = 'default';
            });
        }
        
        // Zoom controls
        if (zoomInBtn && !zoomInBtn.hasAttribute('data-listener-attached')) {
            zoomInBtn.setAttribute('data-listener-attached', 'true');
            zoomInBtn.addEventListener('click', async function() {
                scale = Math.min(scale + 0.25, 3.0);
                setScale(scale);
                await renderPage(currentPage);
            });
        }
        
        if (zoomOutBtn && !zoomOutBtn.hasAttribute('data-listener-attached')) {
            zoomOutBtn.setAttribute('data-listener-attached', 'true');
            zoomOutBtn.addEventListener('click', async function() {
                scale = Math.max(scale - 0.25, 0.5);
                setScale(scale);
                await renderPage(currentPage);
            });
        }
        
        if (pageScaleInput && !pageScaleInput.hasAttribute('data-listener-attached')) {
            pageScaleInput.setAttribute('data-listener-attached', 'true');
            pageScaleInput.addEventListener('input', async function() {
                scale = parseInt(this.value) / 100;
                setScale(scale);
                if (scaleValue) scaleValue.textContent = this.value + '%';
                await renderPage(currentPage);
            });
        }
        
        // Font properties
        if (fontSizeInput && !fontSizeInput.hasAttribute('data-listener-attached')) {
            fontSizeInput.setAttribute('data-listener-attached', 'true');
            fontSizeInput.addEventListener('change', function() {
                if (selectedTextElement) {
                    selectedTextElement.style.fontSize = this.value + 'px';
                    saveAnnotation();
                }
            });
        }
        
        if (fontFamilySelect && !fontFamilySelect.hasAttribute('data-listener-attached')) {
            fontFamilySelect.setAttribute('data-listener-attached', 'true');
            fontFamilySelect.addEventListener('change', function() {
                if (selectedTextElement) {
                    selectedTextElement.style.fontFamily = this.value;
                    saveAnnotation();
                }
            });
        }
        
        if (textColorInput && !textColorInput.hasAttribute('data-listener-attached')) {
            textColorInput.setAttribute('data-listener-attached', 'true');
            textColorInput.addEventListener('change', function() {
                if (selectedTextElement) {
                    selectedTextElement.style.color = this.value;
                    saveAnnotation();
                }
            });
        }
        
        // Delete text button
        if (deleteTextBtn && !deleteTextBtn.hasAttribute('data-listener-attached')) {
            deleteTextBtn.setAttribute('data-listener-attached', 'true');
            deleteTextBtn.addEventListener('click', function() {
                if (selectedTextElement) {
                    deleteTextElement(selectedTextElement);
                } else {
                    alert('Please select a text element to delete.');
                }
            });
        }
        
        // Global keyboard delete handler (Adobe Acrobat Pro style)
        document.addEventListener('keydown', function(e) {
            // Only handle delete if not editing text content
            if ((e.key === 'Delete' || e.key === 'Backspace') && 
                selectedTextElement && 
                !selectedTextElement.classList.contains('editing') &&
                document.activeElement !== selectedTextElement) {
                e.preventDefault();
                deleteTextElement(selectedTextElement);
            }
        });
        
        // Check Google Cloud Vision API status on page load
        async function checkGoogleCloudStatus() {
            try {
                let apiUrl = '/api/pdf-ocr/status';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf-ocr/status';
                } else {
                    apiUrl = '/api/pdf-ocr/status';
                }
                
                const response = await fetch(apiUrl);
                if (response.ok) {
                    const status = await response.json();
                    console.log('Google Cloud Vision API Status:', status);
                    
                    // Update OCR button with status indicator
                    if (ocrBtn) {
                        if (status.available) {
                            ocrBtn.title = `OCR Edit (Google Cloud Vision API - ${status.accuracy || '100% Accuracy'})`;
                            ocrBtn.innerHTML = '<i class="fas fa-language"></i><span>OCR Edit (Google Cloud Active)</span>';
                        } else {
                            ocrBtn.title = `OCR Edit (Tesseract OCR - ${status.accuracy || '90-95% Accuracy'})`;
                            ocrBtn.innerHTML = '<i class="fas fa-language"></i><span>OCR Edit (Tesseract)</span>';
                        }
                    }
                    
                    return status;
                }
            } catch (error) {
                console.warn('Could not check Google Cloud status:', error);
                return { available: false, accuracy: '90-95% (Tesseract OCR)' };
            }
        }
        
        // Check status when page loads
        if (typeof window !== 'undefined') {
            setTimeout(checkGoogleCloudStatus, 1000);
        }
        
        // Tool buttons (with null checks to prevent errors)
        if (ocrBtn && !ocrBtn.hasAttribute('data-listener-attached')) {
            ocrBtn.setAttribute('data-listener-attached', 'true');
            ocrBtn.addEventListener('click', async function() {
            if (!pdfDoc) return;
            
            try {
                loadingOverlay.style.display = 'flex';
                
                // Get current page as image
                const page = await pdfDoc.getPage(currentPage);
                const viewport = page.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const context = canvas.getContext('2d');
                
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                const imageData = canvas.toDataURL('image/png');
                
                // OCR is a SEPARATE feature from direct PDF editing
                // OCR extracts text from scanned PDFs and adds it as editable overlays
                // Direct PDF editing modifies the actual PDF structure (using pdf-lib)
                // This separation allows users to choose: OCR for scanned PDFs, or direct editing for text-based PDFs
                
                // Try server-side OCR first, fallback to client-side OCR
                let result = null;
                let useClientSideOCR = false;
                
                // Determine API URL based on protocol
                let apiUrl = '/api/pdf-ocr/process';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf-ocr/process';
                } else {
                    apiUrl = '/api/pdf-ocr/process';
                }
                
                // Try server-side OCR first
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: imageData.split(',')[1],
                            language: 'en'
                        })
                    });
                    
                    if (response.ok) {
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            result = await response.json();
                            console.log('Server-side OCR successful');
                        } else {
                            throw new Error('Invalid response type from server');
                        }
                    } else {
                        // Server returned error, use client-side OCR
                        console.warn('Server OCR failed, using client-side OCR fallback');
                        useClientSideOCR = true;
                    }
                } catch (fetchError) {
                    // Network error or server not available, use client-side OCR
                    console.warn('Server OCR unavailable, using client-side OCR fallback:', fetchError.message);
                    useClientSideOCR = true;
                }
                
                // Fallback to client-side OCR using Tesseract.js
                if (useClientSideOCR || !result) {
                    if (typeof Tesseract === 'undefined') {
                        throw new Error('OCR service unavailable. Please ensure you have an internet connection for client-side OCR.');
                    }
                    
                    console.log('Starting client-side OCR with Tesseract.js...');
                    
                    try {
                        const { data } = await Tesseract.recognize(imageData, 'eng', {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                                }
                            }
                        });
                        
                        // Convert Tesseract result to our format
                        result = {
                            success: true,
                            text: data.text,
                            words: data.words.map(word => ({
                                text: word.text,
                                boundingBox: {
                                    x: word.bbox.x0,
                                    y: word.bbox.y0,
                                    width: word.bbox.x1 - word.bbox.x0,
                                    height: word.bbox.y1 - word.bbox.y0
                                },
                                confidence: word.confidence
                            })),
                            confidence: data.confidence,
                            method: 'tesseract-js-client'
                        };
                        
                        console.log('Client-side OCR completed successfully');
                    } catch (ocrError) {
                        console.error('Client-side OCR error:', ocrError);
                        throw new Error('OCR processing failed. Please try again or check your internet connection.');
                    }
                }
                
                if (result.success && result.text) {
                    // Clear existing OCR text to prevent duplicates
                    const existingOcrText = textLayer.querySelectorAll('.ocr-extracted-text');
                    existingOcrText.forEach(el => el.remove());
                    
                    // Get current page viewport for proper coordinate mapping
                    const currentViewport = page.getViewport({ scale: scale });
                    const canvasWidth = pdfCanvas.width;
                    const canvasHeight = pdfCanvas.height;
                    
                    // OCR image was rendered at scale 2.0, so we need to scale coordinates back
                    const ocrImageScale = 2.0;
                    const ocrImageWidth = currentViewport.width * ocrImageScale;
                    const ocrImageHeight = currentViewport.height * ocrImageScale;
                    
                    // Calculate scale factors to map OCR coordinates to canvas coordinates
                    const scaleX = canvasWidth / ocrImageWidth;
                    const scaleY = canvasHeight / ocrImageHeight;
                    
                    // Add extracted text as editable elements - Adobe Acrobat Pro style
                    if (result.words && result.words.length > 0) {
                        // Group words by lines to create proper text blocks
                        const textBlocks = [];
                        const processedWords = [];
                        
                        result.words.forEach((word, index) => {
                            if (word.text && word.text.trim() && word.boundingBox && !processedWords.includes(index)) {
                                // Find words on the same line (similar Y coordinates)
                                const lineY = word.boundingBox.y;
                                const lineTolerance = word.boundingBox.height || 20;
                                
                                const lineWords = result.words.filter((w, i) => {
                                    if (!w.text || !w.text.trim() || !w.boundingBox || processedWords.includes(i)) {
                                        return false;
                                    }
                                    const wordY = w.boundingBox.y;
                                    return Math.abs(wordY - lineY) < lineTolerance;
                                });
                                
                                // Sort words in line by X coordinate
                                lineWords.sort((a, b) => a.boundingBox.x - b.boundingBox.x);
                                
                                // Mark words as processed
                                lineWords.forEach(w => {
                                    const wordIndex = result.words.indexOf(w);
                                    if (wordIndex >= 0) processedWords.push(wordIndex);
                                });
                                
                                // Create text block for this line
                                if (lineWords.length > 0) {
                                    const firstWord = lineWords[0];
                                    const lastWord = lineWords[lineWords.length - 1];
                                    
                                    textBlocks.push({
                                        text: lineWords.map(w => w.text.trim()).join(' '),
                                        x: firstWord.boundingBox.x,
                                        y: firstWord.boundingBox.y,
                                        width: (lastWord.boundingBox.x + (lastWord.boundingBox.width || 0)) - firstWord.boundingBox.x,
                                        height: Math.max(...lineWords.map(w => w.boundingBox.height || 20)),
                                        words: lineWords
                                    });
                                }
                            }
                        });
                        
                        // Store OCR texts for embedding into PDF structure (Adobe Acrobat Pro style)
                        const ocrTextsForEmbedding = [];
                        
                        // Render text blocks on PDF canvas
                        textBlocks.forEach((block, blockIndex) => {
                            // Convert OCR image coordinates to PDF canvas coordinates
                            const canvasX = block.x * scaleX;
                            const canvasY = block.y * scaleY;
                            const fontSize = Math.max(12, Math.min(block.height * scaleY, 18));
                            
                            // Create text element positioned correctly on PDF
                            const textElement = document.createElement('div');
                            textElement.className = 'editable-text ocr-extracted-text';
                            textElement.textContent = block.text;
                            textElement.dataset.ocrBlock = 'true';
                            textElement.dataset.blockIndex = blockIndex;
                            
                            // Position relative to PDF canvas
                            textElement.style.position = 'absolute';
                            textElement.style.left = canvasX + 'px';
                            textElement.style.top = canvasY + 'px';
                            textElement.style.fontSize = fontSize + 'px';
                            textElement.style.color = '#000000';
                            textElement.style.cursor = 'text';
                            textElement.style.backgroundColor = 'transparent'; // No background - Adobe Acrobat Pro style
                            textElement.style.padding = '2px 4px';
                            textElement.style.borderRadius = '0';
                            textElement.style.lineHeight = '1.2';
                            textElement.style.whiteSpace = 'nowrap';
                            textElement.style.userSelect = 'text';
                            
                            // Store for PDF embedding (not just overlay) - Adobe Acrobat Pro style
                            ocrTextsForEmbedding.push({
                                pageIndex: currentPage - 1,
                                text: block.text,
                                x: canvasX,
                                y: canvasY,
                                fontSize: fontSize,
                                fontColor: [0, 0, 0],
                                fontName: 'Helvetica'
                            });
                            
                            // Make editable and draggable
                            textElement.addEventListener('click', function(e) {
                                e.stopPropagation();
                                selectTextElement(textElement);
                            });
                            
                            textElement.addEventListener('dblclick', function(e) {
                                e.stopPropagation();
                                editTextElement(textElement);
                            });
                            
                            // Make draggable
                            makeTextDraggable(textElement);
                            
                            textLayer.appendChild(textElement);
                        });
                        
                        // Store OCR texts for embedding when downloading (Adobe Acrobat Pro style)
                        if (!window.ocrTextsForPDF) {
                            window.ocrTextsForPDF = [];
                        }
                        window.ocrTextsForPDF = window.ocrTextsForPDF.concat(ocrTextsForEmbedding);
                        
                        saveAnnotation();
                        alert('OCR completed! Extracted ' + textBlocks.length + ' text blocks. These will be embedded into PDF structure when you download (Adobe Acrobat Pro style).');
                    } else if (result.text) {
                        // Fallback: show full text as single block
                        const textElement = document.createElement('div');
                        textElement.className = 'editable-text ocr-extracted-text';
                        textElement.textContent = result.text.trim();
                        textElement.dataset.ocrBlock = 'true';
                        textElement.style.position = 'absolute';
                        textElement.style.left = '50px';
                        textElement.style.top = '50px';
                        textElement.style.fontSize = '14px';
                        textElement.style.color = '#000000';
                        textElement.style.cursor = 'text';
                        textElement.style.backgroundColor = 'transparent'; // No background - Adobe Acrobat Pro style
                        textElement.style.padding = '4px 8px';
                        textElement.style.borderRadius = '0';
                        textElement.style.maxWidth = '400px';
                        textElement.style.whiteSpace = 'pre-wrap';
                        textElement.style.userSelect = 'text';
                        
                        textElement.addEventListener('click', function(e) {
                            e.stopPropagation();
                            selectTextElement(textElement);
                        });
                        
                        textElement.addEventListener('dblclick', function(e) {
                            e.stopPropagation();
                            editTextElement(textElement);
                        });
                        
                        makeTextDraggable(textElement);
                        textLayer.appendChild(textElement);
                        
                        // Store for PDF embedding (Adobe Acrobat Pro style)
                        if (!window.ocrTextsForPDF) {
                            window.ocrTextsForPDF = [];
                        }
                        window.ocrTextsForPDF.push({
                            pageIndex: currentPage - 1,
                            text: result.text.trim(),
                            x: 50,
                            y: 50,
                            fontSize: 14,
                            fontColor: [0, 0, 0],
                            fontName: 'Helvetica'
                        });
                        
                        saveAnnotation();
                        alert('OCR completed! Extracted text added. This will be embedded into PDF structure when you download (Adobe Acrobat Pro style).');
                    }
                } else {
                    alert('OCR failed: ' + (result.error || 'Unknown error'));
                }
                
                loadingOverlay.style.display = 'none';
            } catch (error) {
                console.error('OCR error:', error);
                loadingOverlay.style.display = 'none';
                alert('Error performing OCR: ' + error.message);
            }
            });
        }
        
        // Text input handler (shared function) - Adobe Acrobat Pro style
        let currentTextInputOverlay = null;
        let isDraggingTextInput = false;
        let textInputDragStart = { x: 0, y: 0 };
        let textInputInitialPos = { x: 0, y: 0 };
        
        function createTextInputBox(x, y) {
            // Remove existing text input if any
            if (currentTextInputOverlay) {
                currentTextInputOverlay.remove();
            }
            
            // Get PDF page wrapper for proper positioning
            const pageWrapper = pdfPageWrapper || document.getElementById('pdf-page-wrapper');
            if (!pageWrapper) {
                console.error('PDF page wrapper not found');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'text-input-overlay';
            overlay.style.left = x + 'px';
            overlay.style.top = y + 'px';
            
            // Header with drag handle
            const header = document.createElement('div');
            header.className = 'text-input-header';
            header.innerHTML = '<span class="drag-handle"><i class="fas fa-grip-vertical"></i> Drag to move</span>';
            
            // Make header draggable
            header.addEventListener('mousedown', function(e) {
                e.preventDefault();
                isDraggingTextInput = true;
                textInputDragStart.x = e.clientX;
                textInputDragStart.y = e.clientY;
                textInputInitialPos.x = parseFloat(overlay.style.left) || 0;
                textInputInitialPos.y = parseFloat(overlay.style.top) || 0;
                overlay.style.cursor = 'grabbing';
            });
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Type your text here...';
            input.style.fontSize = fontSizeInput ? fontSizeInput.value + 'px' : '16px';
            input.style.fontFamily = fontFamilySelect ? fontFamilySelect.value : 'Helvetica';
            input.style.color = textColorInput ? textColorInput.value : '#000000';
            
            // Real-time font/color updates
            if (fontSizeInput) {
                fontSizeInput.addEventListener('input', function() {
                    input.style.fontSize = this.value + 'px';
                });
            }
            if (fontFamilySelect) {
                fontFamilySelect.addEventListener('change', function() {
                    input.style.fontFamily = this.value;
                });
            }
            if (textColorInput) {
                textColorInput.addEventListener('change', function() {
                    input.style.color = this.value;
                });
            }
            
            const actions = document.createElement('div');
            actions.className = 'text-input-actions';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'text-input-btn confirm';
            confirmBtn.textContent = 'Add Text';
            confirmBtn.onclick = function() {
                const text = input.value.trim();
                if (text) {
                    // Create editable text element directly on PDF page
                    const textElement = document.createElement('div');
                    textElement.className = 'editable-text';
                    textElement.textContent = text;
                    textElement.style.left = overlay.style.left;
                    textElement.style.top = overlay.style.top;
                    textElement.style.fontSize = input.style.fontSize;
                    textElement.style.fontFamily = input.style.fontFamily;
                    textElement.style.color = input.style.color;
                    textElement.style.cursor = 'text';
                    
                    // Make editable and draggable
                    textElement.addEventListener('click', function(e) {
                        e.stopPropagation();
                        selectTextElement(textElement);
                    });
                    
                    textElement.addEventListener('dblclick', function(e) {
                        e.stopPropagation();
                        editTextElement(textElement);
                    });
                    
                    // Make text draggable
                    makeTextDraggable(textElement);
                    
                    textLayer.appendChild(textElement);
                    saveAnnotation();
                }
                overlay.remove();
                currentTextInputOverlay = null;
                isDraggingTextInput = false;
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'text-input-btn cancel';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = function() {
                overlay.remove();
                currentTextInputOverlay = null;
                isDraggingTextInput = false;
            };
            
            actions.appendChild(confirmBtn);
            actions.appendChild(cancelBtn);
            
            overlay.appendChild(header);
            overlay.appendChild(input);
            overlay.appendChild(actions);
            
            // Append to PDF page wrapper (not textLayer) for proper positioning
            pageWrapper.appendChild(overlay);
            
            currentTextInputOverlay = overlay;
            input.focus();
            
            // Global mouse move for dragging
            document.addEventListener('mousemove', function dragTextInput(e) {
                if (isDraggingTextInput && currentTextInputOverlay) {
                    const dx = e.clientX - textInputDragStart.x;
                    const dy = e.clientY - textInputDragStart.y;
                    currentTextInputOverlay.style.left = (textInputInitialPos.x + dx) + 'px';
                    currentTextInputOverlay.style.top = (textInputInitialPos.y + dy) + 'px';
                }
            });
            
            document.addEventListener('mouseup', function() {
                if (isDraggingTextInput) {
                    isDraggingTextInput = false;
                    if (currentTextInputOverlay) {
                        currentTextInputOverlay.style.cursor = 'move';
                    }
                }
            });
            
            // Close on Enter key
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    confirmBtn.click();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelBtn.click();
                }
            });
        }
        
        // Make text elements draggable
        function makeTextDraggable(textElement) {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            let initialPos = { x: 0, y: 0 };
            
            textElement.addEventListener('mousedown', function(e) {
                if (e.target === textElement || textElement.contains(e.target)) {
                    isDragging = true;
                    dragStart.x = e.clientX;
                    dragStart.y = e.clientY;
                    initialPos.x = parseFloat(textElement.style.left) || 0;
                    initialPos.y = parseFloat(textElement.style.top) || 0;
                    textElement.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', function dragText(e) {
                if (isDragging) {
                    const dx = e.clientX - dragStart.x;
                    const dy = e.clientY - dragStart.y;
                    textElement.style.left = (initialPos.x + dx) + 'px';
                    textElement.style.top = (initialPos.y + dy) + 'px';
                }
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    textElement.style.cursor = 'text';
                    saveAnnotation();
                }
            });
        }
        
        if (addTextBtn && !addTextBtn.hasAttribute('data-listener-attached')) {
            addTextBtn.setAttribute('data-listener-attached', 'true');
            addTextBtn.addEventListener('click', function() {
                // Remove active class from all tools
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                addTextBtn.classList.add('active');
                activeTool = 'text';
                setActiveTool('text');
                
                // Change cursor to text cursor
                if (pdfCanvas) {
                    pdfCanvas.classList.add('cursor-text');
                    pdfCanvas.style.cursor = 'text';
                }
                if (textLayer) {
                    textLayer.style.cursor = 'text';
                }
                
                // Add click listener to canvas for text insertion
                function addTextHandler(e) {
                    if (activeTool !== 'text') {
                        pdfCanvas.removeEventListener('click', addTextHandler);
                        if (pdfCanvas) {
                            pdfCanvas.classList.remove('cursor-text');
                            pdfCanvas.style.cursor = 'default';
                        }
                        if (textLayer) textLayer.style.cursor = 'default';
                        return;
                    }
                    
                    // Get click position relative to canvas
                    const rect = pdfCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Create real-time text input box
                    createTextInputBox(x, y);
                }
                
                pdfCanvas.addEventListener('click', addTextHandler, { once: false });
            });
        }
        
        // Image editing variables
        let currentImage = null;
        let imageRotation = 0;
        let imageScale = 1;
        
        function createImageControls(img) {
            // Remove existing controls if any
            const existingControls = img.parentElement.querySelector('.image-controls');
            if (existingControls) {
                existingControls.remove();
            }
            
            const controls = document.createElement('div');
            controls.className = 'image-controls';
            controls.style.display = 'none';
            
            // Store rotation per image
            if (!img.dataset.rotation) {
                img.dataset.rotation = '0';
            }
            if (!img.dataset.scale) {
                img.dataset.scale = '1';
            }
            
            const rotateBtn = document.createElement('button');
            rotateBtn.className = 'image-control-btn';
            rotateBtn.innerHTML = '<i class="fas fa-redo"></i> Rotate';
            rotateBtn.title = 'Rotate 90';
            rotateBtn.onclick = function(e) {
                e.stopPropagation();
                const currentRotation = parseInt(img.dataset.rotation) || 0;
                const newRotation = (currentRotation + 90) % 360;
                img.dataset.rotation = newRotation.toString();
                img.style.transform = `rotate(${newRotation}deg)`;
                saveAnnotation();
            };
            
            const resizeBtn = document.createElement('button');
            resizeBtn.className = 'image-control-btn';
            resizeBtn.innerHTML = '<i class="fas fa-expand-arrows-alt"></i> Resize';
            resizeBtn.title = 'Resize Image';
            resizeBtn.onclick = function(e) {
                e.stopPropagation();
                const currentWidth = img.offsetWidth;
                const currentHeight = img.offsetHeight;
                const newWidth = prompt('Enter new width (px):', currentWidth);
                if (newWidth && !isNaN(newWidth) && newWidth > 0) {
                    const aspectRatio = currentHeight / currentWidth;
                    const newHeight = Math.round(newWidth * aspectRatio);
                    img.style.width = newWidth + 'px';
                    img.style.height = newHeight + 'px';
                    saveAnnotation();
                }
            };
            
            const cropBtn = document.createElement('button');
            cropBtn.className = 'image-control-btn';
            cropBtn.innerHTML = '<i class="fas fa-crop"></i> Crop';
            cropBtn.title = 'Crop Image';
            cropBtn.onclick = function(e) {
                e.stopPropagation();
                alert('Crop feature: Click and drag on image to select crop area. (Full crop editor coming soon)');
                // TODO: Implement full crop functionality
            };
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'image-control-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteBtn.title = 'Delete Image';
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                if (confirm('Delete this image?')) {
                    img.remove();
                    controls.remove();
                    saveAnnotation();
                }
            };
            
            controls.appendChild(rotateBtn);
            controls.appendChild(resizeBtn);
            controls.appendChild(cropBtn);
            controls.appendChild(deleteBtn);
            
            img.parentElement.appendChild(controls);
            
            // Always show controls when image is selected
            img.addEventListener('click', function(e) {
                e.stopPropagation();
                // Deselect all images
                document.querySelectorAll('.editable-image').forEach(im => {
                    im.classList.remove('selected');
                    const imControls = im.parentElement.querySelector('.image-controls');
                    if (imControls) imControls.style.display = 'none';
                });
                // Select this image
                img.classList.add('selected');
                controls.style.display = 'flex';
                updateControlsPosition(controls, img);
            });
            
            // Show controls on hover
            img.addEventListener('mouseenter', function() {
                if (!img.classList.contains('selected')) {
                    controls.style.display = 'flex';
                    updateControlsPosition(controls, img);
                }
            });
            
            img.addEventListener('mouseleave', function() {
                if (!img.classList.contains('selected')) {
                    controls.style.display = 'none';
                }
            });
            
            // Update controls position when image moves
            const observer = new MutationObserver(function() {
                if (controls.style.display === 'flex') {
                    updateControlsPosition(controls, img);
                }
            });
            observer.observe(img, { attributes: true, attributeFilter: ['style'] });
            
            return controls;
        }
        
        function updateControlsPosition(controls, img) {
            const rect = img.getBoundingClientRect();
            const pageWrapperRect = pdfPageWrapper ? pdfPageWrapper.getBoundingClientRect() : { left: 0, top: 0 };
            controls.style.left = (rect.left - pageWrapperRect.left) + 'px';
            controls.style.top = (rect.top - pageWrapperRect.top - 35) + 'px';
        }
        
        if (addImageBtn && !addImageBtn.hasAttribute('data-listener-attached')) {
            addImageBtn.setAttribute('data-listener-attached', 'true');
            addImageBtn.addEventListener('click', function() {
                // Remove active class from all tools
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                addImageBtn.classList.add('active');
                activeTool = 'image';
                setActiveTool('image');
                
                // Change cursor to crosshair
                if (pdfCanvas) {
                    pdfCanvas.classList.add('cursor-crosshair');
                    pdfCanvas.style.cursor = 'crosshair';
                }
                if (textLayer) {
                    textLayer.style.cursor = 'crosshair';
                }
                
                if (imageInput) imageInput.click();
            });
        }
        
        if (imageInput && !imageInput.hasAttribute('data-listener-attached')) {
            imageInput.setAttribute('data-listener-attached', 'true');
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // Show visual feedback that image is ready to place
                        if (pdfCanvas) {
                            pdfCanvas.style.cursor = 'crosshair';
                            pdfCanvas.title = 'Click on PDF to place image';
                        }
                        
                        // Add click listener to canvas for image insertion
                        function addImageHandler(clickEvent) {
                            if (activeTool !== 'image') {
                                pdfCanvas.removeEventListener('click', addImageHandler);
                                if (pdfCanvas) {
                                    pdfCanvas.classList.remove('cursor-crosshair');
                                    pdfCanvas.style.cursor = 'default';
                                    pdfCanvas.title = '';
                                }
                                if (textLayer) textLayer.style.cursor = 'default';
                                return;
                            }
                            
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = clickEvent.clientX - rect.left;
                            const y = clickEvent.clientY - rect.top;
                            
                            // Create image element with editing capabilities
                            const img = document.createElement('img');
                            img.src = event.target.result;
                            img.className = 'editable-image';
                            img.style.position = 'absolute';
                            img.style.left = x + 'px';
                            img.style.top = y + 'px';
                            img.style.width = imageWidthInput ? imageWidthInput.value + 'px' : '200px';
                            img.style.height = imageHeightInput ? imageHeightInput.value + 'px' : 'auto';
                            img.style.maxWidth = '500px';
                            img.style.maxHeight = '500px';
                            img.style.cursor = 'move';
                            img.style.zIndex = '10';
                            img.style.objectFit = 'contain';
                            
                            // Initialize rotation and scale
                            imageRotation = 0;
                            imageScale = 1;
                            
                            textLayer.appendChild(img);
                            
                            // Create image controls (rotate, delete, resize)
                            createImageControls(img);
                            
                            // Make image draggable
                            let isDragging = false;
                            let startX, startY, initialX, initialY;
                            
                            img.addEventListener('mousedown', function(e) {
                                e.stopPropagation();
                                isDragging = true;
                                startX = e.clientX;
                                startY = e.clientY;
                                initialX = parseFloat(img.style.left) || 0;
                                initialY = parseFloat(img.style.top) || 0;
                                img.style.cursor = 'grabbing';
                            });
                            
                            document.addEventListener('mousemove', function(e) {
                                if (isDragging) {
                                    const dx = e.clientX - startX;
                                    const dy = e.clientY - startY;
                                    img.style.left = (initialX + dx) + 'px';
                                    img.style.top = (initialY + dy) + 'px';
                                }
                            });
                            
                            document.addEventListener('mouseup', function() {
                                if (isDragging) {
                                    isDragging = false;
                                    img.style.cursor = 'move';
                                    saveAnnotation();
                                }
                            });
                            
                            // Save annotation
                            saveAnnotation();
                            
                            // Reset tool
                            activeTool = 'select';
                            setActiveTool('select');
                            if (pdfCanvas) {
                                pdfCanvas.classList.remove('cursor-crosshair');
                                pdfCanvas.style.cursor = 'default';
                                pdfCanvas.title = '';
                            }
                            if (textLayer) textLayer.style.cursor = 'default';
                            pdfCanvas.removeEventListener('click', addImageHandler);
                            
                            // Reset file input
                            imageInput.value = '';
                        }
                        
                        pdfCanvas.addEventListener('click', addImageHandler, { once: false });
                    };
                    reader.readAsDataURL(file);
                } else {
                    alert('Please select a valid image file');
                    activeTool = 'select';
                    setActiveTool('select');
                    if (pdfCanvas) {
                        pdfCanvas.classList.remove('cursor-crosshair');
                        pdfCanvas.style.cursor = 'default';
                    }
                }
            });
        }
        
        if (highlightBtn && !highlightBtn.hasAttribute('data-listener-attached')) {
            highlightBtn.setAttribute('data-listener-attached', 'true');
            highlightBtn.addEventListener('click', function() {
                // Remove active class from all tools
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                highlightBtn.classList.add('active');
                activeTool = 'highlight';
                setActiveTool('highlight');
                if (selectedTextElement) {
                    selectedTextElement.style.backgroundColor = '#FFFF00';
                    saveAnnotation();
                }
            });
        }
        
        if (undoBtn && !undoBtn.hasAttribute('data-listener-attached')) {
            undoBtn.setAttribute('data-listener-attached', 'true');
            undoBtn.addEventListener('click', function() {
                if (getAnnotationHistory().length > 0) {
                    const history = getAnnotationHistory();
                    const redo = getRedoHistory();
                    redo.push(history.pop());
                    // Restore previous state - reload page with previous annotations
                    if (history.length > 0) {
                        // Restore text annotations from history
                        const prevAnnotations = history[history.length - 1];
                        // Re-render page with previous state
                        renderPage(currentPage);
                    }
                    updateUndoRedoButtons();
                }
            });
        }
        
        if (redoBtn && !redoBtn.hasAttribute('data-listener-attached')) {
            redoBtn.setAttribute('data-listener-attached', 'true');
            redoBtn.addEventListener('click', function() {
                const redo = getRedoHistory();
                if (redo.length > 0) {
                    const history = getAnnotationHistory();
                    history.push(redo.pop());
                    // Restore next state
                    const nextAnnotations = history[history.length - 1];
                    // Re-render page with next state
                    renderPage(currentPage);
                    updateUndoRedoButtons();
                }
            });
        }
        
        if (downloadBtn && !downloadBtn.hasAttribute('data-listener-attached')) {
            downloadBtn.setAttribute('data-listener-attached', 'true');
            downloadBtn.addEventListener('click', async function() {
                // Remove active class from all tools
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                downloadBtn.classList.add('active');
                
                if (!pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                if (!pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    loadingOverlay.style.display = 'flex';
                    
                    // Get current PDF data
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) {
                        throw new Error('PDF file not found in storage');
                    }
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    
                    // Collect all edits (text + images + deletions + OCR + replacements)
                    const edits = {
                        textEdits: [],
                        textReplacements: [], // Real text replacement (find and replace)
                        imageInserts: [],
                        deletions: [], // White rectangles to cover deleted text
                        ocrTexts: [] // OCR text to embed into PDF structure
                    };
                    
                    // Add OCR texts for embedding (Adobe Acrobat Pro style)
                    if (window.ocrTextsForPDF && window.ocrTextsForPDF.length > 0) {
                        // Filter OCR texts for current page
                        const pageOcrTexts = window.ocrTextsForPDF.filter(ocr => ocr.pageIndex === currentPage - 1);
                        edits.ocrTexts = pageOcrTexts.map(ocr => {
                            // Convert to PDF coordinates using viewport
                            const pdfX = (ocr.x / viewport.width) * viewport.width;
                            const pdfY = viewport.height - ((ocr.y + ocr.fontSize) / viewport.height) * viewport.height;
                            return {
                                pageIndex: ocr.pageIndex,
                                text: ocr.text,
                                x: pdfX,
                                y: pdfY,
                                fontSize: ocr.fontSize,
                                fontColor: ocr.fontColor,
                                fontName: ocr.fontName
                            };
                        });
                    }
                    
                    // Get current page viewport for accurate coordinate mapping
                    const page = await pdfDoc.getPage(currentPage);
                    const viewport = page.getViewport({ scale: scale });
                    
                    // Get deletion rectangles (white rectangles covering deleted PDF text)
                    // Adobe Acrobat Pro style - real deletion using white rectangles
                    if (deletionLayer) {
                        const deletionRects = deletionLayer.querySelectorAll('.deletion-rect');
                        deletionRects.forEach((rectEl) => {
                            // Get position from style (more accurate than getBoundingClientRect)
                            const x = parseFloat(rectEl.style.left) || 0;
                            const y = parseFloat(rectEl.style.top) || 0;
                            const width = parseFloat(rectEl.style.width) || 0;
                            const height = parseFloat(rectEl.style.height) || 0;
                            
                            // Convert to PDF coordinates (PDF uses bottom-left origin)
                            const pdfX = (x / viewport.width) * viewport.width;
                            const pdfY = viewport.height - ((y + height) / viewport.height) * viewport.height;
                            
                            edits.deletions.push({
                                pageIndex: currentPage - 1,
                                x: pdfX,
                                y: pdfY,
                                width: (width / viewport.width) * viewport.width,
                                height: (height / viewport.height) * viewport.height
                            });
                        });
                    }
                    
                    // Get text annotations with accurate coordinates
                    // Separate into replacements and new additions (Adobe Acrobat Pro style)
                    const textElements = textLayer.querySelectorAll('.editable-text');
                    textElements.forEach((el, index) => {
                        // Skip OCR texts (they're handled separately)
                        if (el.dataset.ocrBlock === 'true') {
                            return;
                        }
                        
                        // Get position from style (more accurate)
                        const x = parseFloat(el.style.left) || 0;
                        const y = parseFloat(el.style.top) || 0;
                        const fontSize = parseFloat(el.style.fontSize) || 12;
                        const fontFamily = el.style.fontFamily || 'Helvetica';
                        
                        // Convert to PDF coordinates using viewport
                        const pdfX = (x / viewport.width) * viewport.width;
                        const pdfY = viewport.height - ((y + fontSize) / viewport.height) * viewport.height;
                        
                        // Get color
                        const color = el.style.color || '#000000';
                        const rgbMatch = color.match(/\d+/g);
                        const fontColor = rgbMatch ? [
                            parseInt(rgbMatch[0]) || 0,
                            parseInt(rgbMatch[1]) || 0,
                            parseInt(rgbMatch[2]) || 0
                        ] : [0, 0, 0];
                        
                        // Check if this is a replacement (Adobe Acrobat Pro style)
                        const originalText = el.dataset.originalText || originalTexts.get(el);
                        if (originalText && el.dataset.isReplacement === 'true') {
                            // Real text replacement
                            edits.textReplacements.push({
                                pageIndex: currentPage - 1,
                                oldText: originalText,
                                newText: el.textContent,
                                x: pdfX,
                                y: pdfY,
                                fontSize: fontSize,
                                fontName: fontFamily,
                                fontColor: fontColor
                            });
                        } else {
                            // New text addition
                            edits.textEdits.push({
                                pageIndex: currentPage - 1,
                                x: pdfX,
                                y: pdfY,
                                text: el.textContent,
                                fontSize: fontSize,
                                fontName: fontFamily,
                                fontColor: fontColor
                            });
                        }
                    });
                    
                    // Get image elements
                    const imageElements = textLayer.querySelectorAll('img');
                    imageElements.forEach((img) => {
                        const rect = img.getBoundingClientRect();
                        const canvasRect = pdfCanvas.getBoundingClientRect();
                        const scaleX = pdfCanvas.width / canvasRect.width;
                        const scaleY = pdfCanvas.height / canvasRect.height;
                        
                        edits.imageInserts.push({
                            pageIndex: currentPage - 1,
                            imageData: img.src.split(',')[1],
                            x: (rect.left - canvasRect.left) * scaleX,
                            y: (canvasRect.height - (rect.top - canvasRect.top)) * scaleY,
                            width: rect.width * scaleX,
                            height: rect.height * scaleY
                        });
                    });
                    
                    // Convert PDF to base64
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    // Determine API URL based on protocol
                    let editApiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        editApiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    // Send to backend for editing
                    let editResponse;
                    try {
                        editResponse = await fetch(editApiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                pdfData: pdfBase64,
                                edits: edits
                            })
                        });
                    } catch (fetchError) {
                        if (window.location.protocol === 'file:') {
                            alert('PDF editing requires a running server. Please:\n1. Start the Node.js server (npm start in server folder)\n2. Access this page via http://localhost:3000/pdf-editor-preview.html\n\nOr use the online version at easyjpgtopdf.com');
                            loadingOverlay.style.display = 'none';
                            return;
                        }
                        throw fetchError;
                    }
                    
                    const editResult = await editResponse.json();
                    
                    if (editResult.success) {
                        // Download edited PDF
                        const editedPdfBase64 = editResult.pdfData.split(',')[1];
                        const editedPdfBytes = Uint8Array.from(atob(editedPdfBase64), c => c.charCodeAt(0));
                        const blob = new Blob([editedPdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        alert('PDF downloaded successfully!');
                    } else {
                        throw new Error(editResult.error || 'PDF editing failed');
                    }
                    
                    loadingOverlay.style.display = 'none';
                } catch (error) {
                    console.error('Download error:', error);
                    loadingOverlay.style.display = 'none';
                    alert('Error downloading PDF: ' + error.message);
                }
            });
        }
        
        // Initialize highlight color buttons if they exist (for future feature)
        if (highlightColorBtns && highlightColorBtns.length > 0) {
            highlightColorBtns.forEach(btn => {
                if (!btn.hasAttribute('data-listener-attached')) {
                    btn.setAttribute('data-listener-attached', 'true');
                    btn.addEventListener('click', function() {
                        highlightColorBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const color = btn.dataset.color || '#FFFF00';
                        if (selectedTextElement) {
                            selectedTextElement.style.backgroundColor = color;
                        }
                    });
                }
            });
        }
        
        // Initialize image scale value display if it exists (for future feature)
        if (imageScaleValue) {
            // This will be used when image scale slider is added
            console.log('Image scale value element found, ready for future feature');
        }
        
        // Feedback submission
        function submitFeedback() {
            const name = document.getElementById('feedback-name').value;
            const email = document.getElementById('feedback-email').value;
            const message = document.getElementById('feedback-message').value;
            
            if (!name || !email || !message) {
                alert('Please fill in all fields');
                return;
            }
            
            alert('Thank you for your feedback! We appreciate your input.');
            document.getElementById('feedback-name').value = '';
            document.getElementById('feedback-email').value = '';
            document.getElementById('feedback-message').value = '';
        }
        
        // Initialize on page load - load immediately for instant preview
        (function initPDFEditor() {
            // Make preview container visible IMMEDIATELY - no waiting
            function makePreviewVisible() {
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                }
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                }
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                }
            }
            
            // Make visible immediately
            makePreviewVisible();
            
            function startPDFLoad() {
                console.log('startPDFLoad called, pdfjsLib available:', typeof pdfjsLib !== 'undefined');
                
                // Ensure preview container is visible immediately
                makePreviewVisible();
                
                // Wait for PDF.js to load
                if (typeof pdfjsLib === 'undefined') {
                    console.warn('PDF.js library not loaded yet, retrying...');
                    // Retry after a short delay in case script is still loading
                    setTimeout(() => {
                        if (typeof pdfjsLib !== 'undefined') {
                            console.log('PDF.js loaded, starting PDF load');
                            startPDFLoad();
                        } else {
                            console.error('PDF.js library failed to load after retry');
                            if (loadingOverlay) loadingOverlay.style.display = 'none';
                            alert('PDF.js library failed to load. Please refresh the page.');
                        }
                    }, 100);
                    return;
                }
                
                // Set PDF.js worker if not already set
                if (pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    console.log('PDF.js worker configured');
                }
                
                // Load PDF immediately - no delay for instant preview
                console.log('Calling loadPDF()...');
                loadPDF().catch(error => {
                    console.error('Failed to load PDF:', error);
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                });
            }
            
            // Start loading as soon as possible
            function init() {
                // Ensure DOM elements exist
                if (!previewContainer || !pdfCanvas) {
                    // Wait a bit if DOM not ready
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', init);
                        return;
                    }
                }
                makePreviewVisible();
                startPDFLoad();
            }
            
            // Start immediately if DOM is ready, otherwise wait
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                // DOM already loaded, start immediately
                init();
            }
        })(); // Close initPDFEditor IIFE
        })(); // Close main IIFE
    </script>
</body>
</html>

