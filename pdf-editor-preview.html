<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>PDF Editor Online Free - Edit PDF Files Online Without Installation | easyjpgtopdf</title>
    <meta name="description" content="Edit PDF files online for free. Add text, images, annotations, modify PDF documents, highlight content, OCR text extraction - all without software installation. Best free online PDF editor 2024.">
    <meta name="keywords" content="pdf editor online free, edit pdf online, free pdf editor, online pdf editor, edit pdf files, pdf editing tool, modify pdf, edit pdf documents, pdf editor free online, best pdf editor online, edit pdf online free no download, pdf editor website, free online pdf editor, edit pdf text, pdf editor tool, pdf editor with ocr, edit pdf online free, pdf editor no download, online pdf editor free, edit pdf online tool">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://easyjpgtopdf.com/pdf-editor-preview.html">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
    <!-- Preload Critical CSS -->
    <link rel="preload" href="css/header.css" as="style">
    <link rel="preload" href="css/footer.css" as="style">
    
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/theme-modern.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PDF.js for rendering (Fast, Lightweight) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- pdf-lib for real PDF editing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    
    <!-- Professional PDF Editor using enhanced pdf.js + pdf-lib -->
    
    <!-- Schema Markup for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "PDF Editor Online Free",
      "description": "Free online PDF editor to edit PDF files, add text, images, annotations, and extract text with OCR. No software installation required.",
      "url": "https://easyjpgtopdf.com/pdf-editor-preview.html",
      "applicationCategory": "UtilityApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "Edit PDF text online",
        "Add images to PDF",
        "Highlight and annotate PDFs",
        "OCR text extraction",
        "Export to Word, Excel, PowerPoint",
        "Cloud storage integration",
        "No software installation required"
      ],
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "2024",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "1250"
      }
    }
    </script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "PDF Editor Online",
      "applicationCategory": "MultimediaApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free online PDF editor with OCR, text editing, image insertion, annotations, and cloud storage. Edit PDFs without installation.",
      "featureList": [
        "Text editing",
        "Image insertion",
        "Highlighting and annotations",
        "OCR text extraction",
        "Export to multiple formats",
        "Cloud storage"
      ]
    }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #f5f7ff;
            color: #0b1630;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        main {
            flex: 1;
            padding: 30px 0;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .page-header h1 {
            font-size: 2.2rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Professional Editor Workspace */
        .editor-workspace {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 800px;
            background: #2b2b2b;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        /* Left Tools Panel */
        .tools-panel {
            width: 240px;
            min-width: 240px;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .tool-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .tool-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 5px;
        }
        
        .tool-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: #e5e5e5;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-item:hover {
            background: #2d2d2d;
        }
        
        .tool-item.active {
            background: #0078d4;
            color: white;
        }
        
        .tool-item i {
            width: 20px;
            text-align: center;
        }
        
        /* Center Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            overflow: hidden;
        }
        
        .preview-toolbar {
            background: #2b2b2b;
            border-bottom: 1px solid #3a3a3a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .preview-toolbar-btn {
            padding: 6px 12px;
            background: transparent;
            color: #e5e5e5;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .preview-toolbar-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }
        
        .preview-toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
            background: #525252;
            padding: 20px;
            min-height: 100%;
        }
        
        .pdf-page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 0 auto;
        }
        
        .pdf-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        
        /* Overlay system removed - using native PDF editing only */
        
        .deletion-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .deletion-rect {
            position: absolute;
            background: white;
            border: none;
            pointer-events: auto;
            z-index: 6;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #0b1630;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            width: 300px;
            max-width: 80%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .loading-percentage {
            color: #4361ee;
            font-size: 14px;
            margin-top: 8px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile Optimization - Touch Gestures & Responsive UI */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tool-group {
                min-width: 120px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .tool-item {
                min-height: 60px;
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item i {
                font-size: 20px;
                margin-bottom: 4px;
            }
            
            .preview-panel {
                flex: 1;
                min-height: 60vh;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-left: none;
                border-top: 1px solid #3a3a3a;
            }
            
            .property-group {
                min-width: 150px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .pdf-canvas {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            .preview-toolbar-btn {
                min-width: 60px;
                min-height: 44px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            /* Removed .editable-text styles - no longer using DOM overlays */
            /* All text editing now uses backend /api/pdf/edit-text endpoint */
        }
        
        /* Touch Gesture Support */
        .pdf-canvas {
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Larger Touch Targets for Mobile */
        @media (max-width: 768px) {
            button, .tool-item, .preview-toolbar-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            input[type="number"],
            input[type="color"],
            select {
                min-height: 44px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        
        /* Right Properties Panel */
        .properties-panel {
            width: 160px;
            min-width: 160px;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .property-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .property-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 8px;
        }
        
        .property-item {
            padding: 8px 12px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-label {
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .property-input {
            width: 100%;
            padding: 4px 8px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        /* Performance indicators */
        .performance-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        /* Performance Optimizations */
        .pdf-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Lazy loading for pages */
        .pdf-page-wrapper[data-loaded="false"] {
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .pdf-page-wrapper[data-loaded="true"] {
            opacity: 1;
        }
        
        /* Cache optimization */
        .tool-item {
            will-change: transform;
        }
        
        /* Smooth scrolling */
        .tools-panel, .properties-panel {
            scroll-behavior: smooth;
        }
        
        /* Mobile Support - Full Responsive */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: auto;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                flex-direction: row;
                overflow-x: auto;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
                -webkit-overflow-scrolling: touch;
            }
            
            .tool-group {
                min-width: 200px;
                flex-shrink: 0;
            }
            
            .preview-panel {
                order: 2;
                min-height: 500px;
            }
            
            .preview-container {
                min-height: 400px !important;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                order: 3;
                border-left: none;
                border-top: 1px solid #3a3a3a;
                max-height: 300px;
            }
            
            .tool-item {
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item span {
                display: block;
                margin-top: 4px;
            }
            
            /* Touch-friendly buttons */
            .preview-toolbar-btn {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Mobile gestures */
            .pdf-page-wrapper {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            /* Enhanced mobile touch targets */
            .tool-item {
                min-width: 50px;
                min-height: 50px;
            }
            
            /* Mobile-friendly zoom controls */
            .zoom-controls {
                position: fixed;
                bottom: 20px;
                right: 20px;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .zoom-btn {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: #4361ee;
                color: white;
                border: none;
                font-size: 20px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }
        }
        
        /* Real-time Collaboration Styles */
        .collaboration-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 300px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .collaboration-panel.active {
            display: block;
        }
        
        .collaboration-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .collaboration-title {
            font-size: 16px;
            font-weight: 600;
            color: #e5e5e5;
        }
        
        .collaboration-user {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
        }
        
        .collaboration-user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4361ee;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .collaboration-user-name {
            color: #e5e5e5;
            font-size: 14px;
        }
        
        .collaboration-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-left: auto;
        }
        
        .collaboration-chat {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }
        
        .collaboration-message {
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
            font-size: 12px;
            color: #e5e5e5;
        }
        
        .collaboration-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <script src="js/global-components.js"></script>
    <div id="global-header-placeholder"></div>
    <div id="global-breadcrumb-placeholder"></div>
    
    <main>
        <div class="container">
            <div class="page-header">
                <h1>PDF Editor Online Free - Edit PDF Files Without Installation <span class="performance-badge">‚ö° Instant</span></h1>
                <p>Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required - edit PDFs directly in your browser.</p>
            </div>
            
            <!-- Professional Editor Workspace -->
            <div class="editor-workspace">
                <!-- Left Tools Panel -->
                <div class="tools-panel">
                    <div class="tool-group">
                        <div class="tool-group-title">File</div>
                        <div class="tool-item" id="upload-btn" title="Upload PDF">
                            <i class="fas fa-upload"></i>
                            <span>Upload</span>
                        </div>
                        <div class="tool-item" id="download-btn" title="Download PDF">
                            <i class="fas fa-download"></i>
                            <span>Download</span>
                        </div>
                        <div class="tool-item" id="save-cloud-btn" title="Save to Cloud">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <span>Save to Cloud</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Edit</div>
                        <div class="tool-item" id="select-tool" title="Select Tool" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i>
                            <span>Select</span>
                        </div>
                        <div class="tool-item" id="add-text-btn" title="Add Text" data-tool="text">
                            <i class="fas fa-font"></i>
                            <span>Add Text</span>
                        </div>
                        <div class="tool-item" id="add-image-btn" title="Add Image" data-tool="image">
                            <i class="fas fa-image"></i>
                            <span>Add Image</span>
                        </div>
                        <div class="tool-item" id="highlight-btn" title="Highlight" data-tool="highlight">
                            <i class="fas fa-highlighter"></i>
                            <span>Highlight</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Search & Replace</div>
                        <div class="tool-item" id="search-btn" title="Search Text in PDF">
                            <i class="fas fa-search"></i>
                            <span>Search</span>
                        </div>
                        <div class="tool-item" id="replace-btn" title="Find & Replace">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Replace</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">OCR <span class="performance-badge">‚ö° Fast</span></div>
                        <div class="tool-item" id="ocr-btn" title="Advanced OCR">
                            <i class="fas fa-language"></i>
                            <span>OCR</span>
                        </div>
                        <div class="tool-item" id="ocr-server-btn" title="Server-Side Fast OCR">
                            <i class="fas fa-server"></i>
                            <span>Fast Server OCR</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Page Management</div>
                        <div class="tool-item" id="rotate-page-btn" title="Rotate Page">
                            <i class="fas fa-redo"></i>
                            <span>Rotate</span>
                        </div>
                        <div class="tool-item" id="delete-page-btn" title="Delete Page">
                            <i class="fas fa-trash"></i>
                            <span>Delete Page</span>
                        </div>
                        <div class="tool-item" id="reorder-pages-btn" title="Reorder Pages">
                            <i class="fas fa-sort"></i>
                            <span>Reorder</span>
                        </div>
                        <div class="tool-item" id="extract-page-btn" title="Extract Page">
                            <i class="fas fa-file-export"></i>
                            <span>Extract</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Forms</div>
                        <div class="tool-item" id="fill-form-btn" title="Fill Form Fields">
                            <i class="fas fa-edit"></i>
                            <span>Fill Form</span>
                        </div>
                        <div class="tool-item" id="detect-form-btn" title="Detect Form Fields">
                            <i class="fas fa-search"></i>
                            <span>Detect Fields</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Annotations</div>
                        <div class="tool-item" id="comment-btn" title="Add Comment">
                            <i class="fas fa-comment"></i>
                            <span>Comment</span>
                        </div>
                        <div class="tool-item" id="stamp-btn" title="Add Stamp">
                            <i class="fas fa-stamp"></i>
                            <span>Stamp</span>
                        </div>
                        <div class="tool-item" id="shape-btn" title="Add Shape">
                            <i class="fas fa-shapes"></i>
                            <span>Shape</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Export</div>
                        <div class="tool-item" id="export-dropdown-btn" title="Export PDF" style="position: relative; cursor: pointer;">
                            <i class="fas fa-download"></i>
                            <span>Export</span>
                            <i class="fas fa-chevron-down" style="font-size: 10px; margin-left: 5px;"></i>
                            <div id="export-dropdown-menu" style="display: none; position: absolute; top: 100%; left: 0; background: #2d2d2d; border: 1px solid #3a3a3a; border-radius: 4px; min-width: 200px; z-index: 1000; margin-top: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                                <div class="export-option" data-export="word" style="padding: 12px 15px; cursor: pointer; display: flex; align-items: center; gap: 12px; color: #e5e5e5; border-bottom: 1px solid #3a3a3a; transition: background 0.2s;">
                                    <i class="fas fa-file-word" style="color: #2b579a; font-size: 18px;"></i>
                                    <span>Export to Word</span>
                                </div>
                                <div class="export-option" data-export="excel" style="padding: 12px 15px; cursor: pointer; display: flex; align-items: center; gap: 12px; color: #e5e5e5; border-bottom: 1px solid #3a3a3a; transition: background 0.2s;">
                                    <i class="fas fa-file-excel" style="color: #217346; font-size: 18px;"></i>
                                    <span>Export to Excel</span>
                                </div>
                                <div class="export-option" data-export="powerpoint" style="padding: 12px 15px; cursor: pointer; display: flex; align-items: center; gap: 12px; color: #e5e5e5; border-bottom: 1px solid #3a3a3a; transition: background 0.2s;">
                                    <i class="fas fa-file-powerpoint" style="color: #d04423; font-size: 18px;"></i>
                                    <span>Export to PowerPoint</span>
                                </div>
                                <div class="export-option" data-export="image" style="padding: 12px 15px; cursor: pointer; display: flex; align-items: center; gap: 12px; color: #e5e5e5; transition: background 0.2s;">
                                    <i class="fas fa-file-image" style="color: #4caf50; font-size: 18px;"></i>
                                    <span>Export to Images</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Collaboration</div>
                        <div class="tool-item" id="collaboration-btn" title="Real-time Collaboration">
                            <i class="fas fa-users"></i>
                            <span>Share</span>
                        </div>
                        <div class="tool-item" id="add-page-btn" title="Add New Page">
                            <i class="fas fa-plus-square"></i>
                            <span>Add Page</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Tools</div>
                        <div class="tool-item" id="compress-btn" title="Compress PDF">
                            <i class="fas fa-compress"></i>
                            <span>Compress</span>
                        </div>
                        <div class="tool-item" id="merge-btn" title="Merge PDFs">
                            <i class="fas fa-layer-group"></i>
                            <span>Merge</span>
                        </div>
                        <div class="tool-item" id="split-btn" title="Split PDF">
                            <i class="fas fa-cut"></i>
                            <span>Split</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Security & Extra</div>
                        <div class="tool-item" id="watermark-btn" title="Add Watermark">
                            <i class="fas fa-tint"></i>
                            <span>Watermark</span>
                        </div>
                        <div class="tool-item" id="sign-btn" title="Digital Signature">
                            <i class="fas fa-signature"></i>
                            <span>Sign</span>
                        </div>
                        <div class="tool-item" id="redact-btn" title="Redact Text">
                            <i class="fas fa-eye-slash"></i>
                            <span>Redact</span>
                        </div>
                        <div class="tool-item" id="protect-btn" title="Protect PDF">
                            <i class="fas fa-lock"></i>
                            <span>Protect</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">History</div>
                        <div class="tool-item" id="undo-btn" title="Undo" disabled>
                            <i class="fas fa-undo"></i>
                            <span>Undo</span>
                        </div>
                        <div class="tool-item" id="redo-btn" title="Redo" disabled>
                            <i class="fas fa-redo"></i>
                            <span>Redo</span>
                        </div>
                    </div>
                </div>
                
                <!-- Search & Replace Panel -->
                <div class="search-panel" id="search-panel">
                    <div class="search-header">
                        <div class="search-title">Search & Replace</div>
                        <button class="search-close" id="search-close-btn">&times;</button>
                    </div>
                    <div class="search-input-group">
                        <label>Search for:</label>
                        <input type="text" class="search-input" id="search-input" placeholder="Enter text to search...">
                    </div>
                    <div class="search-input-group" id="replace-input-group" style="display: none;">
                        <label>Replace with:</label>
                        <input type="text" class="search-input" id="replace-input" placeholder="Enter replacement text...">
                    </div>
                    <div class="search-options">
                        <div class="search-option">
                            <input type="checkbox" id="case-sensitive">
                            <label for="case-sensitive">Case sensitive</label>
                        </div>
                        <div class="search-option">
                            <input type="checkbox" id="whole-words">
                            <label for="whole-words">Whole words</label>
                        </div>
                    </div>
                    <div class="search-actions">
                        <button class="search-btn" id="search-execute-btn">Search</button>
                        <button class="search-btn" id="replace-execute-btn" style="display: none;">Replace All</button>
                    </div>
                    <div class="search-match-count" id="search-match-count"></div>
                    <div class="search-results" id="search-results"></div>
                </div>
                
                <!-- Center Preview Panel -->
                <div class="preview-panel">
                    <div class="preview-toolbar">
                        <button class="preview-toolbar-btn" id="prev-page" disabled>
                            <i class="fas fa-chevron-left"></i> Prev
                        </button>
                        <span class="page-info" style="color: #e5e5e5; font-size: 12px; padding: 0 10px;">
                            Page <span id="page-num">1</span> of <span id="page-count">1</span>
                        </span>
                        <button class="preview-toolbar-btn" id="next-page" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <div style="flex: 1;"></div>
                        <!-- Search Bar -->
                        <div style="display: flex; align-items: center; gap: 5px; margin-right: 10px; background: #2d2d2d; border: 1px solid #3a3a3a; border-radius: 4px; padding: 2px;">
                            <input type="text" id="quick-search-input" placeholder="Search in PDF..." style="padding: 4px 8px; border: none; background: transparent; color: #e5e5e5; font-size: 12px; width: 150px; outline: none;" />
                            <button class="preview-toolbar-btn" id="quick-search-btn" title="Search" style="padding: 4px 8px; border: none; background: transparent; color: #e5e5e5; cursor: pointer;">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                        <button class="preview-toolbar-btn" id="zoom-out-btn">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span style="color: #e5e5e5; font-size: 12px; padding: 0 10px;" id="zoom-level">100%</span>
                        <button class="preview-toolbar-btn" id="zoom-in-btn">
                            <i class="fas fa-search-plus"></i>
                        </button>
                    </div>
                    
                    <div class="preview-container" id="preview-container" style="display: flex; visibility: visible; min-height: 600px;">
                        <div class="loading-overlay" id="loading-overlay" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="loading-text">Processing...</div>
                            <div class="loading-progress">
                                <div class="loading-progress-bar" id="loading-progress-bar"></div>
                            </div>
                            <div class="loading-percentage" id="loading-percentage">0%</div>
                        </div>
                        <div id="pdf-page-wrapper" class="pdf-page-wrapper" style="display: block; visibility: visible; position: relative;">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="deletion-layer" class="deletion-layer"></div>
                            <div id="text-layer" class="text-layer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Properties Panel -->
                <div class="properties-panel">
                    <div class="property-group">
                        <div class="property-group-title">Text Properties</div>
                        <div class="property-item">
                            <div class="property-label">Font Size</div>
                            <input type="number" class="property-input" id="font-size-input" value="12" min="8" max="72">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Font Family</div>
                            <select class="property-input" id="font-family-select">
                                <option value="Helvetica">Helvetica</option>
                                <option value="Helvetica-Bold">Helvetica Bold</option>
                                <option value="Helvetica-Oblique">Helvetica Oblique</option>
                                <option value="Helvetica-BoldOblique">Helvetica Bold Oblique</option>
                                <option value="Times-Roman">Times Roman</option>
                                <option value="Times-Bold">Times Bold</option>
                                <option value="Times-Italic">Times Italic</option>
                                <option value="Times-BoldItalic">Times Bold Italic</option>
                                <option value="Courier">Courier</option>
                                <option value="Courier-Bold">Courier Bold</option>
                                <option value="Courier-Oblique">Courier Oblique</option>
                                <option value="Courier-BoldOblique">Courier Bold Oblique</option>
                                <option value="Arial">Arial</option>
                                <option value="Symbol">Symbol</option>
                                <option value="ZapfDingbats">ZapfDingbats</option>
                            </select>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Color</div>
                            <input type="color" class="property-input" id="text-color-input" value="#000000">
                        </div>
                        <div class="property-item" style="margin-top: 15px;">
                            <button class="property-input" id="delete-text-btn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-trash"></i> Delete Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Page Actions</div>
                        <div class="property-item">
                            <button class="property-input" id="rotate-90-btn" style="width: 100%; padding: 6px; background: #2d2d2d; color: #e5e5e5; border: 1px solid #3a3a3a; border-radius: 4px; cursor: pointer; font-size: 11px; margin-bottom: 5px;">
                                <i class="fas fa-redo"></i> Rotate 90¬∞
                            </button>
                            <button class="property-input" id="delete-current-page-btn" style="width: 100%; padding: 6px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                <i class="fas fa-trash"></i> Delete Page
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Export Format</div>
                        <div class="property-item">
                            <select class="property-input" id="export-format-select" style="margin-bottom: 5px;">
                                <option value="pdf">PDF</option>
                                <option value="word">Word (DOCX)</option>
                                <option value="excel">Excel (XLSX)</option>
                                <option value="powerpoint">PowerPoint (PPTX)</option>
                                <option value="image">Images (PNG)</option>
                            </select>
                            <button class="property-input" id="export-btn" style="width: 100%; padding: 8px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Compression</div>
                        <div class="property-item">
                            <select class="property-input" id="compression-quality" style="margin-bottom: 5px;">
                                <option value="low">Low (Smaller Size)</option>
                                <option value="medium" selected>Medium (Balanced)</option>
                                <option value="high">High (Better Quality)</option>
                            </select>
                            <button class="property-input" id="compress-pdf-btn" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-compress"></i> Compress
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Performance</div>
                        <div class="property-item">
                            <div class="property-label">Rendering</div>
                            <div style="color: #28a745; font-size: 11px;">‚ö° PDF.js (Fast)</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Processing</div>
                            <div style="color: #28a745; font-size: 11px;">‚òÅÔ∏è Server-Side</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">OCR Engine</div>
                            <div style="color: #28a745; font-size: 11px;">üîç OCR Ready</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- SSL Security & Trust Section -->
    <section class="ssl-security-section" style="background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%); padding: 60px 20px; margin-top: 40px;">
        <div class="container">
            <h2 style="text-align: center; font-size: 2rem; color: #0b1630; margin-bottom: 40px;">üîí Secure & Trusted PDF Editor</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 30px; max-width: 1200px; margin: 0 auto;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üîê</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">SSL Encrypted</h3>
                    <p style="color: #64748b; line-height: 1.6;">256-bit SSL encryption ensures your PDF files are secure during upload and processing. All data is encrypted in transit.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üõ°Ô∏è</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Privacy Protected</h3>
                    <p style="color: #64748b; line-height: 1.6;">Your PDF files are processed securely and automatically deleted after processing. We never store or share your documents.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚úÖ</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">100% Free</h3>
                    <p style="color: #64748b; line-height: 1.6;">No hidden costs, no subscriptions, no credit card required. Edit PDFs online completely free with unlimited usage.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ö°</div>
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Fast Processing</h3>
                    <p style="color: #64748b; line-height: 1.6;">Edit PDFs instantly in your browser. No waiting, no upload delays. Fast and efficient PDF editing experience.</p>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Features & Tools Description Section -->
    <section class="features-feedback-section" style="background: #ffffff; padding: 60px 20px; margin-top: 20px;">
        <div class="container">
            <h2 style="text-align: center; font-size: 2rem; color: #0b1630; margin-bottom: 50px;">üìù PDF Editor Features & Tools</h2>
            
            <div style="max-width: 1000px; margin: 0 auto;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; margin-bottom: 40px;">
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-edit" style="color: #4361ee;"></i> Text Editing
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Add, edit, and delete text in your PDF documents. Change font size, color, and style. Native PDF text editing ensures your changes are permanent.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-image" style="color: #4361ee;"></i> Image Insertion
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Insert images into your PDF files. Add logos, photos, or graphics to enhance your documents. Supports JPG, PNG, and other image formats.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-highlighter" style="color: #4361ee;"></i> Highlighting & Annotations
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Highlight important text, add comments, stamps, and shapes. Annotate your PDFs for review, collaboration, or personal notes.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-eye" style="color: #4361ee;"></i> OCR Text Extraction
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Extract text from scanned PDFs and images using OCR technology. Make scanned documents searchable and editable.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-cloud-upload-alt" style="color: #4361ee;"></i> Cloud Storage
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Save your edited PDFs directly to cloud storage. Access your documents from anywhere, anytime.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-file-export" style="color: #4361ee;"></i> Export Formats
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Export your PDFs to Word, Excel, PowerPoint, or images. Convert PDFs to various formats for easy editing.</p>
                    </div>
                </div>
                
                <!-- Feedback Section -->
                <div style="background: linear-gradient(135deg, #4361ee 0%, #3a56d4 100%); padding: 40px; border-radius: 12px; color: white; text-align: center;">
                    <h3 style="font-size: 1.5rem; margin-bottom: 15px;">üí¨ We Value Your Feedback</h3>
                    <p style="font-size: 1.1rem; margin-bottom: 25px; opacity: 0.95;">Help us improve our PDF editor. Share your experience, suggestions, or report any issues.</p>
                    <a href="index.html#contact" style="display: inline-block; background: white; color: #4361ee; padding: 12px 30px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: transform 0.2s;">
                        Share Feedback <i class="fas fa-arrow-right" style="margin-left: 8px;"></i>
                    </a>
                </div>
            </div>
        </div>
    </section>
    
    <div id="global-footer-placeholder"></div>
    
    <input type="file" id="file-input" accept="application/pdf,.pdf" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
    <script src="js/mobile-menu-init.js"></script>
    <script>
        // Get API base URL helper
        function getApiBaseUrl() {
            if (window.location.protocol === 'file:') {
                return 'http://localhost:3000';
            }
            return '';
        }
        
        // Loading overlay functions
        function showLoading(message, progress = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
                const loadingText = loadingOverlay.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = message || 'Processing...';
                }
                // Update progress if progress bar exists
                const progressBar = loadingOverlay.querySelector('.progress-bar');
                if (progressBar && progress >= 0) {
                    progressBar.style.width = progress + '%';
                }
            }
        }
        
        function hideLoading() {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
        
        function updateProgress(percent, message) {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                const progressBar = loadingOverlay.querySelector('.progress-bar');
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                }
                const loadingText = loadingOverlay.querySelector('.loading-text');
                if (loadingText && message) {
                    loadingText.textContent = message;
                }
            }
        }
        
        function showError(message) {
            hideLoading();
            alert('Error: ' + message);
        }
        
        // Professional PDF Editor Implementation
        // Features: PDF.js rendering, Server processing, Fast OCR, Native editing, Cloud integration
        
        // Set PDF.js worker for performance
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
        
        // Global variables
        if (typeof window.pdfEditorVars === 'undefined') {
            window.pdfEditorVars = {
                pdfDoc: null,
                currentPage: 1,
                totalPages: 1,
                scale: 1.5,
                textAnnotations: [],
                annotationHistory: [],
                redoHistory: [],
                selectedTextElement: null,
                activeTool: 'select',
                ocrTextsForPDF: [],
                annotations: {
                    highlights: [],
                    comments: [],
                    stamps: [],
                    shapes: []
                },
                highlightStart: null,
                highlightEnd: null,
                isDrawing: false
            };
        }
        
        // DOM elements
        const previewContainer = document.getElementById('preview-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const pdfPageWrapper = document.getElementById('pdf-page-wrapper');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const textLayer = document.getElementById('text-layer');
        const deletionLayer = document.getElementById('deletion-layer');
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const downloadBtn = document.getElementById('download-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const saveCloudBtn = document.getElementById('save-cloud-btn');
        const ocrBtn = document.getElementById('ocr-btn');
        const ocrServerBtn = document.getElementById('ocr-server-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const highlightBtn = document.getElementById('highlight-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const imageInput = document.getElementById('image-input');
        const fileInput = document.getElementById('file-input');
        const selectTool = document.getElementById('select-tool');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomLevel = document.getElementById('zoom-level');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorInput = document.getElementById('text-color-input');
        const deleteTextBtn = document.getElementById('delete-text-btn');
        const searchBtn = document.getElementById('search-btn');
        const replaceBtn = document.getElementById('replace-btn');
        const searchPanel = document.getElementById('search-panel');
        const searchCloseBtn = document.getElementById('search-close-btn');
        const searchInput = document.getElementById('search-input');
        const replaceInput = document.getElementById('replace-input');
        const replaceInputGroup = document.getElementById('replace-input-group');
        const searchExecuteBtn = document.getElementById('search-execute-btn');
        const replaceExecuteBtn = document.getElementById('replace-execute-btn');
        const searchResults = document.getElementById('search-results');
        const searchMatchCount = document.getElementById('search-match-count');
        const caseSensitiveCheck = document.getElementById('case-sensitive');
        const wholeWordsCheck = document.getElementById('whole-words');
        
        // Search & Replace functionality (HIGH PRIORITY)
        let currentSearchMatches = [];
        let currentSearchIndex = -1;
        
        // Quick search in toolbar
        const quickSearchInput = document.getElementById('quick-search-input');
        const quickSearchBtn = document.getElementById('quick-search-btn');
        
        if (quickSearchBtn) {
            quickSearchBtn.addEventListener('click', function() {
                if (quickSearchInput && quickSearchInput.value.trim()) {
                    // Open search panel and execute search
                    if (searchPanel) {
                        searchPanel.classList.add('active');
                        searchInput.value = quickSearchInput.value;
                        searchInput.focus();
                        replaceInputGroup.style.display = 'none';
                        replaceExecuteBtn.style.display = 'none';
                        // Trigger search
                        if (searchExecuteBtn) {
                            searchExecuteBtn.click();
                        }
                    }
                } else if (searchPanel) {
                    // Just open search panel
                    searchPanel.classList.add('active');
                    searchInput.focus();
                    replaceInputGroup.style.display = 'none';
                    replaceExecuteBtn.style.display = 'none';
                }
            });
        }
        
        if (quickSearchInput) {
            quickSearchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && quickSearchInput.value.trim()) {
                    quickSearchBtn.click();
                }
            });
        }
        
        // Open search panel (search icon button - works as button)
        if (searchBtn) {
            searchBtn.addEventListener('click', function() {
                if (searchPanel) {
                    searchPanel.classList.add('active');
                    searchInput.focus();
                    replaceInputGroup.style.display = 'none';
                    replaceExecuteBtn.style.display = 'none';
                }
            });
        }
        
        // Open replace panel
        if (replaceBtn) {
            replaceBtn.addEventListener('click', function() {
                if (searchPanel) {
                    searchPanel.classList.add('active');
                    searchInput.focus();
                    replaceInputGroup.style.display = 'block';
                    replaceExecuteBtn.style.display = 'block';
                }
            });
        }
        
        // Close search panel
        if (searchCloseBtn) {
            searchCloseBtn.addEventListener('click', function() {
                if (searchPanel) {
                    searchPanel.classList.remove('active');
                    currentSearchMatches = [];
                    currentSearchIndex = -1;
                }
            });
        }
        
        // Execute search
        if (searchExecuteBtn) {
            searchExecuteBtn.addEventListener('click', async function() {
                const query = searchInput.value.trim();
                if (!query) {
                    alert('Please enter a search query');
                    return;
                }
                
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                if (!fileId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Searching PDF...', 30);
                    const apiBaseUrl = getApiBaseUrl();
                    const response = await fetch(`${apiBaseUrl}/api/pdf/search`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fileId: fileId,
                            searchQuery: query,
                            caseSensitive: caseSensitiveCheck.checked,
                            wholeWords: wholeWordsCheck.checked
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Search failed: ' + response.status);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        currentSearchMatches = result.matches || [];
                        currentSearchIndex = -1;
                        
                        // Display results
                        displaySearchResults(currentSearchMatches, query);
                        
                        // Update match count
                        searchMatchCount.textContent = `Found ${currentSearchMatches.length} match(es)`;
                        
                        // Navigate to first match
                        if (currentSearchMatches.length > 0) {
                            navigateToMatch(0);
                        }
                    } else {
                        alert('Search failed: ' + (result.error || 'Unknown error'));
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Search error:', error);
                    hideLoading();
                    alert('Error searching PDF: ' + error.message);
                }
            });
        }
        
        // Execute replace all
        if (replaceExecuteBtn) {
            replaceExecuteBtn.addEventListener('click', async function() {
                const searchText = searchInput.value.trim();
                const replaceText = replaceInput.value.trim();
                
                if (!searchText) {
                    alert('Please enter text to search');
                    return;
                }
                
                if (!confirm(`Replace all occurrences of "${searchText}" with "${replaceText}"?`)) {
                    return;
                }
                
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                if (!fileId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Replacing text...', 30);
                    const apiBaseUrl = getApiBaseUrl();
                    const response = await fetch(`${apiBaseUrl}/api/pdf/replace-all`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fileId: fileId,
                            searchText: searchText,
                            replaceText: replaceText,
                            caseSensitive: caseSensitiveCheck.checked,
                            wholeWords: wholeWordsCheck.checked
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Replace failed: ' + response.status);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Update PDF data
                        window.pdfEditorVars.currentPdfData = result.pdfData;
                        await reloadPDF();
                        
                        alert(`Successfully replaced ${result.replacementsCount} occurrence(s)`);
                        searchPanel.classList.remove('active');
                    } else {
                        alert('Replace failed: ' + (result.error || 'Unknown error'));
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Replace error:', error);
                    hideLoading();
                    alert('Error replacing text: ' + error.message);
                }
            });
        }
        
        // Display search results
        function displaySearchResults(matches, query) {
            if (!searchResults) return;
            
            searchResults.innerHTML = '';
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div style="padding: 20px; text-align: center; color: #9ca3af;">No matches found</div>';
                return;
            }
            
            matches.forEach((match, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'search-result-item';
                resultItem.innerHTML = `
                    <div class="search-result-text">${highlightMatch(match.text, query, match.matchIndex, match.matchLength)}</div>
                    <div class="search-result-meta">Page ${match.pageIndex + 1} ‚Ä¢ Position: (${Math.round(match.x)}, ${Math.round(match.y)})</div>
                `;
                resultItem.addEventListener('click', () => navigateToMatch(index));
                searchResults.appendChild(resultItem);
            });
        }
        
        // Highlight match in text
        function highlightMatch(text, query, matchIndex, matchLength) {
            const before = text.substring(0, matchIndex);
            const match = text.substring(matchIndex, matchIndex + matchLength);
            const after = text.substring(matchIndex + matchLength);
            return `${escapeHtml(before)}<mark style="background: #ffeb3b; color: #000;">${escapeHtml(match)}</mark>${escapeHtml(after)}`;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Navigate to match
        function navigateToMatch(index) {
            if (index < 0 || index >= currentSearchMatches.length) return;
            
            currentSearchIndex = index;
            const match = currentSearchMatches[index];
            
            // Navigate to page
            if (match.pageIndex + 1 !== window.pdfEditorVars.currentPage) {
                window.pdfEditorVars.currentPage = match.pageIndex + 1;
                renderPDF();
            }
            
            // Highlight active result
            const resultItems = searchResults.querySelectorAll('.search-result-item');
            resultItems.forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });
            
            // Scroll to result item
            if (resultItems[index]) {
                resultItems[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Keyboard shortcuts for search
        document.addEventListener('keydown', function(e) {
            // Ctrl+F or Cmd+F to open search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                if (searchBtn) searchBtn.click();
            }
            
            // Escape to close search
            if (e.key === 'Escape' && searchPanel && searchPanel.classList.contains('active')) {
                searchCloseBtn.click();
            }
            
            // Enter in search input to search
            if (e.key === 'Enter' && searchInput === document.activeElement) {
                if (searchExecuteBtn) searchExecuteBtn.click();
            }
        });
        
        // File upload handler - will be set up in initButtonEventListeners
        // This prevents duplicate listeners
        if (fileInput) {
            fileInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                    alert('Please select a valid PDF file');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Option 1: Direct server upload for processing (Fast)
                    const formData = new FormData();
                    formData.append('pdfFile', file);
                    
                    // Get API base URL
                    const apiBaseUrl = getApiBaseUrl();
                    const uploadUrl = `${apiBaseUrl}/api/pdf/upload`;
                    console.log('Uploading to:', uploadUrl);
                    
                    try {
                        updateProgress(20, 'Uploading to server...');
                        const uploadResponse = await fetch(uploadUrl, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (uploadResponse.ok) {
                            const result = await uploadResponse.json();
                            if (result.success && result.fileId) {
                                updateProgress(60, 'Loading PDF from server...');
                                
                                // Store file ID and server URL
                                const apiBaseUrl = getApiBaseUrl();
                                const serverUrl = `${apiBaseUrl}/api/pdf/load/${result.fileId}`;
                                
                                sessionStorage.setItem('pdfFileId', result.fileId);
                                sessionStorage.setItem('pdfServerUrl', serverUrl);
                                sessionStorage.setItem('pdfFileName', result.filename || file.name);
                                sessionStorage.setItem('pdfFileSize', (result.size || file.size).toString());
                                
                                window.pdfEditorVars.currentFileId = result.fileId;
                                
                                // Load PDF from server using file ID
                                const loadResponse = await fetch(serverUrl);
                                if (loadResponse.ok) {
                                    const pdfArrayBuffer = await loadResponse.arrayBuffer();
                                    
                                    // Store PDF data
                                    const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                    window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                                    
                                    // Store in sessionStorage for fallback
                                    const blob = new Blob([pdfArrayBuffer], { type: 'application/pdf' });
                                    const blobURL = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', blobURL);
                                    
                                    updateProgress(90, 'Rendering PDF...');
                                    await renderPDF(pdfArrayBuffer);
                                    hideLoading();
                                    
                                    console.log('PDF uploaded and loaded successfully. File ID:', result.fileId);
                                    return;
                                } else {
                                    throw new Error('Failed to load PDF from server');
                                }
                            } else {
                                throw new Error(result.error || 'Upload failed');
                            }
                        } else {
                            const errorData = await uploadResponse.json().catch(() => ({}));
                            throw new Error(errorData.error || `Upload failed: ${uploadResponse.status}`);
                        }
                    } catch (uploadError) {
                        console.warn('Server upload failed, using client-side processing:', uploadError);
                        // Continue with client-side processing - no error shown to user
                    }
                    
                    // Option 2: Client-side processing (Fallback)
                    // This always runs if server upload fails or is skipped
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        try {
                            const pdfData = e.target.result;
                            
                            // Store PDF data
                            const arrayBuffer = pdfData;
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for persistence
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            sessionStorage.setItem('pdfFileName', file.name);
                            
                            await renderPDF(pdfData);
                            hideLoading();
                        } catch (renderError) {
                            console.error('PDF rendering error:', renderError);
                            hideLoading();
                            showError('Error loading PDF: ' + renderError.message);
                        }
                    };
                    reader.onerror = function() {
                        hideLoading();
                        showError('Error reading PDF file. Please try again.');
                    };
                    reader.readAsArrayBuffer(file);
                    
                } catch (error) {
                    console.error('File upload error:', error);
                    hideLoading();
                    alert('Error uploading PDF: ' + error.message);
                }
            });
        }
        
        // Check for PDF from edit-pdf.html on page load
        async function checkForStoredPDF() {
            try {
                // Check for PDF server URL first (from edit-pdf.html upload)
                const pdfServerUrl = sessionStorage.getItem('pdfServerUrl');
                const pdfFileId = sessionStorage.getItem('pdfFileId');
                
                if (pdfServerUrl) {
                    console.log('Found PDF server URL:', pdfServerUrl);
                    showLoading('Loading PDF from server...', 20);
                    
                    try {
                        const response = await fetch(pdfServerUrl);
                        if (response.ok) {
                            const arrayBuffer = await response.arrayBuffer();
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for fallback
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            
                            if (pdfFileId) {
                                window.pdfEditorVars.currentFileId = pdfFileId;
                            }
                            
                            await renderPDF(arrayBuffer);
                            hideLoading();
                            console.log('PDF loaded from server successfully');
                            return;
                        } else {
                            console.warn('Failed to load PDF from server URL:', response.status);
                        }
                    } catch (serverError) {
                        console.warn('Server URL load failed, trying file ID:', serverError);
                        hideLoading();
                    }
                }
                
                // Fallback: Check for PDF file ID from server upload
                if (pdfFileId && !pdfServerUrl) {
                    console.log('Found PDF file ID:', pdfFileId);
                    showLoading('Loading PDF from server...', 20);
                    
                    try {
                        // Load PDF from backend using file ID
                        const apiBaseUrl = getApiBaseUrl();
                        const loadUrl = `${apiBaseUrl}/api/pdf/load/${pdfFileId}`;
                        
                        const response = await fetch(loadUrl);
                        
                        if (!response.ok) {
                            throw new Error(`Failed to load PDF: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        
                        // Store as current PDF data
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                        window.pdfEditorVars.currentFileId = pdfFileId;
                        
                        // Store in sessionStorage for fallback
                        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                        const blobURL = URL.createObjectURL(blob);
                        sessionStorage.setItem('pdfFileURL', blobURL);
                        
                        // Render PDF
                        await renderPDF(arrayBuffer);
                        hideLoading();
                        return;
                    } catch (error) {
                        console.error('Error loading PDF from server:', error);
                        hideLoading();
                        // Fall through to blob URL fallback
                    }
                }
                
                // Fallback: Check sessionStorage for PDF blob URL or base64
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                const pdfFileName = sessionStorage.getItem('pdfFileName');
                const pdfFileBase64 = sessionStorage.getItem('pdfFileBase64');
                
                if (pdfFileBase64) {
                    // Use base64 if available (more reliable)
                    console.log('Found PDF from base64:', pdfFileName);
                    showLoading('Loading PDF...', 20);
                    
                    try {
                        // Convert base64 to ArrayBuffer (create new buffer to avoid detached error)
                        const binaryString = atob(pdfFileBase64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        // Create a new ArrayBuffer copy to avoid detached buffer error
                        const arrayBuffer = new Uint8Array(bytes).buffer;
                        
                        // Store as current PDF data
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${pdfFileBase64}`;
                        
                        // Render PDF
                        console.log('Rendering PDF from base64, arrayBuffer size:', arrayBuffer.byteLength);
                        await renderPDF(arrayBuffer);
                        hideLoading();
                        console.log('‚úÖ PDF loaded from base64 successfully');
                        console.log('PDF Doc:', window.pdfEditorVars.pdfDoc);
                        console.log('Total Pages:', window.pdfEditorVars.totalPages);
                        return;
                    } catch (error) {
                        console.error('Error loading PDF from base64:', error);
                        hideLoading();
                    }
                }
                
                if (pdfFileURL && pdfFileName) {
                    console.log('Found PDF from blob URL:', pdfFileName);
                    showLoading('Loading PDF...', 20);
                    
                    try {
                        // Fetch PDF from blob URL
                        const response = await fetch(pdfFileURL);
                        if (!response.ok) {
                            throw new Error('Failed to fetch blob URL');
                        }
                        const pdfBlob = await response.blob();
                        const arrayBuffer = await pdfBlob.arrayBuffer();
                        
                        // Store as current PDF data
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                        
                        // Also store base64 for future use
                        sessionStorage.setItem('pdfFileBase64', base64);
                        
                        // Render PDF
                        await renderPDF(arrayBuffer);
                        hideLoading();
                        console.log('‚úÖ PDF loaded from blob URL successfully');
                    } catch (error) {
                        console.error('Error loading stored PDF from blob URL:', error);
                        hideLoading();
                        // Show error message to user
                        if (previewContainer) {
                            previewContainer.innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #dc3545;">
                                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i>
                                    <h3>PDF Load Error</h3>
                                    <p>Failed to load PDF file. Please upload again.</p>
                                    <button onclick="window.location.href='edit-pdf.html'" style="margin-top: 20px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                        Upload PDF Again
                                    </button>
                                </div>
                            `;
                        }
                    }
                } else {
                    // No PDF found at all
                    console.warn('No PDF found in sessionStorage');
                    if (previewContainer) {
                        previewContainer.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #6c757d;">
                                <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 20px; opacity: 0.5;"></i>
                                <h3>No PDF Found</h3>
                                <p>Please upload a PDF file to get started.</p>
                                <button onclick="window.location.href='edit-pdf.html'" style="margin-top: 20px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                    Upload PDF
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error checking for stored PDF:', error);
            }
        }
        
        // Load PDF from Base64 string
        async function loadPDFFromBase64(base64String) {
            try {
                showLoading('Loading PDF...', 10);
                
                // Remove data URL prefix if present
                let base64 = base64String;
                if (base64String.startsWith('data:application/pdf;base64,')) {
                    base64 = base64String.split(',')[1];
                }
                
                // Convert base64 to ArrayBuffer
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const arrayBuffer = bytes.buffer;
                
                updateProgress(50, 'Rendering PDF...');
                await renderPDF(arrayBuffer);
                
                // Store in sessionStorage for persistence
                const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                const blobURL = URL.createObjectURL(blob);
                sessionStorage.setItem('pdfFileURL', blobURL);
                
                hideLoading();
                return true;
            } catch (error) {
                console.error('Error loading PDF from base64:', error);
                hideLoading();
                showError('Failed to load PDF: ' + error.message);
                return false;
            }
        }
        
        // Reload PDF after edits (refreshes display with updated PDF)
        async function reloadPDF() {
            try {
                if (!window.pdfEditorVars.currentPdfData) {
                    throw new Error('No PDF data available to reload');
                }
                
                showLoading('Reloading PDF...', 20);
                
                // Load from stored base64 data
                const success = await loadPDFFromBase64(window.pdfEditorVars.currentPdfData);
                
                if (success) {
                    hideLoading();
                    return true;
                } else {
                    hideLoading();
                    return false;
                }
            } catch (error) {
                console.error('Error reloading PDF:', error);
                hideLoading();
                showError('Failed to reload PDF: ' + error.message);
                return false;
            }
        }
        
        // Show error message to user
        function showError(message) {
            hideLoading();
            alert('Error: ' + message);
            console.error('PDF Editor Error:', message);
        }
        
        // Render PDF (Fast PDF.js rendering)
        async function renderPDF(pdfData) {
            try {
                if (!pdfjsLib) {
                    throw new Error('PDF.js library not loaded');
                }
                
                // Ensure preview container is visible FIRST
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                    previewContainer.style.minHeight = '600px';
                }
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                    pdfPageWrapper.setAttribute('data-loaded', 'true');
                }
                
                console.log('Rendering PDF...', { 
                    previewContainer: !!previewContainer, 
                    pdfPageWrapper: !!pdfPageWrapper,
                    pdfCanvas: !!pdfCanvas 
                });
                
                // Fix ArrayBuffer detached error - create a copy
                let pdfDataToLoad = pdfData;
                if (pdfData instanceof ArrayBuffer) {
                    // Create a new Uint8Array and copy to avoid detached buffer
                    const uint8Array = new Uint8Array(pdfData);
                    pdfDataToLoad = new Uint8Array(uint8Array).buffer;
                }
                
                const loadingTask = pdfjsLib.getDocument({ data: pdfDataToLoad });
                const pdfDoc = await loadingTask.promise;
                window.pdfEditorVars.pdfDoc = pdfDoc;
                window.pdfEditorVars.totalPages = pdfDoc.numPages;
                
                // Store PDF data for editing
                // Create a copy of ArrayBuffer to avoid detached buffer error
                if (pdfData instanceof ArrayBuffer) {
                    // Create a new Uint8Array from the buffer to ensure it's not detached
                    const uint8Array = new Uint8Array(pdfData);
                    const base64 = btoa(String.fromCharCode(...uint8Array));
                    window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                    // Also store the original buffer copy for rendering
                    window.pdfEditorVars.currentPdfBuffer = new Uint8Array(pdfData).buffer;
                } else if (typeof pdfData === 'string') {
                    window.pdfEditorVars.currentPdfData = pdfData;
                }
                
                if (pageCount) pageCount.textContent = pdfDoc.numPages;
                
                await renderPage(1);
                updatePageButtons();
                
                if (downloadBtn) downloadBtn.disabled = false;
                
                console.log('PDF rendered successfully');
                
            } catch (error) {
                console.error('Error rendering PDF:', error);
                showError('Error rendering PDF: ' + error.message);
            }
        }
        
        // Render specific page (with memory leak fix)
        let currentPageRenderTask = null;
        async function renderPage(pageNumber) {
            try {
                const pdfDoc = window.pdfEditorVars.pdfDoc;
                if (!pdfDoc) return;
                
                // Cancel previous render task to prevent memory leaks
                if (currentPageRenderTask) {
                    currentPageRenderTask.cancel();
                    currentPageRenderTask = null;
                }
                
                // Clear canvas and layers
                const context = pdfCanvas.getContext('2d');
                context.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                if (textLayer) textLayer.innerHTML = '';
                if (deletionLayer) deletionLayer.innerHTML = '';
                
                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                
                // Create render task
                const renderTask = page.render({
                    canvasContext: context,
                    viewport: viewport
                });
                currentPageRenderTask = renderTask;
                
                await renderTask.promise;
                currentPageRenderTask = null;
                
                // Extract and render text layer
                const textContent = await page.getTextContent();
                renderTextLayer(textContent, viewport, pageNumber);
                
                // Update page number
                if (pageNum) pageNum.textContent = pageNumber;
                
                // Clean up page object (help with memory)
                if (page.cleanup) {
                    page.cleanup();
                }
                
                // Initialize deletion layer
                if (deletionLayer) {
                    deletionLayer.style.width = viewport.width + 'px';
                    deletionLayer.style.height = viewport.height + 'px';
                }
                
                window.pdfEditorVars.currentPage = pageNumber;
                if (pageNum) pageNum.textContent = pageNumber;
                
                if (zoomLevel) {
                    zoomLevel.textContent = Math.round(window.pdfEditorVars.scale * 100) + '%';
                }
                
            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }
        
        // Render text layer (with page tracking for multi-page editing)
        // Render text layer - NO HTML overlays, only invisible click zones for native editing
        function renderTextLayer(textContent, viewport, pageNumber = 1) {
            if (!textLayer) return;
            
            // Clear text layer - NO HTML overlays
            textLayer.innerHTML = '';
            textLayer.style.width = viewport.width + 'px';
            textLayer.style.height = viewport.height + 'px';
            
            // Create invisible click zones for native editing (NO visual HTML overlays)
            textContent.items.forEach((item, index) => {
                if (item.str && item.str.trim()) {
                    const words = item.str.split(/(\s+)/);
                    let currentX = item.transform[4];
                    const baseY = viewport.height - item.transform[5];
                    const fontSize = Math.abs(item.transform[0]) || 12;
                    const fontFamily = item.fontName || 'Arial';
                    
                    words.forEach((word, wordIndex) => {
                        if (word.trim()) {
                            // Invisible click zone (NO visual HTML overlay)
                            const clickZone = document.createElement('div');
                            clickZone.style.position = 'absolute';
                            clickZone.style.left = currentX + 'px';
                            clickZone.style.top = (baseY - fontSize) + 'px';
                            clickZone.style.width = (word.length * fontSize * 0.6) + 'px';
                            clickZone.style.height = fontSize + 'px';
                            clickZone.style.pointerEvents = 'auto';
                            clickZone.style.cursor = 'text';
                            clickZone.style.opacity = '0'; // Completely invisible
                            clickZone.dataset.text = word;
                            clickZone.dataset.page = pageNumber;
                            clickZone.title = 'Click to edit (Native PDF editing)';
                            
                            // Visual text selection (HIGH PRIORITY)
                            let isSelecting = false;
                            let selectionStart = null;
                            
                            // Mouse down - start selection
                            clickZone.addEventListener('mousedown', function(e) {
                                if (window.pdfEditorVars.activeTool === 'select') {
                                    e.stopPropagation();
                                    isSelecting = true;
                                    selectionStart = { x: currentX, y: baseY, word: word };
                                    clickZone.style.backgroundColor = 'rgba(0, 120, 212, 0.3)';
                                }
                            });
                            
                            // Mouse up - end selection
                            clickZone.addEventListener('mouseup', function(e) {
                                if (isSelecting && window.pdfEditorVars.activeTool === 'select') {
                                    e.stopPropagation();
                                    isSelecting = false;
                                    // Show text selection menu
                                    showTextSelectionMenu(currentX, baseY, word, pageNumber - 1);
                                }
                            });
                            
                            // Click - edit text (if not selecting)
                            clickZone.addEventListener('click', function(e) {
                                if (window.pdfEditorVars.activeTool !== 'select') {
                                    e.stopPropagation();
                                    // Use multi-line text editing dialog
                                    textEditPosition = { x: currentX, y: baseY };
                                    createTextEditDialog(e.clientX, e.clientY);
                                    // Pre-fill with current text
                                    if (textEditTextarea) {
                                        textEditTextarea.value = word;
                                    }
                                }
                            });
                            
                            // Hover effect for visual feedback
                            clickZone.addEventListener('mouseenter', function() {
                                if (window.pdfEditorVars.activeTool === 'select') {
                                    clickZone.style.backgroundColor = 'rgba(0, 120, 212, 0.2)';
                                    clickZone.style.cursor = 'text';
                                } else {
                                    clickZone.style.cursor = 'pointer';
                                }
                            });
                            
                            clickZone.addEventListener('mouseleave', function() {
                                if (!isSelecting) {
                                    clickZone.style.backgroundColor = 'transparent';
                                }
                            });
                            
                            textLayer.appendChild(clickZone);
                            currentX += word.length * (fontSize * 0.6);
                        } else if (word) {
                            currentX += fontSize * 0.3;
                        }
                    });
                }
            });
        }
        
        // Apply OCR texts to PDF natively
        async function applyOCRTextsToPDF() {
            try {
                if (!window.pdfEditorVars.ocrTextsForPDF || window.pdfEditorVars.ocrTextsForPDF.length === 0) {
                    return;
                }
                
                const currentPdfData = window.pdfEditorVars.currentPdfData;
                if (!currentPdfData) {
                    throw new Error('No PDF loaded');
                }
                
                let apiUrl = '/api/pdf/edit';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit';
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: currentPdfData,
                        edits: {
                            ocrTexts: window.pdfEditorVars.ocrTextsForPDF
                        }
                    })
                });
                
                if (response.success) {
                    const result = response;
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    window.pdfEditorVars.ocrTextsForPDF = []; // Clear after embedding
                } else {
                    throw new Error(result.error || 'Failed to embed OCR text');
                }
            } catch (error) {
                console.error('Error applying OCR texts:', error);
                showError('Failed to embed OCR text: ' + error.message);
            }
        }
        
        // Apply native text edit using pdf-lib backend (NO HTML overlays - direct PDF editing)
        // Sends text edits to /api/pdf/edit-text endpoint for actual PDF modification
        async function applyNativeTextEdit(editData) {
            try {
                const { pageIndex, oldText, newText, x, y, fontSize, fontName, fontColor } = editData;
                
                // Get file ID for backend editing
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                
                if (!fileId) {
                    showError('No file ID available. Please upload PDF first.');
                    return false;
                }
                
                showLoading('Applying text edit to PDF using pdf-lib...', 30);
                
                updateProgress(50, 'Sending edit to server...');
                
                // Determine if this is a replacement or new text
                const isReplacement = oldText && newText && oldText !== newText;
                
                // Prepare request body for /api/pdf/edit-text endpoint
                const requestBody = {
                    fileId: fileId
                };
                
                if (isReplacement) {
                    // Text replacement: send as textReplacements
                    requestBody.textReplacements = [{
                        pageIndex: pageIndex || 0,
                        oldText: oldText,
                        newText: newText,
                        x: x || 0,
                        y: y || 0,
                        fontSize: fontSize || 12,
                        fontName: fontName || 'Helvetica',
                        fontColor: fontColor || [0, 0, 0]
                    }];
                } else {
                    // New text: send as textEdits
                    requestBody.textEdits = [{
                        pageIndex: pageIndex || 0,
                        x: x || 0,
                        y: y || 0,
                        text: newText || '',
                        fontSize: fontSize || 12,
                        fontName: fontName || 'Helvetica',
                        fontColor: fontColor || [0, 0, 0]
                    }];
                }
                
                // Send text edits to /api/pdf/edit-text endpoint for actual PDF modification
                const apiBaseUrl = getApiBaseUrl();
                const apiUrl = `${apiBaseUrl}/api/pdf/edit-text`;
                
                updateProgress(60, 'Sending edit to server...');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Server error: ' + response.status);
                }
                
                updateProgress(70, 'Processing edit with pdf-lib...');
                const result = await response.json();
                
                // Wait for backend confirmation before updating the UI
                if (result.success) {
                    updateProgress(90, 'Reloading PDF...');
                    // Update PDF data and reload (native changes from pdf-lib)
                    // CRITICAL: Only update UI after successful backend edit
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    updateProgress(100, 'Edit applied successfully!');
                    setTimeout(() => {
                        hideLoading();
                    }, 300);
                    return true;
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Native text edit error:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error applying text edit: ' + error.message);
                return false;
            }
        }
        
        /* Overlay functions removed - using native PDF editing only */
        
        // Delete text element - Native PDF editing using pdf-lib (NO HTML overlay)
        async function deleteTextElement(element) {
            if (!element) return;
            
            const x = parseFloat(element.style.left) || 0;
            const y = parseFloat(element.style.top) || 0;
            const fontSize = parseFloat(element.style.fontSize) || 12;
            const textWidth = element.offsetWidth || Math.max(element.textContent.length * fontSize * 0.6, 20);
            const textHeight = Math.max(fontSize * 1.2, fontSize);
            
            // Get file ID for backend editing
            const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
            
            if (!fileId) {
                showError('No file ID available. Please upload PDF first.');
                return;
            }
            
            // Apply deletion directly to PDF using pdf-lib (native editing)
            try {
                showLoading('Deleting text from PDF...', 10);
                
                const apiBaseUrl = getApiBaseUrl();
                const apiUrl = `${apiBaseUrl}/api/pdf/edit-text`;
                
                updateProgress(30, 'Sending deletion to server...');
                
                const deleteResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileId: fileId,
                        deletions: [{
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: x,
                            y: y,
                            width: Math.max(textWidth + 4, 20),
                            height: Math.max(textHeight + 2, fontSize)
                        }]
                    })
                });
                
                if (!deleteResponse.ok) {
                    const errorData = await deleteResponse.json().catch(() => ({}));
                    throw new Error(errorData.error || `Deletion failed: ${deleteResponse.status}`);
                }
                
                updateProgress(70, 'Processing deletion with pdf-lib...');
                const deleteResult = await deleteResponse.json();
                
                // Wait for backend confirmation before updating UI
                if (deleteResult.success) {
                    updateProgress(90, 'Reloading PDF...');
                    // Update PDF data and reload (native changes from pdf-lib)
                    // CRITICAL: Only update UI after successful backend edit
                    window.pdfEditorVars.currentPdfData = deleteResult.pdfData;
                    
                    // Update stored file in sessionStorage
                    const pdfBase64 = deleteResult.pdfData.split(',')[1] || deleteResult.pdfData;
                    const pdfBytes = Uint8Array.from(atob(pdfBase64), c => c.charCodeAt(0));
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const newUrl = URL.createObjectURL(blob);
                    sessionStorage.setItem('pdfFileURL', newUrl);
                    
                    await reloadPDF();
                    
                    updateProgress(100, 'Text deleted successfully!');
                    setTimeout(() => {
                        hideLoading();
                    }, 300);
                } else {
                    throw new Error(deleteResult.error || 'Deletion failed');
                }
            } catch (error) {
                console.error('Error deleting text:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error deleting text: ' + error.message);
            }
            
            // Remove element from view
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            
            if (window.pdfEditorVars.selectedTextElement === element) {
                window.pdfEditorVars.selectedTextElement = null;
            }
        }
        
        // Fast Server-Side OCR
        if (ocrBtn) {
            ocrBtn.addEventListener('click', async function() {
                console.log('OCR button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Starting OCR...', 5);
                    updateProgress(10, 'Rendering page to image...');
                    
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    updateProgress(30, 'Converting to image...');
                    const imageData = canvas.toDataURL('image/png');
                    
                    updateProgress(40, 'Sending to OCR service...');
                    
                    let result = null;
                    let useClientSideOCR = false;
                    
                    // Try server-side OCR first (using new backend API)
                    try {
                        updateProgress(50, 'Processing with server OCR...');
                        
                        // Convert PDF page to base64 for OCR
                        const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage).getPageInfo().data)));
                        
                        result = await callBackendAPI('/api/pdf/ocr', {
                            method: 'POST',
                            body: JSON.stringify({
                                pdfData: window.pdfEditorVars.currentPdfData,
                                pageIndex: window.pdfEditorVars.currentPage - 1
                            })
                        });
                        
                        if (result.success) {
                            updateProgress(80, 'Receiving OCR results...');
                            // Transform result to match expected format
                            result = {
                                success: true,
                                text: result.text,
                                words: result.words || [],
                                method: result.method || 'Advanced OCR Service'
                            };
                            updateProgress(95, 'Processing results...');
                            console.log('Server-side OCR successful');
                        } else {
                            throw new Error(result.error || 'OCR failed');
                        }
                    } catch (fetchError) {
                        // Network error or server not available, use client-side OCR
                        console.warn('Server OCR unavailable, using client-side OCR fallback:', fetchError.message);
                        useClientSideOCR = true;
                    }
                    
                    // Fallback to client-side OCR
                    if (useClientSideOCR || !result) {
                        if (typeof window.ClientOCR === 'undefined') {
                            hideLoading();
                            alert('OCR service unavailable. Please ensure you have an internet connection or start the server.');
                            return;
                        }
                        
                        updateProgress(50, 'Using client-side OCR...');
                        console.log('Starting client-side OCR...');
                        try {
                            const { data } = await window.ClientOCR.recognize(imageData, 'eng', {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        const progress = 50 + (m.progress * 40); // 50-90%
                                        updateProgress(progress, `OCR progress: ${Math.round(m.progress * 100)}%`);
                                        console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                                    }
                                }
                            });
                            updateProgress(95, 'Processing OCR results...');
                            
                            result = {
                                success: true,
                                text: data.text,
                                words: data.words.map(word => ({
                                    text: word.text,
                                    boundingBox: {
                                        x: word.bbox.x0,
                                        y: word.bbox.y0,
                                        width: word.bbox.x1 - word.bbox.x0,
                                        height: word.bbox.y1 - word.bbox.y0
                                    },
                                    confidence: word.confidence
                                })),
                                confidence: data.confidence,
                                method: 'client-side'
                            };
                        } catch (ocrError) {
                            console.error('Client-side OCR error:', ocrError);
                            hideLoading();
                            alert('OCR processing failed. Please try again or check your internet connection.');
                            return;
                        }
                    }
                    
                    if (result && result.success && result.words) {
                        // Process OCR results
                        const currentViewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                        const scaleX = pdfCanvas.width / (viewport.width);
                        const scaleY = pdfCanvas.height / (viewport.height);
                        
                        result.words.forEach((word) => {
                            if (word.text && word.boundingBox) {
                                // OCR text is stored for native PDF embedding - NO HTML overlays
                                // Text will be embedded directly into PDF structure
                                
                                // Store for PDF embedding
                                if (!window.pdfEditorVars.ocrTextsForPDF) {
                                    window.pdfEditorVars.ocrTextsForPDF = [];
                                }
                                window.pdfEditorVars.ocrTextsForPDF.push({
                                    pageIndex: window.pdfEditorVars.currentPage - 1,
                                    text: word.text,
                                    x: word.boundingBox.x * scaleX,
                                    y: word.boundingBox.y * scaleY,
                                    fontSize: 12,
                                    fontColor: [0, 0, 0],
                                    fontName: 'Helvetica'
                                });
                            }
                        });
                        
                        alert('OCR completed! Extracted ' + result.words.length + ' words.');
                    } else {
                        alert('OCR completed but no text found.');
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('OCR error:', error);
                    hideLoading();
                    alert('Error performing OCR: ' + error.message);
                }
            });
        }
        
        // Fast Server-Side OCR (Alternative fast processing)
        if (ocrServerBtn) {
            ocrServerBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) return;
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Use fast server-side processing
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    const imageData = canvas.toDataURL('image/png');
                    
                    // Fast server OCR endpoint
                    let apiUrl = '/api/pdf-ocr/process-fast';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf-ocr/process-fast';
                    }
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: imageData.split(',')[1],
                            language: 'en',
                            fast: true
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Determine which service was actually used
                        let serviceName = 'Fast Server OCR';
                        if (result.method) {
                            if (result.method.includes('server') || result.method.includes('advanced')) {
                                serviceName = 'Server OCR (Fast)';
                            } else if (result.method === 'client-side' || result.method.includes('client')) {
                                serviceName = 'Client-side OCR';
                            } else {
                                serviceName = result.method || 'OCR';
                            }
                        }
                        
                        alert('Fast OCR completed! ' + (result.words ? result.words.length : 0) + ' words extracted.');
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Fast OCR error:', error);
                    hideLoading();
                    alert('Error performing fast OCR: ' + error.message);
                }
            });
        }
        
        // Download with server processing - Returns edited PDF
        if (downloadBtn) {
            downloadBtn.addEventListener('click', async function() {
                console.log('Download button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Preparing download...', 10);
                    
                    // Get file ID from sessionStorage
                    const fileId = sessionStorage.getItem('pdfFileId') || window.pdfEditorVars.currentFileId;
                    
                    if (fileId) {
                        // Use fileId-based download endpoint (returns edited PDF)
                        updateProgress(30, 'Fetching edited PDF from server...');
                        
                        const apiBaseUrl = getApiBaseUrl();
                        const downloadUrl = `${apiBaseUrl}/api/pdf/download/${fileId}`;
                        
                        const response = await fetch(downloadUrl);
                        
                        if (!response.ok) {
                            throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                        }
                        
                        updateProgress(70, 'Receiving PDF data...');
                        
                        // Get PDF as blob
                        const pdfBlob = await response.blob();
                        
                        updateProgress(90, 'Preparing download...');
                        
                        // Create download link
                        const url = URL.createObjectURL(pdfBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        
                        // Get filename from response headers or use default
                        const contentDisposition = response.headers.get('Content-Disposition');
                        let filename = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        if (contentDisposition) {
                            const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                            if (filenameMatch) {
                                filename = filenameMatch[1];
                            }
                        }
                        
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully:', filename);
                        }, 500);
                    } else {
                        // Fallback: Use direct PDF data if no fileId
                        updateProgress(20, 'Collecting PDF data...');
                        
                        // Get current PDF data (should already have edits applied)
                        if (!window.pdfEditorVars.currentPdfData) {
                            throw new Error('PDF data not available');
                        }
                        
                        updateProgress(50, 'Processing PDF...');
                        
                        // Extract base64 from data URL
                        let pdfBase64 = window.pdfEditorVars.currentPdfData;
                        if (pdfBase64.startsWith('data:application/pdf;base64,')) {
                            pdfBase64 = pdfBase64.split(',')[1];
                        }
                        
                        updateProgress(80, 'Preparing download...');
                        
                        // Convert to blob and download
                        const pdfBytes = Uint8Array.from(atob(pdfBase64), c => c.charCodeAt(0));
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully');
                        }, 500);
                    }
                } catch (error) {
                    console.error('Download error:', error);
                    hideLoading();
                    alert('Error downloading PDF: ' + error.message);
                }
            });
        }
        
        // Save to Cloud
        if (saveCloudBtn) {
            saveCloudBtn.addEventListener('click', async function() {
                alert('Cloud save feature - Coming soon! This will save your PDF to Google Drive/Dropbox.');
            });
        }
        
        // Page navigation
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage > 1) {
                    window.pdfEditorVars.currentPage--;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage < window.pdfEditorVars.totalPages) {
                    window.pdfEditorVars.currentPage++;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        function updatePageButtons() {
            if (prevPageBtn) prevPageBtn.disabled = window.pdfEditorVars.currentPage <= 1;
            if (nextPageBtn) nextPageBtn.disabled = window.pdfEditorVars.currentPage >= window.pdfEditorVars.totalPages;
        }
        
        // Delete text button
        if (deleteTextBtn) {
            deleteTextBtn.addEventListener('click', function() {
                if (window.pdfEditorVars.selectedTextElement) {
                    deleteTextElement(window.pdfEditorVars.selectedTextElement);
                } else {
                    alert('Please select a text element to delete.');
                }
            });
        }
        
        // Add Text button
        if (addTextBtn) {
            addTextBtn.addEventListener('click', function() {
                console.log('Add Text button clicked');
                window.pdfEditorVars.activeTool = 'text';
                if (addTextBtn) addTextBtn.classList.add('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                // Add text on canvas click
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                    pdfCanvas.addEventListener('click', addTextOnCanvas, { once: true });
                }
            });
        }
        
        // Add Image button
        if (addImageBtn) {
            addImageBtn.addEventListener('click', function() {
                console.log('Add Image button clicked');
                window.pdfEditorVars.activeTool = 'image';
                if (addImageBtn) addImageBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (imageInput) {
                    imageInput.click();
                }
            });
        }
        
        // Highlight button
        if (highlightBtn) {
            highlightBtn.addEventListener('click', function() {
                console.log('Highlight button clicked');
                window.pdfEditorVars.activeTool = 'highlight';
                if (highlightBtn) highlightBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
            });
        }
        
        // Select tool
        if (selectTool) {
            selectTool.addEventListener('click', function() {
                console.log('Select tool clicked');
                window.pdfEditorVars.activeTool = 'select';
                if (selectTool) selectTool.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                }
            });
        }
        
        // Native PDF Text Editing - No HTML Overlays!
        // Edits are applied directly to PDF and re-rendered
        // Multi-line text editing (HIGH PRIORITY)
        let textEditDialog = null;
        let textEditTextarea = null;
        let textEditPosition = null;
        
        // Create multi-line text editing dialog
        function createTextEditDialog(x, y) {
            // Remove existing dialog if any
            if (textEditDialog) {
                textEditDialog.remove();
            }
            
            // Create dialog
            textEditDialog = document.createElement('div');
            textEditDialog.className = 'text-edit-dialog';
            textEditDialog.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                background: #2d2d2d;
                border: 2px solid #0078d4;
                border-radius: 8px;
                padding: 15px;
                z-index: 10000;
                min-width: 300px;
                max-width: 500px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            // Create textarea for multi-line input
            textEditTextarea = document.createElement('textarea');
            textEditTextarea.className = 'text-edit-textarea';
            textEditTextarea.style.cssText = `
                width: 100%;
                min-height: 100px;
                max-height: 300px;
                padding: 10px;
                background: #1e1e1e;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                color: #e5e5e5;
                font-size: 14px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                resize: vertical;
                outline: none;
            `;
            textEditTextarea.placeholder = 'Enter text (supports multiple lines)...\nPress Ctrl+Enter to save, Esc to cancel';
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 10px;
                margin-top: 10px;
                justify-content: flex-end;
            `;
            
            // Save button
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.cssText = `
                padding: 8px 16px;
                background: #0078d4;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: 600;
            `;
            saveBtn.onclick = () => saveTextEdit();
            
            // Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                padding: 8px 16px;
                background: #3a3a3a;
                color: #e5e5e5;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            `;
            cancelBtn.onclick = () => cancelTextEdit();
            
            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(saveBtn);
            
            textEditDialog.appendChild(textEditTextarea);
            textEditDialog.appendChild(buttonContainer);
            
            // Append to preview container
            const previewContainer = document.getElementById('preview-container');
            if (previewContainer) {
                previewContainer.appendChild(textEditDialog);
                textEditTextarea.focus();
            }
            
            // Keyboard shortcuts
            textEditTextarea.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    saveTextEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextEdit();
                }
            });
        }
        
        // Save multi-line text edit
        async function saveTextEdit() {
            if (!textEditTextarea || !textEditPosition) return;
            
            const text = textEditTextarea.value.trim();
            if (!text) {
                cancelTextEdit();
                return;
            }
            
            // Split text into lines for multi-line support
            const lines = text.split('\n');
            const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
            
            if (!fileId) {
                alert('No file ID available. Please upload PDF first.');
                cancelTextEdit();
                return;
            }
            
            try {
                showLoading('Adding text to PDF...', 30);
                
                // Get font properties
                const fontSize = parseInt(fontSizeInput?.value || 12);
                const fontName = fontFamilySelect?.value || 'Helvetica';
                const fontColor = textColorInput?.value || '#000000';
                
                // Convert hex color to RGB
                const rgbColor = hexToRgb(fontColor);
                
                // Calculate line height
                const lineHeight = fontSize * 1.2;
                const startY = textEditPosition.y;
                
                // Prepare text edits for each line
                const textEdits = lines.map((line, index) => ({
                    pageIndex: window.pdfEditorVars.currentPage - 1,
                    x: textEditPosition.x,
                    y: startY - (index * lineHeight), // Stack lines vertically
                    text: line,
                    fontSize: fontSize,
                    fontName: fontName,
                    fontColor: [rgbColor.r, rgbColor.g, rgbColor.b]
                }));
                
                // Send to backend
                const apiBaseUrl = getApiBaseUrl();
                const response = await fetch(`${apiBaseUrl}/api/pdf/edit-text`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileId: fileId,
                        textEdits: textEdits
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to add text: ' + response.status);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    hideLoading();
                } else {
                    throw new Error(result.error || 'Failed to add text');
                }
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                alert('Error adding text: ' + error.message);
            }
            
            cancelTextEdit();
        }
        
        // Cancel text edit
        function cancelTextEdit() {
            if (textEditDialog) {
                textEditDialog.remove();
                textEditDialog = null;
                textEditTextarea = null;
                textEditPosition = null;
            }
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        async function addTextOnCanvas(e) {
            if (window.pdfEditorVars.activeTool !== 'text') return;
            
            const rect = pdfCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Use multi-line text editing dialog instead of prompt
            textEditPosition = { x, y };
            createTextEditDialog(e.clientX, e.clientY);
            return;
            
            // OLD CODE (replaced with multi-line dialog above):
            // const text = prompt('Enter text:');
            // if (!text) return;
            
            const fontSize = fontSizeInput ? parseInt(fontSizeInput.value) || 12 : 12;
            const fontFamily = fontFamilySelect ? fontFamilySelect.value || 'Helvetica' : 'Helvetica';
            const textColor = textColorInput ? textColorInput.value || '#000000' : '#000000';
            
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255
                ] : [0, 0, 0];
            };
            
            try {
                showLoading('Adding text to PDF...', 10);
                
                // Get current PDF
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(30, 'Loading PDF...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                // Get file ID for backend editing
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                
                if (!fileId) {
                    showError('No file ID available. Please upload PDF first.');
                    return;
                }
                
                // Apply edit directly to PDF using pdf-lib backend
                updateProgress(50, 'Applying text to PDF with pdf-lib...');
                const apiBaseUrl = getApiBaseUrl();
                const apiUrl = `${apiBaseUrl}/api/pdf/edit-text`;
                
                // Convert hex color to RGB array
                const fontColorRgb = hexToRgb(textColor);
                
                const editResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileId: fileId,
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: x,
                            y: y,
                            text: text,
                            fontSize: fontSize,
                            fontName: fontFamily,
                            fontColor: hexToRgb(textColor)
                        }]
                    })
                });
                
                updateProgress(80, 'Processing with backend...');
                
                if (!editResponse.ok) {
                    const errorData = await editResponse.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Server error: ' + editResponse.status);
                }
                
                const result = await editResponse.json();
                
                // Wait for backend confirmation before updating UI
                if (result.success) {
                    updateProgress(90, 'Reloading PDF...');
                    // Update PDF data and reload (native changes from pdf-lib)
                    // CRITICAL: Only update UI after successful backend edit
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                    
                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                    const newUrl = URL.createObjectURL(blob);
                    sessionStorage.setItem('pdfFileURL', newUrl);
                    
                    await reloadPDF();
                    
                    updateProgress(100, 'Text added successfully!');
                    setTimeout(() => {
                        hideLoading();
                    }, 300);
                } else {
                    throw new Error(result.error || 'Failed to add text');
                }
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error adding text: ' + error.message);
            }
            
            // Reset tool
            window.pdfEditorVars.activeTool = 'select';
            if (pdfCanvas) pdfCanvas.style.cursor = 'default';
            if (addTextBtn) addTextBtn.classList.remove('active');
            if (selectTool) selectTool.classList.add('active');
        }
        
        // Handle image input
        if (imageInput) {
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Add image to canvas at click position
                        if (window.pdfEditorVars.activeTool === 'image' && pdfCanvas) {
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = (window.pdfEditorVars.lastClickX || 100) - rect.left;
                            const y = (window.pdfEditorVars.lastClickY || 100) - rect.top;
                            
                            const imgElement = document.createElement('img');
                            imgElement.src = e.target.result;
                            imgElement.style.position = 'absolute';
                            imgElement.style.left = x + 'px';
                            imgElement.style.top = y + 'px';
                            imgElement.style.maxWidth = '200px';
                            imgElement.style.maxHeight = '200px';
                            
                            if (textLayer) {
                                textLayer.appendChild(imgElement);
                            }
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Track canvas clicks for image placement
        if (pdfCanvas) {
            pdfCanvas.addEventListener('click', function(e) {
                if (window.pdfEditorVars.activeTool === 'image') {
                    window.pdfEditorVars.lastClickX = e.clientX;
                    window.pdfEditorVars.lastClickY = e.clientY;
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && 
                window.pdfEditorVars.selectedTextElement && 
                !window.pdfEditorVars.selectedTextElement.classList.contains('editing')) {
                e.preventDefault();
                deleteTextElement(window.pdfEditorVars.selectedTextElement);
            }
        });
        
        // ========== NEW FEATURES IMPLEMENTATION ==========
        
        // Page Management - Complete Implementation
        const rotate90Btn = document.getElementById('rotate-90-btn');
        const deleteCurrentPageBtn = document.getElementById('delete-current-page-btn');
        const rotatePageBtn = document.getElementById('rotate-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const reorderPagesBtn = document.getElementById('reorder-pages-btn');
        const extractPageBtn = document.getElementById('extract-page-btn');
        
        // Rotate Current Page 90¬∞
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Rotating page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Rotating page...');
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Page rotated!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Rotation failed');
                        }
                    } else {
                        throw new Error('Rotation request failed');
                    }
                } catch (error) {
                    console.error('Error rotating page:', error);
                    hideLoading();
                    showError('Failed to rotate page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                if (!confirm(`Delete page ${window.pdfEditorVars.currentPage}?`)) {
                    return;
                }
                
                try {
                    showLoading('Deleting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Deleting page...');
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Adjust current page if needed
                            if (window.pdfEditorVars.currentPage > window.pdfEditorVars.totalPages - 1) {
                                window.pdfEditorVars.currentPage = Math.max(1, window.pdfEditorVars.totalPages - 1);
                            }
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Page deleted!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Deletion failed');
                        }
                    } else {
                        throw new Error('Deletion request failed');
                    }
                } catch (error) {
                    console.error('Error deleting page:', error);
                    hideLoading();
                    showError('Failed to delete page: ' + error.message);
                }
            });
        }
        
        // Reorder Pages
        if (reorderPagesBtn) {
            reorderPagesBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                const totalPages = window.pdfEditorVars.totalPages;
                const currentOrder = Array.from({ length: totalPages }, (_, i) => i);
                const newOrderStr = prompt(`Enter new page order (comma-separated, 1-${totalPages}):\nExample: 3,1,2,4`, currentOrder.map(i => i + 1).join(','));
                
                if (!newOrderStr) return;
                
                try {
                    const newOrder = newOrderStr.split(',').map(s => parseInt(s.trim()) - 1).filter(n => !isNaN(n) && n >= 0 && n < totalPages);
                    
                    if (newOrder.length !== totalPages) {
                        throw new Error('Invalid page order');
                    }
                    
                    showLoading('Reordering pages...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Reordering pages...');
                    let apiUrl = '/api/pdf/pages/reorder';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/reorder';
                    }
                    
                    const reorderResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            newOrder: newOrder
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (reorderResponse.ok) {
                        const result = await reorderResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Pages reordered!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Reordering failed');
                        }
                    } else {
                        throw new Error('Reordering request failed');
                    }
                } catch (error) {
                    console.error('Error reordering pages:', error);
                    hideLoading();
                    showError('Failed to reorder pages: ' + error.message);
                }
            });
        }
        
        // Extract Page
        if (extractPageBtn) {
            extractPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                const pageNum = window.pdfEditorVars.currentPage;
                if (!confirm(`Extract page ${pageNum} as a new PDF?`)) {
                    return;
                }
                
                try {
                    showLoading('Extracting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Extracting page...');
                    let apiUrl = '/api/pdf/pages/extract';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/extract';
                    }
                    
                    const extractResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    updateProgress(80, 'Preparing download...');
                    
                    if (extractResponse.ok) {
                        const result = await extractResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Downloading...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `page-${pageNum}.pdf`;
                            a.click();
                            URL.revokeObjectURL(url);
                            
                            updateProgress(100, 'Page extracted!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Extraction failed');
                        }
                    } else {
                        throw new Error('Extraction request failed');
                    }
                } catch (error) {
                    console.error('Error extracting page:', error);
                    hideLoading();
                    showError('Failed to extract page: ' + error.message);
                }
            });
        }
        
        // Forms - Complete Implementation
        const fillFormBtn = document.getElementById('fill-form-btn');
        const detectFormBtn = document.getElementById('detect-form-btn');
        
        // Detect Form Fields
        if (detectFormBtn) {
            detectFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (detectResponse.ok) {
                        const result = await detectResponse.json();
                        if (result.success && result.formFields) {
                            updateProgress(100, 'Form fields detected!');
                            setTimeout(() => hideLoading(), 300);
                            
                            const fieldsList = result.formFields.map(f => 
                                `- ${f.name} (${f.type}): ${f.value || '(empty)'}`
                            ).join('\n');
                            
                            alert(`Found ${result.formFields.length} form field(s):\n\n${fieldsList}`);
                        } else {
                            alert('No form fields found in this PDF.');
                            hideLoading();
                        }
                    } else {
                        throw new Error('Form detection failed');
                    }
                } catch (error) {
                    console.error('Error detecting form fields:', error);
                    hideLoading();
                    showError('Failed to detect form fields: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    showError('No PDF loaded');
                    return;
                }
                
                try {
                    // First detect form fields
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(20, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(40, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    if (!detectResponse.ok) {
                        throw new Error('Form detection failed');
                    }
                    
                    const detectResult = await detectResponse.json();
                    if (!detectResult.success || !detectResult.formFields || detectResult.formFields.length === 0) {
                        alert('No form fields found in this PDF.');
                        hideLoading();
                        return;
                    }
                    
                    // Collect form field values from user
                    const formFields = [];
                    for (const field of detectResult.formFields) {
                        let value = prompt(`Enter value for "${field.name}" (${field.type}):`, field.value || '');
                        if (value !== null) {
                            formFields.push({
                                fieldName: field.name,
                                value: value
                            });
                        }
                    }
                    
                    if (formFields.length === 0) {
                        hideLoading();
                        return;
                    }
                    
                    updateProgress(60, 'Filling form fields...');
                    apiUrl = '/api/pdf/forms/fill';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/fill';
                    }
                    
                    const fillResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            formFields: formFields
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (fillResponse.ok) {
                        const result = await fillResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Form filled!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Form filling failed');
                        }
                    } else {
                        throw new Error('Form filling request failed');
                    }
                } catch (error) {
                    console.error('Error filling form:', error);
                    hideLoading();
                    showError('Failed to fill form: ' + error.message);
                }
            });
        }
        
        // Annotations - Complete Implementation
        const commentBtn = document.getElementById('comment-btn');
        const stampBtn = document.getElementById('stamp-btn');
        const shapeBtn = document.getElementById('shape-btn');
        
        // Comment Button
        if (commentBtn) {
            commentBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'comment';
                if (commentBtn) commentBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (stampBtn) stampBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Add click handler for comment placement
                pdfCanvas.addEventListener('click', async function addCommentHandler(e) {
                    if (window.pdfEditorVars.activeTool === 'comment') {
                        pdfCanvas.removeEventListener('click', addCommentHandler);
                        const rect = pdfCanvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const commentText = prompt('Enter your comment:');
                        if (commentText) {
                            const comment = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: commentText,
                                author: 'User'
                            };
                            
                            // Apply comment directly to PDF (native editing - NO HTML overlay)
                            try {
                                showLoading('Adding comment to PDF...', 10);
                                
                                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                if (!pdfFileURL) throw new Error('PDF file not found');
                                
                                updateProgress(30, 'Loading PDF...');
                                const response = await fetch(pdfFileURL);
                                const pdfArrayBuffer = await response.arrayBuffer();
                                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                
                                updateProgress(50, 'Applying comment...');
                                let apiUrl = '/api/pdf/edit-native';
                                if (window.location.protocol === 'file:') {
                                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                                }
                                
                                const commentResponse = await fetch(apiUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        edit: {
                                            type: 'comment',
                                            data: comment
                                        }
                                    })
                                });
                                
                                updateProgress(80, 'Updating PDF...');
                                
                                if (commentResponse.ok) {
                                    const result = await commentResponse.json();
                                    if (result.success) {
                                        updateProgress(90, 'Rendering...');
                                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                        
                                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                                        const newUrl = URL.createObjectURL(blob);
                                        sessionStorage.setItem('pdfFileURL', newUrl);
                                        
                                        await renderPDF(pdfData);
                                        
                                        updateProgress(100, 'Comment added!');
                                        setTimeout(() => hideLoading(), 300);
                                        
                                        // Store in annotations
                                        window.pdfEditorVars.annotations.comments.push(comment);
                                    }
                                }
                            } catch (error) {
                                console.error('Error adding comment:', error);
                                hideLoading();
                            }
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (commentBtn) commentBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }
                }, { once: true });
            });
        }
        
        // Stamp Button
        if (stampBtn) {
            stampBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'stamp';
                if (stampBtn) stampBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (commentBtn) commentBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Show stamp type selection
                const stampType = prompt('Enter stamp type (APPROVED, REJECTED, CONFIDENTIAL, DRAFT, or custom):', 'APPROVED');
                if (stampType) {
                    pdfCanvas.addEventListener('click', function addStampHandler(e) {
                        if (window.pdfEditorVars.activeTool === 'stamp') {
                            pdfCanvas.removeEventListener('click', addStampHandler);
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const stamp = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                stampType: stampType,
                                width: 100,
                                height: 50
                            };
                            
                            window.pdfEditorVars.annotations.stamps.push(stamp);
                            
                            // Store in sessionStorage
                            const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                            if (!storedEdits.stamps) storedEdits.stamps = [];
                            storedEdits.stamps.push(stamp);
                            sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                            
                            // Apply stamp directly to PDF (native editing)
                            (async () => {
                                try {
                                    showLoading('Adding stamp to PDF...', 10);
                                    
                                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                    if (!pdfFileURL) throw new Error('PDF file not found');
                                    
                                    updateProgress(30, 'Loading PDF...');
                                    const response = await fetch(pdfFileURL);
                                    const pdfArrayBuffer = await response.arrayBuffer();
                                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                    
                                    updateProgress(50, 'Applying stamp...');
                                    let apiUrl = '/api/pdf/edit';
                                    if (window.location.protocol === 'file:') {
                                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                                    }
                                    
                                    // Use standard edit endpoint for stamps
                                    const stampResponse = await fetch(apiUrl, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                            edits: {
                                                stamps: [stamp]
                                            }
                                        })
                                    });
                                    
                                    updateProgress(80, 'Updating PDF...');
                                    
                                    if (stampResponse.ok) {
                                        const result = await stampResponse.json();
                                        if (result.success) {
                                            updateProgress(90, 'Rendering...');
                                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                            
                                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                                            const newUrl = URL.createObjectURL(blob);
                                            sessionStorage.setItem('pdfFileURL', newUrl);
                                            
                                            await renderPDF(pdfData);
                                            
                                            updateProgress(100, 'Stamp added!');
                                            setTimeout(() => hideLoading(), 300);
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error adding stamp:', error);
                                    hideLoading();
                                }
                            })();
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (stampBtn) stampBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }, { once: true });
                } else {
                    window.pdfEditorVars.activeTool = 'select';
                    if (stampBtn) stampBtn.classList.remove('active');
                }
            });
        }
        
        // Shape Button
        if (shapeBtn) {
            shapeBtn.addEventListener('click', function() {
                const shapeType = prompt('Enter shape type (rectangle, circle, line):', 'rectangle');
                if (shapeType && ['rectangle', 'circle', 'line'].includes(shapeType.toLowerCase())) {
                    window.pdfEditorVars.activeTool = 'shape';
                    window.pdfEditorVars.shapeType = shapeType.toLowerCase();
                    if (shapeBtn) shapeBtn.classList.add('active');
                    if (highlightBtn) highlightBtn.classList.remove('active');
                    if (commentBtn) commentBtn.classList.remove('active');
                    if (stampBtn) stampBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.remove('active');
                    
                    if (pdfCanvas) {
                        pdfCanvas.style.cursor = 'crosshair';
                    }
                }
            });
        }
        
        // Shape drawing (similar to highlight)
        let shapeStartX = null;
        let shapeStartY = null;
        let shapeRect = null;
        
        if (pdfCanvas) {
            const shapeMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    shapeStartX = e.clientX - rect.left;
                    shapeStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Shape will be added to PDF on mouseup
                }
            };
            
            const shapeMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Shape will be drawn directly in PDF on mouseup
                }
            };
            
            const shapeMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - shapeStartX);
                    const height = Math.abs(currentY - shapeStartY);
                    const left = Math.min(shapeStartX, currentX);
                    const top = Math.min(shapeStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const shape = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            shapeType: window.pdfEditorVars.shapeType,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            color: [0, 0, 0],
                            strokeWidth: 2
                        };
                        
                        // Apply shape directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Adding shape to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying shape...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const shapeResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'shape',
                                        data: shape
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (shapeResponse.ok) {
                                const result = await shapeResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Shape added!');
                                    setTimeout(() => hideLoading(), 300);
                                    
                                    // Store in annotations
                                    window.pdfEditorVars.annotations.shapes.push(shape);
                                }
                            }
                        } catch (error) {
                            console.error('Error adding shape:', error);
                            hideLoading();
                        }
                    }
                    
                    // Reset tool
                    window.pdfEditorVars.activeTool = 'select';
                    if (shapeBtn) shapeBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    shapeStartX = null;
                    shapeStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', shapeMouseDown);
            pdfCanvas.addEventListener('mousemove', shapeMouseMove);
            pdfCanvas.addEventListener('mouseup', shapeMouseUp);
        }
        
        // Export - Complete Implementation
        const exportBtn = document.getElementById('export-btn');
        const exportFormatSelect = document.getElementById('export-format-select');
        const exportWordBtn = document.getElementById('export-word-btn');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const exportPptBtn = document.getElementById('export-ppt-btn');
        const exportImageBtn = document.getElementById('export-image-btn');
        
        // Export Function
        async function exportToFormat(format) {
            if (!window.pdfEditorVars.pdfDoc) {
                alert('No PDF loaded');
                return;
            }
            
            try {
                showLoading(`Exporting to ${format.toUpperCase()}...`, 10);
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(20, 'Loading PDF data...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                let apiUrl = '';
                let mimeType = '';
                let fileExtension = '';
                
                switch(format) {
                    case 'word':
                        apiUrl = '/api/pdf/export/word';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        fileExtension = 'docx';
                        break;
                    case 'excel':
                        apiUrl = '/api/pdf/export/excel';
                        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                        fileExtension = 'xlsx';
                        break;
                    case 'powerpoint':
                        apiUrl = '/api/pdf/export/powerpoint';
                        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
                        fileExtension = 'pptx';
                        break;
                    case 'image':
                        apiUrl = '/api/pdf/export/images';
                        mimeType = 'image/png';
                        fileExtension = 'zip';
                        break;
                    default:
                        throw new Error('Unsupported export format');
                }
                
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000' + apiUrl;
                }
                
                updateProgress(40, `Sending to ${format} converter...`);
                const exportResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                });
                
                updateProgress(70, 'Processing export...');
                
                if (exportResponse.ok) {
                    const result = await exportResponse.json();
                    if (result.success) {
                        updateProgress(90, 'Preparing download...');
                        
                        if (format === 'image' && result.images) {
                            alert('Image export creates multiple files. Downloading first image as example.');
                            if (result.images[0]) {
                                const imgBase64 = Buffer.from(result.images[0].image).toString('base64');
                                const imgBytes = Uint8Array.from(atob(imgBase64), c => c.charCodeAt(0));
                                const blob = new Blob([imgBytes], { type: 'image/png' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `page-1.png`;
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                        } else if (result.fileData) {
                            const fileBase64 = result.fileData.split(',')[1] || result.fileData;
                            const fileBytes = Uint8Array.from(atob(fileBase64), c => c.charCodeAt(0));
                            const blob = new Blob([fileBytes], { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `exported-document.${fileExtension}`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                        
                        updateProgress(100, 'Export complete!');
                        setTimeout(() => {
                            hideLoading();
                            alert(`Successfully exported to ${format.toUpperCase()}!`);
                        }, 500);
                    } else {
                        throw new Error(result.error || 'Export failed');
                    }
                } else {
                    throw new Error('Export server error: ' + exportResponse.status);
                }
            } catch (error) {
                console.error('Export error:', error);
                hideLoading();
                alert(`Error exporting to ${format}: ${error.message}`);
            }
        }
        
        // Export Button Event Listeners
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    // Use download function
                    if (downloadBtn) downloadBtn.click();
                } else {
                    await exportToFormat(format);
                }
            });
        }
        
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compression & Merge/Split
        const compressPdfBtn = document.getElementById('compress-pdf-btn');
        const compressionQuality = document.getElementById('compression-quality');
        const compressBtn = document.getElementById('compress-btn');
        const mergeBtn = document.getElementById('merge-btn');
        const splitBtn = document.getElementById('split-btn');
        
        // Extra Functions - Security & Advanced
        const watermarkBtn = document.getElementById('watermark-btn');
        const signBtn = document.getElementById('sign-btn');
        const redactBtn = document.getElementById('redact-btn');
        const protectBtn = document.getElementById('protect-btn');
        
        // Watermark Implementation
        if (watermarkBtn) {
            watermarkBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const watermarkText = prompt('Enter watermark text:', 'CONFIDENTIAL');
                if (!watermarkText) return;
                
                const opacity = prompt('Enter opacity (0.1 to 1.0):', '0.3');
                const opacityValue = parseFloat(opacity) || 0.3;
                
                try {
                    showLoading('Adding watermark...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Applying watermark to all pages...');
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    const watermarkEdits = {
                        textEdits: []
                    };
                    
                    for (let i = 0; i < window.pdfEditorVars.totalPages; i++) {
                        watermarkEdits.textEdits.push({
                            pageIndex: i,
                            x: 200,
                            y: 400,
                            text: watermarkText,
                            fontSize: 48,
                            fontName: 'Helvetica',
                            fontColor: [0.7, 0.7, 0.7]
                        });
                    }
                    
                    const watermarkResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: watermarkEdits
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (watermarkResponse.ok) {
                        const result = await watermarkResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading watermarked PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Watermark added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Watermark added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Watermark failed');
                    }
                } catch (error) {
                    console.error('Watermark error:', error);
                    hideLoading();
                    alert('Error adding watermark: ' + error.message);
                }
            });
        }
        
        // Sign Implementation
        if (signBtn) {
            signBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const signerName = prompt('Enter signer name:', 'Your Name');
                if (!signerName) return;
                
                try {
                    showLoading('Adding digital signature...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Creating signature...');
                    const signatureEdits = {
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 100,
                            text: `Digitally Signed by: ${signerName}\nDate: ${new Date().toLocaleDateString()}`,
                            fontSize: 12,
                            fontName: 'Helvetica',
                            fontColor: [0, 0, 0]
                        }],
                        stamps: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 50,
                            stampType: 'SIGNED',
                            width: 150,
                            height: 50
                        }]
                    };
                    
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    updateProgress(70, 'Applying signature...');
                    const signResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: signatureEdits
                        })
                    });
                    
                    updateProgress(90, 'Processing...');
                    
                    if (signResponse.ok) {
                        const result = await signResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Signature added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Digital signature added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Signature failed');
                    }
                } catch (error) {
                    console.error('Sign error:', error);
                    hideLoading();
                    alert('Error adding signature: ' + error.message);
                }
            });
        }
        
        // Redact Implementation
        if (redactBtn) {
            redactBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'redact';
                if (redactBtn) redactBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                alert('Redact mode activated. Click and drag to select text to redact (black out).');
            });
        }
        
        // Redact drawing
        let redactStartX = null;
        let redactStartY = null;
        let redactRect = null;
        
        if (pdfCanvas && redactBtn) {
            const redactMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    redactStartX = e.clientX - rect.left;
                    redactStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Redaction will be added to PDF on mouseup
                }
            };
            
            const redactMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Redaction will be drawn directly in PDF on mouseup
                }
            };
            
            const redactMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - redactStartX);
                    const height = Math.abs(currentY - redactStartY);
                    const left = Math.min(redactStartX, currentX);
                    const top = Math.min(redactStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const redaction = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            type: 'redaction'
                        };
                        
                        // Apply redaction directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Applying redaction to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying redaction...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const redactResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'redaction',
                                        data: redaction
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (redactResponse.ok) {
                                const result = await redactResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Redaction applied!');
                                    setTimeout(() => hideLoading(), 300);
                                }
                            }
                        } catch (error) {
                            console.error('Error applying redaction:', error);
                            hideLoading();
                        }
                    }
                    
                    window.pdfEditorVars.activeTool = 'select';
                    if (redactBtn) redactBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    redactStartX = null;
                    redactStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', redactMouseDown);
            pdfCanvas.addEventListener('mousemove', redactMouseMove);
            pdfCanvas.addEventListener('mouseup', redactMouseUp);
        }
        
        // Compression Implementation
        if (compressBtn) {
            compressBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const quality = prompt('Enter compression quality (low/medium/high):', 'medium');
                if (!quality || !['low', 'medium', 'high'].includes(quality.toLowerCase())) {
                    if (quality) alert('Invalid quality. Use: low, medium, or high');
                    return;
                }
                
                try {
                    showLoading('Compressing PDF...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Compressing...');
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            quality: quality.toLowerCase()
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading compressed PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            sessionStorage.setItem('pdfFileBase64', btoa(String.fromCharCode(...new Uint8Array(pdfData))));
                            
                            await renderPDF(pdfData);
                            updateProgress(100, 'PDF compressed!');
                            setTimeout(() => {
                                hideLoading();
                                alert(`PDF compressed successfully!\nOriginal: ${(result.originalSize / 1024).toFixed(2)} KB\nCompressed: ${(result.compressedSize / 1024).toFixed(2)} KB\nReduction: ${result.compressionRatio}%`);
                            }, 500);
                        }
                    } else {
                        throw new Error('Compression failed');
                    }
                } catch (error) {
                    console.error('Compression error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Protect PDF Implementation
        if (protectBtn) {
            protectBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const password = prompt('Enter password to protect PDF:', '');
                if (!password || password.length < 4) {
                    if (password) alert('Password must be at least 4 characters');
                    return;
                }
                
                const confirmPassword = prompt('Confirm password:', '');
                if (password !== confirmPassword) {
                    alert('Passwords do not match!');
                    return;
                }
                
                try {
                    showLoading('Protecting PDF...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Encrypting PDF...');
                    let apiUrl = '/api/pdf/protect';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/protect';
                    }
                    
                    const protectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            userPassword: password,
                            ownerPassword: password,
                            permissions: {
                                printing: 'highResolution',
                                modifying: false,
                                copying: false,
                                annotating: false,
                                fillingForms: false,
                                contentAccessibility: false,
                                documentAssembly: false
                            }
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (protectResponse.ok) {
                        const result = await protectResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading protected PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            sessionStorage.setItem('pdfFileBase64', btoa(String.fromCharCode(...new Uint8Array(pdfData))));
                            
                            await renderPDF(pdfData);
                            updateProgress(100, 'PDF protected!');
                            setTimeout(() => {
                                hideLoading();
                                alert('PDF protected successfully! Password required to open.');
                            }, 500);
                        }
                    } else {
                        throw new Error('Protection failed');
                    }
                } catch (error) {
                    console.error('Protection error:', error);
                    hideLoading();
                    alert('Error protecting PDF: ' + error.message);
                }
            });
        }
        
        // Rotate Page 90 degrees
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page rotated successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Rotate error:', error);
                    hideLoading();
                    alert('Error rotating page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                if (!confirm('Are you sure you want to delete this page?')) return;
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page deleted successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Delete page error:', error);
                    hideLoading();
                    alert('Error deleting page: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                // First detect form fields
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const fieldsResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                    });
                    
                    if (fieldsResponse.ok) {
                        const result = await fieldsResponse.json();
                        if (result.success && result.formFields && result.formFields.length > 0) {
                            // Show form fill dialog
                            let formHtml = '<div style="padding: 20px;"><h3>Fill Form Fields</h3>';
                            result.formFields.forEach(field => {
                                formHtml += `<div style="margin: 10px 0;">
                                    <label>${field.name} (${field.type}):</label>
                                    <input type="text" id="field-${field.name}" value="${field.value || ''}" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>`;
                            });
                            formHtml += '<button onclick="fillFormSubmit()" style="margin-top: 15px; padding: 10px 20px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer;">Fill Form</button></div>';
                            
                            const formDialog = document.createElement('div');
                            formDialog.id = 'form-fill-dialog';
                            formDialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;';
                            formDialog.innerHTML = formHtml;
                            document.body.appendChild(formDialog);
                            
                            window.fillFormSubmit = async function() {
                                const formFields = result.formFields.map(field => ({
                                    fieldName: field.name,
                                    value: document.getElementById(`field-${field.name}`).value
                                }));
                                
                                let fillUrl = '/api/pdf/forms/fill';
                                if (window.location.protocol === 'file:') {
                                    fillUrl = 'http://localhost:3000/api/pdf/forms/fill';
                                }
                                
                                const fillResponse = await fetch(fillUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        formFields: formFields
                                    })
                                });
                                
                                if (fillResponse.ok) {
                                    const fillResult = await fillResponse.json();
                                    if (fillResult.success) {
                                        const pdfData = await fetch(fillResult.pdfData).then(r => r.arrayBuffer());
                                        await renderPDF(pdfData);
                                        document.body.removeChild(formDialog);
                                        alert('Form filled successfully!');
                                    }
                                }
                                hideLoading();
                            };
                        } else {
                            alert('No form fields found in this PDF.');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Form fill error:', error);
                    hideLoading();
                    alert('Error filling form: ' + error.message);
                }
            });
        }
        
        // Export to Different Formats - Enhanced with Progress
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    if (downloadBtn) downloadBtn.click();
                    return;
                }
                
                await exportToFormat(format);
            });
        }
        
        // Individual Export Buttons
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compress PDF
        if (compressPdfBtn) {
            compressPdfBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            options: { quality: compressionQuality.value }
                        })
                    });
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert(`PDF compressed! Size reduced by ${result.compressionRatio}%`);
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Compress error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Initialize all button event listeners
        function initButtonEventListeners() {
            console.log('Initializing button event listeners...');
            
            // Re-get all button elements to ensure they exist
            const uploadBtn = document.getElementById('upload-btn');
            const downloadBtn = document.getElementById('download-btn');
            const ocrBtn = document.getElementById('ocr-btn');
            const addTextBtn = document.getElementById('add-text-btn');
            const addImageBtn = document.getElementById('add-image-btn');
            const highlightBtn = document.getElementById('highlight-btn');
            const selectTool = document.getElementById('select-tool');
            const fileInput = document.getElementById('file-input');
            const imageInput = document.getElementById('image-input');
            
            // Upload button - remove any existing listeners first
            if (uploadBtn && fileInput) {
                // Clone and replace to remove all event listeners
                const newUploadBtn = uploadBtn.cloneNode(true);
                uploadBtn.parentNode.replaceChild(newUploadBtn, uploadBtn);
                const newFileInput = fileInput.cloneNode(true);
                fileInput.parentNode.replaceChild(newFileInput, fileInput);
                
                // Get fresh references
                const freshUploadBtn = document.getElementById('upload-btn');
                const freshFileInput = document.getElementById('file-input');
                
                if (freshUploadBtn && freshFileInput) {
                    freshUploadBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Upload button clicked');
                        try {
                            freshFileInput.click();
                        } catch (error) {
                            console.error('Error clicking file input:', error);
                            alert('Error opening file dialog. Please try again.');
                        }
                    });
                    console.log('‚úÖ Upload button listener added');
                } else {
                    console.error('‚ùå Upload button or file input not found after clone!');
                }
            } else {
                console.error('‚ùå Upload button or file input not found!', { uploadBtn, fileInput });
            }
            
            // Download button - already has listener, but verify
            if (downloadBtn) {
                console.log('‚úÖ Download button found');
            } else {
                console.error('‚ùå Download button not found!');
            }
            
            // OCR button - already has listener, but verify
            if (ocrBtn) {
                console.log('‚úÖ OCR button found');
            } else {
                console.error('‚ùå OCR button not found!');
            }
            
            // Add Text button - already has listener, but verify
            if (addTextBtn) {
                console.log('‚úÖ Add Text button found');
            } else {
                console.error('‚ùå Add Text button not found!');
            }
            
            // Add Image button - already has listener, but verify
            if (addImageBtn) {
                console.log('‚úÖ Add Image button found');
            } else {
                console.error('‚ùå Add Image button not found!');
            }
            
            // Highlight button - already has listener, but verify
            if (highlightBtn) {
                console.log('‚úÖ Highlight button found');
            } else {
                console.error('‚ùå Highlight button not found!');
            }
            
            // Select tool - already has listener, but verify
            if (selectTool) {
                console.log('‚úÖ Select tool found');
            } else {
                console.error('‚ùå Select tool not found!');
            }
            
            console.log('Button event listeners initialization complete!');
        }
        
        // Initialize - ensure DOM is ready
        async function initPDFEditor() {
            // Check for PDF from edit-pdf.html on page load
            await checkForStoredPDF();
            
            // Initialize button event listeners
            initButtonEventListeners();
            
            // Try to load PDF from storage
            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
            if (pdfFileURL) {
                fetch(pdfFileURL)
                    .then(r => r.arrayBuffer())
                    .then(data => renderPDF(data))
                    .catch(e => console.warn('Could not load PDF from storage:', e));
            }
            
            // Ensure preview container is visible
            if (previewContainer) {
                previewContainer.style.display = 'flex';
                previewContainer.style.visibility = 'visible';
            }
            if (pdfPageWrapper) {
                pdfPageWrapper.style.display = 'block';
                pdfPageWrapper.style.visibility = 'visible';
            }
        }
        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPDFEditor);
        } else {
            // DOM already loaded
            initPDFEditor();
        }
    </script>
</body>
</html>

