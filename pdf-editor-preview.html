<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Free Online PDF Editor - Edit PDF Files Online | Add Text, Images, OCR | easyjpgtopdf</title>
    <meta name="description" content="Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required - edit PDFs directly in your browser. 5 pages free per day.">
    <meta name="keywords" content="pdf editor, edit pdf online, free pdf editor, pdf editor online, edit pdf files, add text to pdf, pdf editor free, online pdf editor, pdf editor tool, edit pdf text, pdf editor software, pdf editor app, edit pdf online free, pdf editor download, best pdf editor, pdf editor chrome, edit pdf document, pdf editor windows, pdf editor mac, pdf editor android, pdf editor ios, edit pdf pages, pdf editor with ocr, pdf editor hindi, pdf editor english">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="author" content="easyjpgtopdf">
    <meta name="language" content="English, Hindi">
    <meta name="revisit-after" content="7 days">
    <link rel="canonical" href="https://easyjpgtopdf.com/pdf-editor-preview.html">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://easyjpgtopdf.com/pdf-editor-preview.html">
    <meta property="og:title" content="Free Online PDF Editor - Edit PDF Files Online | easyjpgtopdf">
    <meta property="og:description" content="Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required.">
    <meta property="og:image" content="https://easyjpgtopdf.com/images/pdf-editor-og.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://easyjpgtopdf.com/pdf-editor-preview.html">
    <meta property="twitter:title" content="Free Online PDF Editor - Edit PDF Files Online | easyjpgtopdf">
    <meta property="twitter:description" content="Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required.">
    <meta property="twitter:image" content="https://easyjpgtopdf.com/images/pdf-editor-twitter.jpg">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
    <!-- Preload Critical CSS -->
    <link rel="preload" href="css/header.css" as="style">
    <link rel="preload" href="css/footer.css" as="style">
    
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/theme-modern.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PDF Editor API Client (Backend Integration) -->
    <script type="module" src="js/pdf-editor-api.js"></script>
    
    <!-- Professional PDF Editor using backend rendering (NO PDF.js) -->
    
    <!-- Schema Markup for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Free Online PDF Editor",
      "description": "Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required - edit PDFs directly in your browser.",
      "url": "https://easyjpgtopdf.com/pdf-editor-preview.html",
      "applicationCategory": "UtilityApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "1250"
      },
      "featureList": [
        "Edit PDF text online",
        "Add text to PDF",
        "Add images to PDF",
        "Highlight PDF content",
        "OCR text extraction",
        "Export to Word, Excel, PowerPoint",
        "Compress PDF files",
        "Merge and split PDFs",
        "Password protect PDFs",
        "Watermark PDFs"
      ],
      "inLanguage": ["en-US", "hi-IN"],
      "isPartOf": {
        "@type": "WebSite",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com",
        "potentialAction": {
          "@type": "SearchAction",
          "target": "https://easyjpgtopdf.com/search?q={search_term_string}",
          "query-input": "required name=search_term_string"
        }
      },
      "publisher": {
        "@type": "Organization",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com",
        "logo": {
          "@type": "ImageObject",
          "url": "https://easyjpgtopdf.com/images/logo.png"
        }
      }
    }
    </script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "PDF Editor Online",
      "applicationCategory": "UtilityApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD",
        "availability": "https://schema.org/InStock"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "bestRating": "5",
        "worstRating": "1",
        "ratingCount": "1250"
      }
    }
    </script>
    
    <style>
        /* Theme Variables */
        :root {
            --bg-primary: #f5f7ff;
            --bg-secondary: #ffffff;
            --text-primary: #0b1630;
            --text-secondary: #64748b;
            --border-color: #e0e0e0;
            --editor-bg: #2b2b2b;
            --editor-panel-bg: #1e1e1e;
            --editor-text: #e5e5e5;
            --editor-border: #3a3a3a;
            --editor-hover: #2d2d2d;
            --editor-active: #0078d4;
        }
        
        [data-theme="light"] {
            --bg-primary: #f5f7ff;
            --bg-secondary: #ffffff;
            --text-primary: #0b1630;
            --text-secondary: #64748b;
            --border-color: #e0e0e0;
            --editor-bg: #ffffff;
            --editor-panel-bg: #f8f9fa;
            --editor-text: #0b1630;
            --editor-border: #dee2e6;
            --editor-hover: #e9ecef;
            --editor-active: #0078d4;
        }
        
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2b2b2b;
            --text-primary: #e5e5e5;
            --text-secondary: #9ca3af;
            --border-color: #3a3a3a;
            --editor-bg: #2b2b2b;
            --editor-panel-bg: #1e1e1e;
            --editor-text: #e5e5e5;
            --editor-border: #3a3a3a;
            --editor-hover: #2d2d2d;
            --editor-active: #0078d4;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        main {
            flex: 1;
            padding: 30px 0;
        }
        
        .page-
        
        .page-header h1 {
            font-size: 2.2rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Professional Editor Workspace */
        .editor-workspace {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 800px;
            background: var(--editor-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: background-color 0.3s;
        }
        
        /* Left Tools Panel */
        .tools-panel {
            width: 240px;
            min-width: 240px;
            background: var(--editor-panel-bg);
            border-right: 1px solid var(--editor-border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .tool-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .tool-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 5px;
        }
        
        .tool-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: var(--editor-text);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-item:hover {
            background: var(--editor-hover);
        }
        
        .tool-item.active {
            background: var(--editor-active);
            color: white;
        }
        
        .tool-item i {
            width: 20px;
            text-align: center;
        }
        
        /* Center Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            overflow: hidden;
        }
        
        .preview-toolbar {
            background: var(--editor-bg);
            border-bottom: 1px solid var(--editor-border);
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .preview-toolbar-btn {
            padding: 6px 12px;
            background: transparent;
            color: var(--editor-text);
            border: 1px solid var(--editor-border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .preview-toolbar-btn:hover {
            background: var(--editor-hover);
            border-color: var(--editor-active);
        }
        
        .preview-toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
            background: #525252;
            padding: 20px;
            min-height: 100%;
        }
        
        .pdf-page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 0 auto;
        }
        
        .pdf-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        
        /* Overlay system removed - using native PDF editing only */
        
        .deletion-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .deletion-rect {
            position: absolute;
            background: white;
            border: none;
            pointer-events: auto;
            z-index: 6;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #0b1630;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            width: 300px;
            max-width: 80%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .loading-percentage {
            color: #4361ee;
            font-size: 14px;
            margin-top: 8px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile Optimization - Touch Gestures & Responsive UI */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tool-group {
                min-width: 120px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .tool-item {
                min-height: 60px;
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item i {
                font-size: 20px;
                margin-bottom: 4px;
            }
            
            .preview-panel {
                flex: 1;
                min-height: 60vh;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-left: none;
                border-top: 1px solid #3a3a3a;
            }
            
            .property-group {
                min-width: 150px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .pdf-canvas {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            .preview-toolbar-btn {
                min-width: 60px;
                min-height: 44px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            /* Removed .editable-text styles - no longer using DOM overlays */
            /* All text editing now uses backend /api/pdf/edit-text endpoint */
        }
        
        /* Touch Gesture Support */
        .pdf-canvas {
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Larger Touch Targets for Mobile */
        @media (max-width: 768px) {
            button, .tool-item, .preview-toolbar-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            input[type="number"],
            input[type="color"],
            select {
                min-height: 44px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Right Properties Panel */
        .properties-panel {
            width: 280px;
            min-width: 280px;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .property-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .property-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 8px;
        }
        
        .property-item {
            padding: 8px 12px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-label {
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .property-input {
            width: 100%;
            padding: 4px 8px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        /* Search Results in Properties Panel */
        #search-results {
            padding: 8px 0 !important;
        }
        
        .search-result-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }
        
        .search-result-item:hover {
            background: #3a3a3a;
            border-color: #0078d4;
        }
        
        .search-result-item.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .search-result-text {
            color: #e5e5e5;
            margin-bottom: 4px;
            line-height: 1.4;
        }
        
        .search-result-item.active .search-result-text {
            color: white;
        }
        
        .search-result-meta {
            color: #9ca3af;
            font-size: 10px;
        }
        
        .search-result-item.active .search-result-meta {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .search-result-item mark {
            background: #ffeb3b;
            color: #000;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        .search-result-item.active mark {
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .search-close:hover {
            color: #e5e5e5 !important;
        }
        
        /* Performance indicators */
        .performance-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        /* Performance Optimizations */
        .pdf-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Lazy loading for pages */
        .pdf-page-wrapper[data-loaded="false"] {
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .pdf-page-wrapper[data-loaded="true"] {
            opacity: 1;
        }
        
        /* Cache optimization */
        .tool-item {
            will-change: transform;
        }
        
        /* Smooth scrolling */
        .tools-panel, .properties-panel {
            scroll-behavior: smooth;
        }
        
        /* Mobile Support - Full Responsive */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: auto;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                flex-direction: row;
                overflow-x: auto;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
                -webkit-overflow-scrolling: touch;
            }
            
            .tool-group {
                min-width: 200px;
                flex-shrink: 0;
            }
            
            .preview-panel {
                order: 2;
                min-height: 500px;
            }
            
            .preview-container {
                min-height: 400px !important;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                order: 3;
                border-left: none;
                border-top: 1px solid #3a3a3a;
                max-height: 400px;
            }
            
            #search-results {
                max-height: 150px !important;
            }
            
            .tool-item {
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item span {
                display: block;
                margin-top: 4px;
            }
            
            /* Touch-friendly buttons */
            .preview-toolbar-btn {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Mobile gestures */
            .pdf-page-wrapper {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            /* Enhanced mobile touch targets */
            .tool-item {
                min-width: 50px;
                min-height: 50px;
            }
            
            /* Mobile-friendly zoom controls */
            .zoom-controls {
                position: fixed;
                bottom: 20px;
                right: 20px;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .zoom-btn {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: #4361ee;
                color: white;
                border: none;
                font-size: 20px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }
        }
        
        /* Real-time Collaboration Styles */
        .collaboration-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 300px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .collaboration-panel.active {
            display: block;
        }
        
        .collaboration-
        
        .collaboration-title {
            font-size: 16px;
            font-weight: 600;
            color: #e5e5e5;
        }
        
        .collaboration-user {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
        }
        
        .collaboration-user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4361ee;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .collaboration-user-name {
            color: #e5e5e5;
            font-size: 14px;
        }
        
        .collaboration-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-left: auto;
        }
        
        .collaboration-chat {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }
        
        .collaboration-message {
            padding: 8px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border-radius: 4px;
            font-size: 12px;
            color: #e5e5e5;
        }
        
        .collaboration-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="global-header-placeholder"></div>

    <nav aria-label="Breadcrumb" style="padding: 15px 0; background: #f8f9ff; border-bottom: 1px solid #e2e6ff;">
        <div class="container" style="max-width: 1200px; margin: 0 auto; padding: 0 24px;">
            <ol style="list-style: none; display: flex; flex-wrap: wrap; gap: 10px; margin: 0; padding: 0; align-items: center;">
                <li><a href="feedback.html" style="color: #4361ee; text-decoration: none; font-weight: 500; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">Home</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="login.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Sign In</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="signup.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Signup</a></li>
            </ol>
        </div>
    </nav>
    <script src="js/global-components.js"></script>
    <script>
    // Ensure header loads - multiple attempts to guarantee it works
    (function() {
        function tryLoadHeader() {
            if (typeof loadGlobalHeader === 'function') {
                try {
                    loadGlobalHeader();
                    return true;
                } catch (e) {
                    console.error('Error calling loadGlobalHeader:', e);
                }
            }
            return false;
        }
        
        // Try immediately if script already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            if (!tryLoadHeader()) {
                // Script not loaded yet, wait for it
                var attempts = 0;
                var maxAttempts = 60; // 3 seconds total
                var checkHeader = setInterval(function() {
                    attempts++;
                    if (tryLoadHeader() || attempts >= maxAttempts) {
                        clearInterval(checkHeader);
                    }
                }, 50);
            }
        } else {
            // Wait for DOM to be ready
            document.addEventListener('DOMContentLoaded', function() {
                if (!tryLoadHeader()) {
                    var attempts = 0;
                    var maxAttempts = 40;
                    var checkHeader = setInterval(function() {
                        attempts++;
                        if (tryLoadHeader() || attempts >= maxAttempts) {
                            clearInterval(checkHeader);
                        }
                    }, 50);
                }
            });
        }
        
        // Final backup attempt on window load
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (!document.querySelector('header') && typeof loadGlobalHeader === 'function') {
                    loadGlobalHeader();
                }
            }, 100);
        });
    })();
    </script>
    
    <div id="global-breadcrumb-placeholder"></div>
    
    <main>
        <div class="container">
            <div class="page-header">
                <h1>Free Online PDF Editor - Edit PDF Files Online | Add Text, Images, OCR</h1>
                <h2 style="font-size: 1.2rem; color: #64748b; font-weight: 400; margin-top: 10px;">Edit PDF documents online for free. Add text, images, annotations, and extract text with OCR. No software installation required.</h2>
                <p>Free online PDF editor to edit PDF files, add text, images, annotations, highlight content, and extract text with OCR. No software installation required - edit PDFs directly in your browser.</p>
            </div>
            
            <!-- Professional Editor Workspace -->
            <div class="editor-workspace">
                <!-- Left Tools Panel -->
                <div class="tools-panel">
                    <div class="tool-group">
                        <div class="tool-group-title">File</div>
                        <div class="tool-item" id="upload-btn" title="Upload PDF">
                            <i class="fas fa-upload"></i>
                            <span>Upload</span>
                        </div>
                        <div class="tool-item" id="download-btn" title="Download PDF">
                            <i class="fas fa-download"></i>
                            <span>Download</span>
                        </div>
                        <div class="tool-item" id="save-cloud-btn" title="Save to Cloud">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <span>Save to Cloud</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Edit</div>
                        <div class="tool-item" id="select-tool" title="Select Tool" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i>
                            <span>Select</span>
                        </div>
                        <div class="tool-item" id="add-text-btn" title="Add Text" data-tool="text">
                            <i class="fas fa-font"></i>
                            <span>Add Text</span>
                        </div>
                        <div class="tool-item" id="add-image-btn" title="Add Image" data-tool="image">
                            <i class="fas fa-image"></i>
                            <span>Add Image</span>
                        </div>
                        <div class="tool-item" id="highlight-btn" title="Highlight" data-tool="highlight">
                            <i class="fas fa-highlighter"></i>
                            <span>Highlight</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Search & Replace</div>
                        <div class="tool-item" id="search-btn" title="Search Text in PDF">
                            <i class="fas fa-search"></i>
                            <span>Search</span>
                        </div>
                        <div class="tool-item" id="replace-btn" title="Find & Replace">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Replace</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">OCR</div>
                        <div class="tool-item" id="ocr-btn" title="Server-Side OCR">
                            <i class="fas fa-language"></i>
                            <span>OCR</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Page Management</div>
                        <div class="tool-item" id="rotate-page-btn" title="Rotate Page">
                            <i class="fas fa-redo"></i>
                            <span>Rotate</span>
                        </div>
                        <div class="tool-item" id="delete-page-btn" title="Delete Page">
                            <i class="fas fa-trash"></i>
                            <span>Delete Page</span>
                        </div>
                        <div class="tool-item" id="reorder-pages-btn" title="Reorder Pages">
                            <i class="fas fa-sort"></i>
                            <span>Reorder</span>
                        </div>
                        <div class="tool-item" id="extract-page-btn" title="Extract Page">
                            <i class="fas fa-file-export"></i>
                            <span>Extract</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Forms</div>
                        <div class="tool-item" id="fill-form-btn" title="Fill Form Fields">
                            <i class="fas fa-edit"></i>
                            <span>Fill Form</span>
                        </div>
                        <div class="tool-item" id="detect-form-btn" title="Detect Form Fields">
                            <i class="fas fa-search"></i>
                            <span>Detect Fields</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Annotations</div>
                        <div class="tool-item" id="comment-btn" title="Add Comment">
                            <i class="fas fa-comment"></i>
                            <span>Comment</span>
                        </div>
                        <div class="tool-item" id="stamp-btn" title="Add Stamp">
                            <i class="fas fa-stamp"></i>
                            <span>Stamp</span>
                        </div>
                        <div class="tool-item" id="shape-btn" title="Add Shape">
                            <i class="fas fa-shapes"></i>
                            <span>Shape</span>
                        </div>
                    </div>
                    
                    <!-- Export removed from left panel - available in right panel only -->
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Page Management</div>
                        <div class="tool-item" id="add-page-btn" title="Add New Page">
                            <i class="fas fa-plus-square"></i>
                            <span>Add Page</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Tools</div>
                        <div class="tool-item" id="compress-btn" title="Compress PDF">
                            <i class="fas fa-compress"></i>
                            <span>Compress</span>
                        </div>
                        <div class="tool-item" id="merge-btn" title="Merge PDFs">
                            <i class="fas fa-layer-group"></i>
                            <span>Merge</span>
                        </div>
                        <div class="tool-item" id="split-btn" title="Split PDF">
                            <i class="fas fa-cut"></i>
                            <span>Split</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Security & Extra</div>
                        <div class="tool-item" id="watermark-btn" title="Add Watermark">
                            <i class="fas fa-tint"></i>
                            <span>Watermark</span>
                        </div>
                        <div class="tool-item" id="sign-btn" title="Digital Signature">
                            <i class="fas fa-signature"></i>
                            <span>Sign</span>
                        </div>
                        <div class="tool-item" id="redact-btn" title="Redact Text">
                            <i class="fas fa-eye-slash"></i>
                            <span>Redact</span>
                        </div>
                        <div class="tool-item" id="protect-btn" title="Protect PDF">
                            <i class="fas fa-lock"></i>
                            <span>Protect</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">History</div>
                        <div class="tool-item" id="undo-btn" title="Undo" disabled>
                            <i class="fas fa-undo"></i>
                            <span>Undo</span>
                        </div>
                        <div class="tool-item" id="redo-btn" title="Redo" disabled>
                            <i class="fas fa-redo"></i>
                            <span>Redo</span>
                        </div>
                    </div>
                </div>
                
                <!-- Center Preview Panel -->
                <div class="preview-panel">
                    <div class="preview-toolbar">
                        <button class="preview-toolbar-btn" id="prev-page" disabled>
                            <i class="fas fa-chevron-left"></i> Prev
                        </button>
                        <span class="page-info" style="color: #e5e5e5; font-size: 12px; padding: 0 10px;">
                            Page <span id="page-num">1</span> of <span id="page-count">1</span>
                        </span>
                        <button class="preview-toolbar-btn" id="next-page" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <div style="flex: 1;"></div>
                        <!-- Theme Toggle -->
                        <button class="preview-toolbar-btn" id="theme-toggle-btn" title="Toggle Light/Dark Theme" style="margin-right: 10px;">
                            <i class="fas fa-moon" id="theme-icon"></i>
                            <span id="theme-text">Dark</span>
                        </button>
                        <button class="preview-toolbar-btn" id="zoom-out-btn">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span style="color: #e5e5e5; font-size: 12px; padding: 0 10px;" id="zoom-level">100%</span>
                        <button class="preview-toolbar-btn" id="zoom-in-btn">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <!-- Credit Balance Display -->
                        <div id="credit-balance-display" style="margin-left: 10px; padding: 6px 12px; background: #4361ee; color: white; border-radius: 4px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                            <i class="fas fa-coins"></i>
                            <span id="credit-count">Loading...</span>
                        </div>
                    </div>
                    
                    <div class="preview-container" id="preview-container" style="display: flex; visibility: visible; min-height: 600px;">
                        <div class="loading-overlay" id="loading-overlay" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="loading-text">Processing...</div>
                            <div class="loading-progress">
                                <div class="loading-progress-bar" id="loading-progress-bar"></div>
                            </div>
                            <div class="loading-percentage" id="loading-percentage">0%</div>
                        </div>
                        <div id="pdf-page-wrapper" class="pdf-page-wrapper" style="display: block; visibility: visible; position: relative;">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="deletion-layer" class="deletion-layer"></div>
                            <div id="text-layer" class="text-layer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Properties Panel -->
                <div class="properties-panel">
                    <!-- Search & Replace Panel -->
                    <div class="property-group" id="search-panel">
                        <div class="property-group-title" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Search & Replace</span>
                            <button class="search-close" id="search-close-btn" style="background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 18px; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;" title="Close">&times;</button>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Search for:</div>
                            <input type="text" class="property-input" id="search-input" placeholder="Enter text to search..." style="margin-bottom: 8px;">
                        </div>
                        <div class="property-item" id="replace-input-group" style="display: none;">
                            <div class="property-label">Replace with:</div>
                            <input type="text" class="property-input" id="replace-input" placeholder="Enter replacement text..." style="margin-bottom: 8px;">
                        </div>
                        <div class="property-item" style="padding: 4px 12px;">
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 6px; color: #e5e5e5; font-size: 11px; cursor: pointer;">
                                    <input type="checkbox" id="case-sensitive" style="margin: 0; cursor: pointer;">
                                    <span>Case sensitive</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 6px; color: #e5e5e5; font-size: 11px; cursor: pointer;">
                                    <input type="checkbox" id="whole-words" style="margin: 0; cursor: pointer;">
                                    <span>Whole words</span>
                                </label>
                            </div>
                        </div>
                        <div class="property-item" style="padding: 8px 12px;">
                            <button class="property-input" id="search-execute-btn" style="width: 100%; padding: 8px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 5px;">
                                <i class="fas fa-search"></i> Search
                            </button>
                            <button class="property-input" id="replace-execute-btn" style="display: none; width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-exchange-alt"></i> Replace All
                            </button>
                        </div>
                        <div class="property-item" id="search-match-count" style="padding: 4px 12px; font-size: 11px; color: #9ca3af; min-height: 20px;"></div>
                        <div class="property-item" id="search-results" style="padding: 0; max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Text Properties</div>
                        <div class="property-item">
                            <div class="property-label">Font Size</div>
                            <input type="number" class="property-input" id="font-size-input" value="12" min="8" max="72">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Font Family</div>
                            <select class="property-input" id="font-family-select">
                                <option value="Helvetica">Helvetica</option>
                                <option value="Helvetica-Bold">Helvetica Bold</option>
                                <option value="Helvetica-Oblique">Helvetica Oblique</option>
                                <option value="Helvetica-BoldOblique">Helvetica Bold Oblique</option>
                                <option value="Times-Roman">Times Roman</option>
                                <option value="Times-Bold">Times Bold</option>
                                <option value="Times-Italic">Times Italic</option>
                                <option value="Times-BoldItalic">Times Bold Italic</option>
                                <option value="Courier">Courier</option>
                                <option value="Courier-Bold">Courier Bold</option>
                                <option value="Courier-Oblique">Courier Oblique</option>
                                <option value="Courier-BoldOblique">Courier Bold Oblique</option>
                                <option value="Arial">Arial</option>
                                <option value="Symbol">Symbol</option>
                                <option value="ZapfDingbats">ZapfDingbats</option>
                            </select>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Color</div>
                            <input type="color" class="property-input" id="text-color-input" value="#000000">
                        </div>
                        <div class="property-item" style="margin-top: 15px;">
                            <button class="property-input" id="delete-text-btn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-trash"></i> Delete Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Page Actions</div>
                        <div class="property-item">
                            <button class="property-input" id="rotate-90-btn" style="width: 100%; padding: 6px; background: #2d2d2d; color: #e5e5e5; border: 1px solid #3a3a3a; border-radius: 4px; cursor: pointer; font-size: 11px; margin-bottom: 5px;">
                                <i class="fas fa-redo"></i> Rotate 90Â°
                            </button>
                            <button class="property-input" id="delete-current-page-btn" style="width: 100%; padding: 6px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                <i class="fas fa-trash"></i> Delete Page
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Export Format</div>
                        <div class="property-item">
                            <select class="property-input" id="export-format-select" style="margin-bottom: 5px;">
                                <option value="pdf">PDF</option>
                                <option value="word" disabled>Word (DOCX) - Coming soon</option>
                                <option value="excel" disabled>Excel (XLSX) - Coming soon</option>
                                <option value="powerpoint" disabled>PowerPoint (PPTX) - Coming soon</option>
                                <option value="image">Images (PNG)</option>
                            </select>
                            <button class="property-input" id="export-btn" style="width: 100%; padding: 8px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Compression</div>
                        <div class="property-item">
                            <select class="property-input" id="compression-quality" style="margin-bottom: 5px;">
                                <option value="low">Low (Smaller Size)</option>
                                <option value="medium" selected>Medium (Balanced)</option>
                                <option value="high">High (Better Quality)</option>
                            </select>
                            <button class="property-input" id="compress-pdf-btn" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-compress"></i> Compress
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Performance</div>
                        <div class="property-item">
                            <div class="property-label">Rendering</div>
                            <div style="color: #28a745; font-size: 11px;">â¡ Backend Rendering</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Processing</div>
                            <div style="color: #28a745; font-size: 11px;">âï¸ Server-Side</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">OCR Engine</div>
                            <div style="color: #28a745; font-size: 11px;">ð OCR Ready</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Free Limit Info Panel -->
        <div id="free-limit-panel" style="position: fixed; bottom: 20px; right: 20px; background: #2b2b2b; color: #e5e5e5; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; max-width: 300px; display: none;">
            <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-info-circle" style="color: #4361ee;"></i>
                <span>Daily Free Limit</span>
            </div>
            <div style="font-size: 12px; line-height: 1.6; margin-bottom: 12px;">
                <div>Pages edited today: <span id="free-limit-pages-used">0</span> / <span id="free-limit-total">5</span></div>
                <div style="margin-top: 8px; color: #9ca3af;">Remaining: <span id="free-limit-remaining">5</span> pages</div>
            </div>
            <div style="font-size: 11px; color: #9ca3af; margin-bottom: 12px; line-height: 1.4;">
                After free limit: 10 credits per page
            </div>
            <a href="pricing.html" style="display: block; text-align: center; padding: 8px; background: #4361ee; color: white; border-radius: 4px; text-decoration: none; font-size: 12px; font-weight: 600;">
                Upgrade to Premium
            </a>
        </div>
    </main>
    
    <!-- 
    <section class="faq-section" style="margin: 40px 0; padding: 40px; background: #f8f9ff; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <h2 style="font-size: 2rem; color: #4361ee; margin-bottom: 30px; text-align: center;">
            <i class="fas fa-question-circle" style="margin-right: 10px;"></i>
            Frequently Asked Questions
        </h2>
        <div class="faq-container" style="max-width: 800px; margin: 0 auto;">
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    How accurate is the conversion?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Our conversion tools maintain 99% accuracy, preserving all formatting, fonts, and layout from your original files.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    What file sizes are supported?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Free users can convert files up to 10MB. Premium users can process files up to 100MB with faster processing.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    Will my data be secure?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Yes, all files are processed securely and automatically deleted after conversion. We never store or share your documents.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    Can I convert multiple files at once?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Yes, premium users can convert multiple files simultaneously. Free users can process one file at a time.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h4 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    What formats are supported?
                </h4>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    We support all major file formats. Check the tool page for specific format compatibility.
                </div>
            </div>
        </div>
    </section>

    <script>
    function toggleFaq(element) {
        const answer = element.nextElementSibling;
        const icon = element.querySelector('i');
        const isOpen = answer.style.display === 'block';

        answer.style.display = isOpen ? 'none' : 'block';
        icon.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(90deg)';
    }
    </script>
SSL Security & Trust Section -->
    <section class="ssl-security-section" style="background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%); padding: 60px 20px; margin-top: 40px;">
        <div class="container">
            <h2>Upload File</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 30px; max-width: 1200px; margin: 0 auto;">
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">ð</div>
                    <h4 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">SSL Encrypted</h4>
                    <p style="color: #64748b; line-height: 1.6;">256-bit SSL encryption ensures your PDF files are secure during upload and processing. All data is encrypted in transit.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">ð¡ï¸</div>
                    <h4 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Privacy Protected</h4>
                    <p style="color: #64748b; line-height: 1.6;">Your PDF files are processed securely and automatically deleted after processing. We never store or share your documents.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">â</div>
                    <h4 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">100% Free</h4>
                    <p style="color: #64748b; line-height: 1.6;">No hidden costs, no subscriptions, no credit card required. Edit PDFs online completely free with unlimited usage.</p>
                </div>
                <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); text-align: center;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">â¡</div>
                    <h4 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 10px;">Fast Processing</h4>
                    <p style="color: #64748b; line-height: 1.6;">Edit PDFs instantly in your browser. No waiting, no upload delays. Fast and efficient PDF editing experience.</p>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Features & Tools Description Section -->
    <section class="features-feedback-section" style="background: #ffffff; padding: 60px 20px; margin-top: 20px;">
        <div class="container">
            <h2 style="text-align: center; font-size: 2rem; color: #0b1630; margin-bottom: 50px;">ð ï¸ Key Features & Characteristics</h2>
            <h3 style="text-align: center; font-size: 1.1rem; color: #64748b; margin-bottom: 30px; font-weight: 400;">Native PDF editing, OCR, export, security, and performance in one workspace</h3>
            
            <div style="max-width: 1000px; margin: 0 auto;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; margin-bottom: 40px;">
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-edit" style="color: #4361ee;"></i> Text Editing
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Add, edit, and delete text in your PDF documents. Change font size, color, and style. Native PDF text editing ensures your changes are permanent.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-image" style="color: #4361ee;"></i> Image Insertion
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Insert images into your PDF files. Add logos, photos, or graphics to enhance your documents. Supports JPG, PNG, and other image formats.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-highlighter" style="color: #4361ee;"></i> Highlighting & Annotations
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Highlight important text, add comments, stamps, and shapes. Annotate your PDFs for review, collaboration, or personal notes.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-eye" style="color: #4361ee;"></i> OCR Text Extraction
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Extract text from scanned PDFs and images using OCR technology. Make scanned documents searchable and editable.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-cloud-upload-alt" style="color: #4361ee;"></i> Cloud Storage
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Save your edited PDFs directly to cloud storage. Access your documents from anywhere, anytime.</p>
                    </div>
                    
                    <div style="background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #4361ee;">
                        <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-file-export" style="color: #4361ee;"></i> Export Formats
                        </h3>
                        <p style="color: #64748b; line-height: 1.7;">Export your PDFs to Word, Excel, PowerPoint, or images. Convert PDFs to various formats for easy editing.</p>
                    </div>
                </div>
                
                <!-- Feedback Section -->
                <div style="background: linear-gradient(135deg, #4361ee 0%, #3a56d4 100%); padding: 40px; border-radius: 12px; color: white; text-align: center;">
                    <h3 style="font-size: 1.5rem; margin-bottom: 15px;">ð¬ We Value Your Feedback</h3>
                    <p style="font-size: 1.1rem; margin-bottom: 25px; opacity: 0.95;">Help us improve our PDF editor. Share your experience, suggestions, or report any issues.</p>
                    <a href="index.html#contact" style="display: inline-block; background: white; color: #4361ee; padding: 12px 30px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: transform 0.2s;">
                        Share Feedback <i class="fas fa-arrow-right" style="margin-left: 8px;"></i>
                    </a>
                </div>
            </div>
        </div>
    </section>
    
    
    <section class="feedback-section" style="margin: 40px 0; padding: 40px; background: #f8f9ff; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <h2 style="font-size: 2rem; color: #4361ee; margin-bottom: 30px; text-align: center;">
            <i class="fas fa-comments" style="margin-right: 10px;"></i>
            Reviews & Comments
        </h2>
        <div style="text-align: center; margin-bottom: 30px;">
            <a href="feedback.html" style="display: inline-flex; align-items: center; gap: 8px; color: #4361ee; text-decoration: none; font-weight: 600; font-size: 1rem; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">
                <i class="fas fa-external-link-alt"></i>
                View All Comments
            </a>
        </div>
        
        <div class="feedback-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: flex-start; max-width: 1200px; margin: 0 auto;">
            <!-- Left Side: Comments List -->
            <div class="feedback-card" style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); min-height: 400px; max-height: 600px; overflow-y: auto;">
                <div class="thread-header" style="margin-bottom: 20px; border-bottom: 2px solid #e2e6ff; padding-bottom: 12px;">
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 8px;">Live Comments</h3>
                    <p class="feedback-hint" style="font-size: 0.85rem; color: #9ca3af; margin: 0;">Share your experience and see what others are saying.</p>
                </div>
                <ul class="comment-list" id="feedbackList" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 16px;">
                    <li class="feedback-muted" id="feedback-empty-state" style="text-align: center; padding: 40px 20px; color: #9ca3af; font-size: 0.95rem;">No comments yet. Start the conversation!</li>
                </ul>
            </div>
            
            <!-- Right Side: Feedback Form -->
            <div class="feedback-form-card" style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); position: sticky; top: 20px;">
                <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 20px;">
                    <i class="fas fa-edit" style="color: #4361ee; margin-right: 8px;"></i>
                    Share Your Feedback
                </h3>
                <form id="feedbackForm" style="display: flex; flex-direction: column; gap: 15px;">
                    <div class="form-group">
                        <label for="feedbackName" style="display: block; margin-bottom: 8px; color: #56607a; font-weight: 600; font-size: 0.9rem;">Your Name</label>
                        <input type="text" id="feedbackName" placeholder="Enter your name" required style="width: 100%; padding: 12px 16px; border: 1px solid #e2e6ff; border-radius: 8px; font-size: 0.95rem; transition: border-color 0.3s; box-sizing: border-box;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#e2e6ff'">
                    </div>
                    <div class="form-group">
                        <label for="feedbackMessage" style="display: block; margin-bottom: 8px; color: #56607a; font-weight: 600; font-size: 0.9rem;">Your Comment</label>
                        <textarea id="feedbackMessage" placeholder="Write your feedback or comment here..." required rows="5" style="width: 100%; padding: 12px 16px; border: 1px solid #e2e6ff; border-radius: 8px; font-size: 0.95rem; resize: vertical; transition: border-color 0.3s; font-family: inherit; box-sizing: border-box;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#e2e6ff'"></textarea>
                    </div>
                    <button type="submit" style="background: linear-gradient(135deg, #4361ee, #3a0ca3); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; width: 100%;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(67, 97, 238, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        <i class="fas fa-paper-plane" style="margin-right: 8px;"></i>
                        Submit Feedback
                    </button>
                </form>
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e6ff;">
                    <a href="feedback.html" style="color: #4361ee; text-decoration: none; font-weight: 600; font-size: 0.9rem; display: inline-flex; align-items: center; gap: 8px; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">
                        <i class="fas fa-arrow-right"></i>
                        View All Feedback
                    </a>
                </div>
            </div>
        </div>
    </section>

    <style>
    @media (max-width: 768px) {
        .feedback-grid {
            grid-template-columns: 1fr !important;
        }
        .feedback-form-card {
            position: static !important;
        }
    }
    </style>

    <script>
    // Store feedback in localStorage (in production, use backend API)
    const currentPage = window.location.pathname.split('/').pop() || 'index.html';
    
    // Load feedbacks for this page (max 3, only genuine user comments)
    function loadFeedbacks() {
        const storedFeedbacks = JSON.parse(localStorage.getItem('feedbacks') || '{}');
        const pageFeedbacks = (storedFeedbacks[currentPage] || []).slice(0, 3);
        const feedbackList = document.getElementById('feedbackList');
        const emptyState = document.getElementById('feedback-empty-state');
        
        if (!feedbackList) return;
        
        // Clear existing content
        feedbackList.innerHTML = '';
        
        if (pageFeedbacks.length === 0) {
            // Show empty state
            if (emptyState) {
                feedbackList.appendChild(emptyState);
            } else {
                const empty = document.createElement('li');
                empty.className = 'feedback-muted';
                empty.id = 'feedback-empty-state';
                empty.style.cssText = 'text-align: center; padding: 40px 20px; color: #9ca3af; font-size: 0.95rem;';
                empty.textContent = 'No comments yet. Start the conversation!';
                feedbackList.appendChild(empty);
            }
            return;
        }
        
        // Remove empty state
        if (emptyState) {
            emptyState.remove();
        }
        
        // Display genuine user feedbacks
        pageFeedbacks.forEach(fb => {
            const li = document.createElement('li');
            li.className = 'live-comment';
            li.style.cssText = 'background: #f8f9ff; padding: 16px; border-radius: 8px; border-left: 3px solid #4361ee; margin-bottom: 12px;';
            
            const header = document.createElement('div');
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;';
            
            const nameDiv = document.createElement('div');
            const name = document.createElement('h4');
            name.style.cssText = 'font-size: 1rem; color: #0b1630; margin: 0 0 4px 0; font-weight: 600;';
            name.textContent = fb.name || 'Anonymous';
            
            const time = document.createElement('span');
            time.style.cssText = 'font-size: 0.8rem; color: #9ca3af;';
            time.textContent = fb.date || 'Recently';
            
            nameDiv.appendChild(name);
            nameDiv.appendChild(time);
            header.appendChild(nameDiv);
            
            li.appendChild(header);
            
            const body = document.createElement('p');
            body.style.cssText = 'color: #56607a; line-height: 1.6; margin: 0 0 12px 0; font-size: 0.9rem;';
            body.textContent = fb.message || '';
            li.appendChild(body);
            
            // Add reply if exists
            if (fb.reply) {
                const replyDiv = document.createElement('div');
                replyDiv.style.cssText = 'margin-left: 20px; padding: 12px; background: white; border-radius: 6px; margin-top: 10px; border-left: 2px solid #4361ee;';
                
                const replyHeader = document.createElement('div');
                replyHeader.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-bottom: 6px;';
                
                const replyIcon = document.createElement('i');
                replyIcon.className = 'fas fa-reply';
                replyIcon.style.cssText = 'color: #4361ee; font-size: 0.85rem;';
                
                const replyLabel = document.createElement('strong');
                replyLabel.style.cssText = 'color: #4361ee; font-size: 0.85rem;';
                replyLabel.textContent = 'Admin Reply:';
                
                replyHeader.appendChild(replyIcon);
                replyHeader.appendChild(replyLabel);
                replyDiv.appendChild(replyHeader);
                
                const replyText = document.createElement('p');
                replyText.style.cssText = 'color: #56607a; font-size: 0.85rem; line-height: 1.5; margin: 0;';
                replyText.textContent = fb.reply;
                replyDiv.appendChild(replyText);
                
                li.appendChild(replyDiv);
            }
            
            feedbackList.appendChild(li);
        });
    }
    
    // Handle feedback form submission
    const feedbackForm = document.getElementById('feedbackForm');
    if (feedbackForm) {
        feedbackForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('feedbackName').value.trim();
            const message = document.getElementById('feedbackMessage').value.trim();
            
            if (!name || !message) {
                alert('Please fill in all fields');
                return;
            }
            
            const feedback = {
                name: name,
                message: message,
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
                page: currentPage
            };
            
            // Store in localStorage
            const storedFeedbacks = JSON.parse(localStorage.getItem('feedbacks') || '{}');
            if (!storedFeedbacks[currentPage]) {
                storedFeedbacks[currentPage] = [];
            }
            storedFeedbacks[currentPage].unshift(feedback);
            localStorage.setItem('feedbacks', JSON.stringify(storedFeedbacks));
            
            // Reset form
            this.reset();
            
            // Reload feedbacks
            loadFeedbacks();
            
            alert('Thank you for your feedback!');
        });
    }
    
    // Load feedbacks on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadFeedbacks);
    } else {
        loadFeedbacks();
    }
    </script>
    
    <!-- About Section -->
    <section id="about" class="about-section" style="background: white; padding: 60px 0; margin-top: 40px;">
        <div class="container">
            <div class="about-content" style="max-width: 1000px; margin: 0 auto;">
                <div class="about-text" style="text-align: center; margin-bottom: 40px;">
                    <h2 style="font-size: 2.5rem; color: #0b1630; margin-bottom: 20px; font-weight: 700;">About easyjpgtopdf</h2>
                    <p style="font-size: 1.1rem; color: #56607a; line-height: 1.8; margin-bottom: 20px;">
                        easyjpgtopdf was founded in 2023 with a simple mission: to make PDF management easy, accessible, and free for everyone. We believe that working with PDFs shouldn't require expensive software or technical expertise.
                    </p>
                    <p style="font-size: 1.1rem; color: #56607a; line-height: 1.8; margin-bottom: 20px;">
                        Our platform offers a comprehensive suite of PDF tools that help individuals and businesses convert, edit, and manage their documents with just a few clicks. All processing happens securely in the cloud, with no software installation required.
                    </p>
                    
                    <!-- How PDF Editor Works - Short Review -->
                    <div style="background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%); padding: 40px; border-radius: 16px; margin: 40px 0; text-align: left; box-shadow: 0 4px 12px rgba(0,0,0,0.08);">
                        <h3 style="font-size: 1.8rem; color: #0b1630; margin-bottom: 25px; text-align: center; font-weight: 700;">ð How Our PDF Editor Works</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 25px; margin-bottom: 30px;">
                            <div style="background: white; padding: 25px; border-radius: 12px; border-left: 4px solid #4361ee;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">ð¤</div>
                                <h4 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; font-weight: 600;">1. Upload PDF</h4>
                                <p style="color: #56607a; line-height: 1.6; font-size: 0.95rem;">Simply drag and drop your PDF file or click to browse. Supports all standard PDF formats up to 50MB. Your file is processed securely in the cloud.</p>
                            </div>
                            <div style="background: white; padding: 25px; border-radius: 12px; border-left: 4px solid #4361ee;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">âï¸</div>
                                <h4 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; font-weight: 600;">2. Edit Content</h4>
                                <p style="color: #56607a; line-height: 1.6; font-size: 0.95rem;">Click on any text to edit it directly. Add new text, change fonts, colors, and sizes. Insert images, highlight content, and add annotations. All changes are native to the PDF.</p>
                            </div>
                            <div style="background: white; padding: 25px; border-radius: 12px; border-left: 4px solid #4361ee;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">ð</div>
                                <h4 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; font-weight: 600;">3. OCR & Extract</h4>
                                <p style="color: #56607a; line-height: 1.6; font-size: 0.95rem;">Use OCR to extract text from scanned PDFs. Supports multiple languages including Hindi and English. Make scanned documents searchable and editable.</p>
                            </div>
                            <div style="background: white; padding: 25px; border-radius: 12px; border-left: 4px solid #4361ee;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">ð¾</div>
                                <h4 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; font-weight: 600;">4. Download</h4>
                                <p style="color: #56607a; line-height: 1.6; font-size: 0.95rem;">Download your edited PDF instantly. Export to Word, Excel, or PowerPoint formats. All changes are permanently saved in the PDF file.</p>
                            </div>
                        </div>
                        <div style="background: #f8f9ff; padding: 25px; border-radius: 12px; margin-top: 30px; border: 2px solid #e2e6ff;">
                            <h4 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 15px; font-weight: 600;">â¨ Key Features</h4>
                            <ul style="color: #56607a; line-height: 2; font-size: 1rem; list-style: none; padding: 0;">
                                <li style="margin-bottom: 10px;">â <strong>Native PDF Editing:</strong> Real text editing, not HTML overlays - changes are permanent</li>
                                <li style="margin-bottom: 10px;">â <strong>Server-Side OCR:</strong> Advanced OCR engine for accurate text extraction from scanned documents</li>
                                <li style="margin-bottom: 10px;">â <strong>Multi-Language Support:</strong> OCR works with Hindi, English, and 80+ languages</li>
                                <li style="margin-bottom: 10px;">â <strong>Font Customization:</strong> Change font family, size, color, and style for any text</li>
                                <li style="margin-bottom: 10px;">â <strong>Image Insertion:</strong> Add images, logos, and graphics to your PDFs</li>
                                <li style="margin-bottom: 10px;">â <strong>Export Options:</strong> Download as PDF, Word, Excel, or PowerPoint</li>
                                <li style="margin-bottom: 10px;">â <strong>Free Usage:</strong> 5 pages free per day, unlimited with premium</li>
                            </ul>
                        </div>
                        <div style="text-align: center; margin-top: 30px;">
                            <a href="blog-how-to-edit-pdf.html" style="display: inline-flex; align-items: center; gap: 10px; background: linear-gradient(135deg, #4361ee, #3a0ca3); color: white; padding: 14px 32px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 1.1rem; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(67, 97, 238, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(67, 97, 238, 0.3)'">
                                <i class="fas fa-book-reader"></i>
                                Read More - Complete Guide
                                <i class="fas fa-arrow-right"></i>
                            </a>
                        </div>
                    </div>
                    
                    <p style="font-size: 1.1rem; color: #56607a; line-height: 1.8; margin-top: 30px;">
                        We're committed to continuously improving our tools and adding new features based on user feedback. If you have suggestions or need help, don't hesitate to contact our support team.
                    </p>
                </div>
            </div>
        </div>
    </section>
    
    <footer>
        <div class="container footer-inner">
            <div class="footer-company-links">
                <span>Company</span>
                <a href="index.html#about">About Us</a>
                <a href="index.html#contact">Contact</a>
                <a href="pricing.html">Pricing</a>
                <a href="privacy-policy.html">Privacy Policy</a>
                <a href="terms-of-service.html">Terms of Service</a>
                <a href="dmca.html">DMCA</a>
                <a href="blog.html">Blog</a>
                <a href="sitemap.xml">Sitemap</a>
                <a href="feedback.html">Feedback</a>
            </div>
            <p class="footer-brand-line">&copy; easyjpgtopdf &mdash; Free PDF &amp; Image Tools for everyone. All rights reserved.</p>
                        <p class="footer-credits">
                Thanks to every open-source contributor powering this site. <a href="attributions.html">See full acknowledgements</a>.
            </p>
            <div class="footer-social-search" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; padding-top: 20px; border-top: 1px solid #444; flex-wrap: wrap; gap: 15px;">
                <div class="footer-social-links" style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                    <a href="https://x.com/easyjpgtopdf" target="_blank" rel="noopener noreferrer" title="Follow us on X (Twitter)" style="display: inline-flex; align-items: center; gap: 8px; color: #aaa; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#aaa'">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                        <span style="font-size: 0.9rem;">@easyjpgtopdf</span>
                    </a>
                    <a href="https://www.youtube.com/@EasyJpgtoPdf" target="_blank" rel="noopener noreferrer" title="Subscribe to our YouTube channel" style="display: inline-flex; align-items: center; gap: 8px; color: #aaa; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#aaa'">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                        </svg>
                        <span style="font-size: 0.9rem;">@EasyJpgtoPdf</span>
                    </a>
                    <div style="display: inline-flex; align-items: center; gap: 8px; color: #aaa; cursor: default;" title="Mobile App Coming Soon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.05 20.28c-.98.95-2.05.88-3.08.4-1.09-.5-2.08-.95-3.24-1.44-2.24-1.01-4.33-1.95-5.99-3.22C2.79 14.25.99 12.12.99 9.12c0-2.23 1.21-4.15 3.29-5.19.4-.2.81-.38 1.24-.52.7-.23 1.23-.52 1.62-.82.49-.38.85-.88 1.06-1.46.19-.57.24-1.17.14-1.8-.09-.63-.29-1.24-.58-1.81L7.76.36c.16-.24.35-.45.57-.62.22-.17.46-.3.72-.4.26-.1.54-.15.82-.15.28 0 .56.05.82.15.26.1.5.23.72.4.22.17.41.38.57.62l1.39 2.06c.29.57.49 1.18.58 1.81.1.63.05 1.23-.14 1.8-.21.58-.57 1.08-1.06 1.46-.39.3-.92.59-1.62.82-.43.14-.84.32-1.24.52-2.08 1.04-3.29 2.96-3.29 5.19 0 3 1.8 5.13 4.5 6.5 1.66 1.27 3.75 2.21 5.99 3.22 1.16.49 2.15.94 3.24 1.44 1.03.48 2.1.55 3.08-.4 1.01-.98 1.01-2.4.01-3.38z"/>
                        </svg>
                        <span style="font-size: 0.9rem;">App Coming Soon</span>
                    </div>
                </div>
                <div class="footer-search" style="flex: 1; min-width: 200px; max-width: 300px;">
                    <form action="https://www.google.com/search" method="get" target="_blank" style="display: flex; gap: 5px;">
                        <input type="hidden" name="sitesearch" value="easyjpgtopdf.com">
                        <input type="text" name="q" placeholder="Search our site..." style="flex: 1; padding: 8px 12px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 0.9rem; outline: none;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#555'">
                        <button type="submit" style="padding: 8px 15px; background: #4361ee; border: none; border-radius: 4px; color: #fff; cursor: pointer; transition: background 0.3s;" onmouseover="this.style.background='#3a0ca3'" onmouseout="this.style.background='#4361ee'">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                            </svg>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </footer>
    
    <input type="file" id="file-input" accept="application/pdf,.pdf" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
    <script src="js/mobile-menu-init.js"></script>
    <script>
        // Get API base URL helper
        function getApiBaseUrl() {
            if (window.location.protocol === 'file:') {
                return 'http://localhost:3000';
            }
            return '';
        }
        
        // Loading overlay functions
        function showLoading(message, progress = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
                const loadingText = loadingOverlay.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = message || 'Processing...';
                }
                // Update progress if progress bar exists
                const progressBar = loadingOverlay.querySelector('.progress-bar');
                if (progressBar && progress >= 0) {
                    progressBar.style.width = progress + '%';
                }
            }
        }
        
        function hideLoading() {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
        
        function updateProgress(percent, message) {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                const progressBar = loadingOverlay.querySelector('.progress-bar');
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                }
                const loadingText = loadingOverlay.querySelector('.loading-text');
                if (loadingText && message) {
                    loadingText.textContent = message;
                }
            }
        }
        
        function showError(message) {
            hideLoading();
            alert('Error: ' + message);
        }
        
        // Professional PDF Editor Implementation
        // Features: Backend rendering, Server processing, Fast OCR, Native editing, Cloud integration
        
        // Initialize device fingerprinting for quota tracking
        let deviceInfo = null;
        async function initDeviceTracking() {
            try {
                const { getDeviceInfo } = await import('./js/device-fingerprint.js');
                deviceInfo = await getDeviceInfo();
                console.log('â Device tracking initialized for PDF editor:', {
                    deviceId: deviceInfo.deviceId,
                    ip: deviceInfo.ip,
                    fingerprint: deviceInfo.fingerprint.substring(0, 20) + '...'
                });
                return true;
            } catch (error) {
                console.warn('â ï¸ Device fingerprinting not available:', error);
                return false;
            }
        }
        
        // Initialize device tracking on page load
        initDeviceTracking();
        
        // PDF.js removed - using backend /page/render for all rendering
        
        // Global variables
        if (typeof window.pdfEditorVars === 'undefined') {
            window.pdfEditorVars = {
                pdfDoc: null,
                currentPage: 1,
                totalPages: 1,
                scale: 1.5,
                loadedFromStorage: false,
                textAnnotations: [],
                annotationHistory: [],
                redoHistory: [],
                selectedTextElement: null,
                activeTool: 'select',
                ocrTextsForPDF: [],
                annotations: {
                    highlights: [],
                    comments: [],
                    stamps: [],
                    shapes: []
                },
                highlightStart: null,
                highlightEnd: null,
                isDrawing: false,
                loadedInitialPdf: false,
                expectedTexts: [] // Track texts added/edited for validation
            };
        }
        
        // DOM elements
        const previewContainer = document.getElementById('preview-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const pdfPageWrapper = document.getElementById('pdf-page-wrapper');
        const pdfCanvas = document.getElementById('pdf-canvas');
        // Overlay layers removed - using backend rendering only
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const downloadBtn = document.getElementById('download-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const saveCloudBtn = document.getElementById('save-cloud-btn');
        const ocrBtn = document.getElementById('ocr-btn');
        // Fast OCR removed - using single OCR button
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const highlightBtn = document.getElementById('highlight-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const imageInput = document.getElementById('image-input');
        const fileInput = document.getElementById('file-input');
        const selectTool = document.getElementById('select-tool');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomLevel = document.getElementById('zoom-level');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorInput = document.getElementById('text-color-input');
        const deleteTextBtn = document.getElementById('delete-text-btn');
        const searchBtn = document.getElementById('search-btn');
        const replaceBtn = document.getElementById('replace-btn');
        const searchPanel = document.getElementById('search-panel');
        const searchCloseBtn = document.getElementById('search-close-btn');
        const searchInput = document.getElementById('search-input');
        const replaceInput = document.getElementById('replace-input');
        const replaceInputGroup = document.getElementById('replace-input-group');
        const searchExecuteBtn = document.getElementById('search-execute-btn');
        const replaceExecuteBtn = document.getElementById('replace-execute-btn');
        const searchResults = document.getElementById('search-results');
        const searchMatchCount = document.getElementById('search-match-count');
        const caseSensitiveCheck = document.getElementById('case-sensitive');
        const wholeWordsCheck = document.getElementById('whole-words');
        
        // Search & Replace functionality (HIGH PRIORITY)
        let currentSearchMatches = [];
        let currentSearchIndex = -1;
        
        // Open search panel (search icon button - works as button)
        if (searchBtn) {
            searchBtn.addEventListener('click', function() {
                if (searchPanel) {
                    // Scroll to search panel in properties panel
                    searchPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    searchInput.focus();
                    replaceInputGroup.style.display = 'none';
                    replaceExecuteBtn.style.display = 'none';
                }
            });
        }
        
        // Open replace panel
        if (replaceBtn) {
            replaceBtn.addEventListener('click', function() {
                if (searchPanel) {
                    // Scroll to search panel in properties panel
                    searchPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    searchInput.focus();
                    replaceInputGroup.style.display = 'block';
                    replaceExecuteBtn.style.display = 'block';
                }
            });
        }
        
        // Close search panel (clear search)
        if (searchCloseBtn) {
            searchCloseBtn.addEventListener('click', function() {
                if (searchPanel) {
                    // Clear search instead of hiding panel
                    searchInput.value = '';
                    replaceInput.value = '';
                    currentSearchMatches = [];
                    currentSearchIndex = -1;
                    searchMatchCount.textContent = '';
                    searchResults.innerHTML = '';
                    replaceInputGroup.style.display = 'none';
                    replaceExecuteBtn.style.display = 'none';
                }
            });
        }
        
        // Execute search
        if (searchExecuteBtn) {
            searchExecuteBtn.addEventListener('click', async function() {
                const query = searchInput.value.trim();
                if (!query) {
                    alert('Please enter a search query');
                    return;
                }
                
                if (!currentSessionId) {
                    alert('No active PDF session. Please upload PDF first.');
                    return;
                }
                
                try {
                    showLoading('Searching PDF...', 30);
                    
                    // Import backend API
                    const { searchText } = await import('./js/pdf-editor-api.js');
                    
                    const result = await searchText(currentSessionId, query);
                    
                    if (result.success) {
                        // Convert backend matches to frontend format
                        currentSearchMatches = result.matches.map(match => ({
                            pageIndex: match.page_number - 1,
                            text: match.text,
                            bbox: match.bbox,
                            matchIndex: 0,
                            matchLength: query.length
                        }));
                        currentSearchIndex = -1;
                        
                        // Display results
                        displaySearchResults(currentSearchMatches, query);
                        
                        // Update match count
                        if (searchMatchCount) {
                            searchMatchCount.textContent = `Found ${currentSearchMatches.length} match(es)`;
                        }
                        
                        // Navigate to first match
                        if (currentSearchMatches.length > 0) {
                            navigateToMatch(0);
                        }
                    } else {
                        alert('Search failed: ' + (result.error || 'Unknown error'));
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Search error:', error);
                    hideLoading();
                    alert('Error searching PDF: ' + error.message);
                }
            });
        }
        
        // Execute replace all
        if (replaceExecuteBtn) {
            replaceExecuteBtn.addEventListener('click', async function() {
                const searchText = searchInput.value.trim();
                const replaceText = replaceInput.value.trim();
                
                if (!searchText) {
                    alert('Please enter text to search');
                    return;
                }
                
                if (!confirm(`Replace all occurrences of "${searchText}" with "${replaceText}"?`)) {
                    return;
                }
                
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Replacing text...', 30);
                    
                    // Search for all occurrences first
                    const { searchText: searchTextBackend } = await import('./js/pdf-editor-api.js');
                    const searchResult = await searchTextBackend(currentSessionId, searchText);
                    
                    if (!searchResult.matches || searchResult.matches.length === 0) {
                        alert('No matches found to replace.');
                        hideLoading();
                        return;
                    }
                    
                    // Replace each match using backend /text/edit
                    const { editText } = await import('./js/pdf-editor-api.js');
                    const userId = await getCurrentUserId();
                    let replacedCount = 0;
                    
                    for (const match of searchResult.matches) {
                        try {
                            // Use old_text from search result and new_text from replace input
                            const oldText = match.text || searchText;
                            await editText(
                                currentSessionId,
                                match.page_number,
                                oldText,
                                replaceText,
                                1, // max_replacements
                                userId
                            );
                            replacedCount++;
                        } catch (editError) {
                            console.warn('Failed to replace match:', editError);
                        }
                    }
                    
                    // Reload page to show changes
                    await renderPage(window.pdfEditorVars.currentPage);
                    
                    alert(`Successfully replaced ${replacedCount} occurrence(s)`);
                    
                    // Clear search results
                    currentSearchMatches = [];
                    currentSearchIndex = -1;
                    if (searchMatchCount) searchMatchCount.textContent = '';
                    if (searchResults) searchResults.innerHTML = '';
                    
                    hideLoading();
                } catch (error) {
                    console.error('Replace error:', error);
                    hideLoading();
                    alert('Error replacing text: ' + error.message);
                }
            });
        }
        
        // Display search results
        function displaySearchResults(matches, query) {
            if (!searchResults) return;
            
            searchResults.innerHTML = '';
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div style="padding: 12px; text-align: center; color: #9ca3af; font-size: 11px;">No matches found</div>';
                return;
            }
            
            matches.forEach((match, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'search-result-item';
                resultItem.innerHTML = `
                    <div class="search-result-text">${highlightMatch(match.text, query, match.matchIndex, match.matchLength)}</div>
                    <div class="search-result-meta">Page ${match.pageIndex + 1}</div>
                `;
                resultItem.addEventListener('click', () => navigateToMatch(index));
                searchResults.appendChild(resultItem);
            });
            
            // Scroll to top of results
            searchResults.scrollTop = 0;
        }
        
        // Highlight match in text
        function highlightMatch(text, query, matchIndex, matchLength) {
            const before = text.substring(0, matchIndex);
            const match = text.substring(matchIndex, matchIndex + matchLength);
            const after = text.substring(matchIndex + matchLength);
            return `${escapeHtml(before)}<mark style="background: #ffeb3b; color: #000;">${escapeHtml(match)}</mark>${escapeHtml(after)}`;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Navigate to match
        async function navigateToMatch(index) {
            if (index < 0 || index >= currentSearchMatches.length) return;
            
            currentSearchIndex = index;
            const match = currentSearchMatches[index];
            
            // Navigate to page
            if (match.pageIndex + 1 !== window.pdfEditorVars.currentPage) {
                window.pdfEditorVars.currentPage = match.pageIndex + 1;
                await renderPage(window.pdfEditorVars.currentPage);
            }
            
            // Highlight active result
            const resultItems = searchResults.querySelectorAll('.search-result-item');
            resultItems.forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });
            
            // Scroll to result item
            if (resultItems[index]) {
                resultItems[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Keyboard shortcuts for search
        document.addEventListener('keydown', function(e) {
            // Ctrl+F or Cmd+F to open search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                if (searchBtn) searchBtn.click();
            }
            
            // Escape to clear search
            if (e.key === 'Escape' && searchInput === document.activeElement) {
                if (searchCloseBtn) searchCloseBtn.click();
            }
            
            // Enter in search input to search
            if (e.key === 'Enter' && searchInput === document.activeElement) {
                if (searchExecuteBtn) searchExecuteBtn.click();
            }
        });
        
        // Global session ID for backend
        let currentSessionId = null;
        
        // File upload handler - set up after DOM is ready
        function setupFileUploadHandler() {
            const currentFileInput = document.getElementById('file-input');
            if (!currentFileInput) {
                console.error('File input not found');
                return;
            }
            
            // Remove existing listener if any by cloning
            const newFileInput = currentFileInput.cloneNode(true);
            currentFileInput.parentNode.replaceChild(newFileInput, currentFileInput);
            
            newFileInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                    alert('Please select a valid PDF file');
                    return;
                }
                
                // Check device quota before uploading
                try {
                    const { checkDeviceQuota } = await import('./js/device-fingerprint.js');
                    const quotaCheck = await checkDeviceQuota('pdfEdit');
                    
                    if (!quotaCheck.allowed) {
                        alert(`Quota exceeded: ${quotaCheck.message}\n\nYou have used ${quotaCheck.currentUsage.count || 0} of ${quotaCheck.limit} PDFs this month.\n\nPlease upgrade to Premium for unlimited PDF editing.`);
                        newFileInput.value = ''; // Clear file input
                        return;
                    }
                    
                    // Check file size limit (50 MB for free)
                    const fileSizeMB = file.size / (1024 * 1024);
                    if (fileSizeMB > 50) {
                        alert(`File size limit exceeded: ${fileSizeMB.toFixed(2)} MB\n\nFree plan allows up to 50 MB per PDF.\n\nPlease upgrade to Premium for larger files.`);
                        newFileInput.value = '';
                        return;
                    }
                } catch (quotaError) {
                    console.warn('Quota check failed, continuing:', quotaError);
                    // Continue on error (fail-open)
                }
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Start backend session for PDF editing
                    try {
                        updateProgress(20, 'Starting PDF session...');
                        const { startSession } = await import('./js/pdf-editor-api.js');
                        const userId = await getCurrentUserId();
                        
                        const sessionResult = await startSession(file);
                        currentSessionId = sessionResult.session_id;
                        window.pdfEditorVars.sessionId = currentSessionId;
                        window.pdfEditorVars.totalPages = sessionResult.page_count;
                        window.pdfEditorVars.loadedInitialPdf = false;
                        
                        updateProgress(50, 'Loading PDF...');
                        
                        // Load PDF for preview using PDF.js
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                const arrayBuffer = e.target.result;
                                // PDF.js removed - backend session will be created in renderPDF()
                                window.pdfEditorVars.currentPage = 1;
                                
                                // Store PDF data
                                const uint8Array = new Uint8Array(arrayBuffer);
                                let base64 = '';
                                const chunkSize = 8192;
                                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                                    const chunk = uint8Array.subarray(i, i + chunkSize);
                                    base64 += String.fromCharCode.apply(null, chunk);
                                }
                                base64 = btoa(base64);
                                window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                                
                                // Store in sessionStorage
                                const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                                const blobURL = URL.createObjectURL(blob);
                                sessionStorage.setItem('pdfFileURL', blobURL);
                                sessionStorage.setItem('pdfFileName', file.name);
                                
                                updateProgress(90, 'Starting backend session and rendering...');
                                await renderPDF(arrayBuffer);
                                window.pdfEditorVars.loadedInitialPdf = true;
                                
                                hideLoading();
                                console.log('â PDF session started. Session ID:', currentSessionId);
                            } catch (error) {
                                console.error('Error loading PDF:', error);
                                hideLoading();
                                alert('Error loading PDF: ' + error.message);
                            }
                        };
                        reader.readAsArrayBuffer(file);
                        return; // Exit early after starting session
                    } catch (sessionError) {
                        console.warn('Backend session failed, using client-side processing:', sessionError);
                        // Continue with client-side processing as fallback
                    }
                    
                    // Option 2: Client-side processing (Fallback)
                    // This always runs if server upload fails or is skipped
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        try {
                            const pdfData = e.target.result;
                            
                            // Store PDF data (chunked for large files to avoid stack overflow)
                            const arrayBuffer = pdfData;
                            
                            // Increment device quota after successful client-side processing
                            try {
                                const { incrementDeviceQuota } = await import('./js/device-fingerprint.js');
                                await incrementDeviceQuota('pdfEdit', 1, file.size);
                                console.log('â Device quota incremented for PDF upload (client-side)');
                            } catch (quotaError) {
                                console.warn('Failed to increment device quota:', quotaError);
                            }
                            
                            const uint8Array = new Uint8Array(arrayBuffer);
                            let base64 = '';
                            const chunkSize = 8192; // Process in 8KB chunks
                            for (let i = 0; i < uint8Array.length; i += chunkSize) {
                                const chunk = uint8Array.subarray(i, i + chunkSize);
                                base64 += String.fromCharCode.apply(null, chunk);
                            }
                            base64 = btoa(base64);
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for persistence
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            sessionStorage.setItem('pdfFileName', file.name);
                            
                            await renderPDF(pdfData);
                            window.pdfEditorVars.loadedInitialPdf = true;
                            
                            // Increment usage after successful render
                            try {
                                const { incrementUsage } = await import('./js/usage-limits.js');
                                await incrementUsage('pdf', 1);
                            } catch (usageError) {
                                console.warn('Failed to increment usage:', usageError);
                            }
                            
                            hideLoading();
                        } catch (renderError) {
                            console.error('PDF rendering error:', renderError);
                            hideLoading();
                            showError('Error loading PDF: ' + renderError.message);
                        }
                    };
                    reader.onerror = function() {
                        hideLoading();
                        showError('Error reading PDF file. Please try again.');
                    };
                    // Check usage limit before uploading
                    const { checkUsageLimit, incrementUsage, showUsageLimitMessage } = await import('./js/usage-limits.js');
                    const limitCheck = await checkUsageLimit('pdf');
                    
                    if (!limitCheck.allowed) {
                        hideLoading();
                        showUsageLimitMessage(limitCheck.message || 'Usage limit reached. Please upgrade your plan.', true);
                        // Redirect to pricing page
                        setTimeout(() => {
                            if (confirm('Would you like to upgrade your plan to continue?')) {
                                window.location.href = 'pricing.html';
                            }
                        }, 2000);
                        return;
                    }
                    
                    reader.readAsArrayBuffer(file);
                    
                } catch (error) {
                    console.error('File upload error:', error);
                    hideLoading();
                    alert('Error uploading PDF: ' + error.message);
                }
            });
        }
        
        // Setup file upload handler when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupFileUploadHandler);
        } else {
            // DOM already loaded, setup immediately
            setTimeout(setupFileUploadHandler, 100);
        }
        
        // Check for PDF from edit-pdf.html on page load
        async function checkForStoredPDF() {
            if (window.pdfEditorVars.loadedInitialPdf || window.pdfEditorVars.loadedFromStorage) {
                console.log('PDF already loaded, skipping re-load');
                return;
            }
            try {
                // Check for PDF server URL first (from edit-pdf.html upload)
                const pdfServerUrl = sessionStorage.getItem('pdfServerUrl');
                const pdfFileId = sessionStorage.getItem('pdfFileId');
                
                if (pdfServerUrl) {
                    console.log('Found PDF server URL:', pdfServerUrl);
                    showLoading('Loading PDF from server...', 20);
                    
                    try {
                        const response = await fetch(pdfServerUrl);
                        if (response.ok) {
                            const arrayBuffer = await response.arrayBuffer();
                            // Chunked base64 conversion for large files
                            const uint8Array = new Uint8Array(arrayBuffer);
                            let base64 = '';
                            const chunkSize = 8192; // Process in 8KB chunks
                            for (let i = 0; i < uint8Array.length; i += chunkSize) {
                                const chunk = uint8Array.subarray(i, i + chunkSize);
                                base64 += String.fromCharCode.apply(null, chunk);
                            }
                            base64 = btoa(base64);
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            // Store in sessionStorage for fallback (both blob URL and base64)
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const blobURL = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', blobURL);
                            // Also store base64 as fallback (more reliable)
                            sessionStorage.setItem('pdfFileBase64', base64);
                            
                            // File ID storage removed - using session-based approach
                            
                        await renderPDF(arrayBuffer);
                        window.pdfEditorVars.loadedInitialPdf = true;
                        window.pdfEditorVars.loadedFromStorage = true;
                            hideLoading();
                            console.log('PDF loaded from server successfully');
                            return;
                        } else {
                            console.warn('Failed to load PDF from server URL:', response.status);
                        }
                    } catch (serverError) {
                        console.warn('Server URL load failed, trying file ID:', serverError);
                        hideLoading();
                    }
                }
                
                // File ID loading removed - use session-based approach only
                
                // Fallback: Check sessionStorage for PDF blob URL or base64
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                const pdfFileName = sessionStorage.getItem('pdfFileName');
                const pdfFileBase64 = sessionStorage.getItem('pdfFileBase64');
                
                if (pdfFileBase64) {
                    // Use base64 if available (more reliable)
                    console.log('Found PDF from base64:', pdfFileName);
                    showLoading('Loading PDF...', 20);
                    
                    try {
                        // Convert base64 to ArrayBuffer (create new buffer to avoid detached error)
                        const binaryString = atob(pdfFileBase64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        // Create a new ArrayBuffer copy to avoid detached buffer error
                        const arrayBuffer = new Uint8Array(bytes).buffer;
                        
                        // Store as current PDF data
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${pdfFileBase64}`;
                        
                        // Render PDF
                        console.log('Rendering PDF from base64, arrayBuffer size:', arrayBuffer.byteLength);
                        await renderPDF(arrayBuffer);
                        window.pdfEditorVars.loadedInitialPdf = true;
                        window.pdfEditorVars.loadedFromStorage = true;
                        hideLoading();
                        console.log('â PDF loaded from base64 successfully');
                        console.log('PDF Doc:', window.pdfEditorVars.pdfDoc);
                        console.log('Total Pages:', window.pdfEditorVars.totalPages);
                        return;
                    } catch (error) {
                        console.error('Error loading PDF from base64:', error);
                        hideLoading();
                    }
                }
                
                if (pdfFileURL && pdfFileName) {
                    console.log('Found PDF from blob URL:', pdfFileName);
                    showLoading('Loading PDF...', 20);
                    
                    try {
                        // Fetch PDF from blob URL
                        const response = await fetch(pdfFileURL);
                        if (!response.ok) {
                            throw new Error('Failed to fetch blob URL');
                        }
                        const pdfBlob = await response.blob();
                        const arrayBuffer = await pdfBlob.arrayBuffer();
                        
                        // Store as current PDF data (chunked for large files)
                        const uint8Array = new Uint8Array(arrayBuffer);
                        let base64 = '';
                        const chunkSize = 8192; // Process in 8KB chunks
                        for (let i = 0; i < uint8Array.length; i += chunkSize) {
                            const chunk = uint8Array.subarray(i, i + chunkSize);
                            base64 += String.fromCharCode.apply(null, chunk);
                        }
                        base64 = btoa(base64);
                        window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                        
                        // Also store base64 for future use
                        sessionStorage.setItem('pdfFileBase64', base64);
                        
                        // Render PDF
                        await renderPDF(arrayBuffer);
                        hideLoading();
                        console.log('â PDF loaded from blob URL successfully');
                    } catch (error) {
                        console.error('Error loading stored PDF from blob URL:', error);
                        hideLoading();
                        // Show error message to user
                        if (previewContainer) {
                            previewContainer.innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #dc3545;">
                                    <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i>
                                    <h3>PDF Load Error</h3>
                                    <p>Failed to load PDF file. Please upload again.</p>
                                    <button onclick="window.location.href='edit-pdf.html'" style="margin-top: 20px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                        Upload PDF Again
                                    </button>
                                </div>
                            `;
                        }
                    }
                } else {
                    // No PDF found at all
                    console.warn('No PDF found in sessionStorage');
                    if (previewContainer) {
                        previewContainer.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #6c757d;">
                                <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 20px; opacity: 0.5;"></i>
                                <h3>No PDF Found</h3>
                                <p>Please upload a PDF file to get started.</p>
                                <button onclick="window.location.href='edit-pdf.html'" style="margin-top: 20px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                    Upload PDF
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error checking for stored PDF:', error);
            }
        }
        
        // Load PDF from Base64 string
        async function loadPDFFromBase64(base64String) {
            try {
                showLoading('Loading PDF...', 10);
                
                // Remove data URL prefix if present
                let base64 = base64String;
                if (base64String.startsWith('data:application/pdf;base64,')) {
                    base64 = base64String.split(',')[1];
                }
                
                // Convert base64 to ArrayBuffer
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const arrayBuffer = bytes.buffer;
                
                updateProgress(50, 'Rendering PDF...');
                await renderPDF(arrayBuffer);
                
                // Store in sessionStorage for persistence
                const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                const blobURL = URL.createObjectURL(blob);
                sessionStorage.setItem('pdfFileURL', blobURL);
                
                hideLoading();
                return true;
            } catch (error) {
                console.error('Error loading PDF from base64:', error);
                hideLoading();
                showError('Failed to load PDF: ' + error.message);
                return false;
            }
        }
        
        // Reload PDF after edits (refreshes display with updated PDF)
        // Reload PDF page using backend /page/render (NO PDF.js, NO overlay)
        async function reloadPDF() {
            try {
                if (currentSessionId) {
                    // Use backend /page/render to reload current page
                    await renderPage(window.pdfEditorVars.currentPage || 1);
                    return true;
                }
                
                // If no session, try to start one from stored data
                if (window.pdfEditorVars.currentPdfData || window.pdfEditorVars.currentPdfBuffer) {
                    await renderPDF();
                    return true;
                }
                
                throw new Error('No PDF session or data available to reload');
            } catch (error) {
                console.error('Error reloading PDF:', error);
                showError('Failed to reload PDF: ' + error.message);
                return false;
            }
        }
        
        // Show error message to user
        function showError(message) {
            hideLoading();
            alert('Error: ' + message);
            console.error('PDF Editor Error:', message);
        }
        
        // Safe base64 encoder to avoid call stack overflow
        function bufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            const chunkSize = 0x8000; // 32KB chunks to avoid stack overflow
            for (let i = 0; i < bytes.length; i += chunkSize) {
                const chunk = bytes.subarray(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }
        
        // Render PDF using backend session (NO PDF.js - uses /page/render)
        async function renderPDF(pdfData) {
            try {
                // If we already have a session, just render the current page
                if (currentSessionId) {
                    await renderPage(window.pdfEditorVars.currentPage || 1);
                    return;
                }
                
                // Need to start a new session with backend
                if (!pdfData) {
                    if (window.pdfEditorVars.currentPdfBuffer) {
                        pdfData = window.pdfEditorVars.currentPdfBuffer.slice(0);
                    } else if (window.pdfEditorVars.currentPdfData && window.pdfEditorVars.currentPdfData.startsWith('data:')) {
                        const base64 = window.pdfEditorVars.currentPdfData.split(',')[1];
                        const binaryString = atob(base64);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        pdfData = bytes.buffer;
                    } else {
                        throw new Error('No PDF data available to render');
                    }
                }
                
                // Convert ArrayBuffer to Blob for FormData
                let pdfBlob;
                if (pdfData instanceof ArrayBuffer) {
                    pdfBlob = new Blob([pdfData], { type: 'application/pdf' });
                } else if (pdfData instanceof Blob) {
                    pdfBlob = pdfData;
                } else {
                    throw new Error('Invalid PDF data format');
                }
                
                // Start session with backend
                const { startSession } = await import('./js/pdf-editor-api.js');
                const sessionResult = await startSession(pdfBlob);
                
                currentSessionId = sessionResult.session_id;
                window.pdfEditorVars.sessionId = currentSessionId;
                window.pdfEditorVars.totalPages = sessionResult.page_count;
                
                // Store PDF data
                if (pdfData instanceof ArrayBuffer) {
                    window.pdfEditorVars.currentPdfBuffer = new Uint8Array(pdfData).buffer;
                    const base64 = bufferToBase64(pdfData);
                    window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                }
                
                // Ensure preview container is visible BEFORE rendering
                if (previewContainer) {
                    previewContainer.style.display = 'flex';
                    previewContainer.style.visibility = 'visible';
                    previewContainer.style.minHeight = '600px';
                    previewContainer.style.opacity = '1';
                }
                if (pdfPageWrapper) {
                    pdfPageWrapper.style.display = 'block';
                    pdfPageWrapper.style.visibility = 'visible';
                    pdfPageWrapper.style.opacity = '1';
                    pdfPageWrapper.setAttribute('data-loaded', 'true');
                }
                if (pdfCanvas) {
                    pdfCanvas.style.display = 'block';
                    pdfCanvas.style.visibility = 'visible';
                }
                
                if (pageCount) pageCount.textContent = sessionResult.page_count;
                
                // Render first page using backend
                await renderPage(1);
                updatePageButtons();
                
                if (downloadBtn) downloadBtn.disabled = false;
                
                console.log('PDF session started and rendered successfully');
                console.log('Preview container visible:', previewContainer ? previewContainer.style.display : 'not found');
                console.log('Canvas visible:', pdfCanvas ? pdfCanvas.style.display : 'not found');
                
            } catch (error) {
                console.error('Error rendering PDF:', error);
                showError('Error rendering PDF: ' + error.message);
            }
        }
        
        // Render specific page using backend /page/render (NO PDF.js)
        async function renderPage(pageNumber) {
            try {
                if (!currentSessionId) {
                    console.warn('No session ID available for backend rendering');
                    showError('Please upload PDF first to start a session');
                    return;
                }
                
                // Always use backend rendering
                const { renderPage: renderPageBackend } = await import('./js/pdf-editor-api.js');
                const zoom = window.pdfEditorVars.scale || 1.5;
                
                // Fetch PNG from backend
                const imageUrl = await renderPageBackend(currentSessionId, pageNumber, zoom);
                
                // Display rendered PNG image on canvas
                if (pdfCanvas) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    await new Promise((resolve, reject) => {
                        img.onload = function() {
                            try {
                                const ctx = pdfCanvas.getContext('2d');
                                pdfCanvas.width = img.width;
                                pdfCanvas.height = img.height;
                                ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                                ctx.drawImage(img, 0, 0);
                                
                                // Ensure preview container is visible
                                const previewContainerEl = document.getElementById('preview-container');
                                const pdfPageWrapperEl = document.getElementById('pdf-page-wrapper');
                                
                                if (previewContainerEl) {
                                    previewContainerEl.style.display = 'flex';
                                    previewContainerEl.style.visibility = 'visible';
                                }
                                if (pdfPageWrapperEl) {
                                    pdfPageWrapperEl.style.display = 'block';
                                    pdfPageWrapperEl.style.visibility = 'visible';
                                }
                                
                                // Clean up object URL
                                if (imageUrl.startsWith('blob:') || imageUrl.startsWith('data:')) {
                                    URL.revokeObjectURL(imageUrl);
                                }
                                
                                console.log('â Page rendered successfully:', pageNumber);
                                resolve();
                            } catch (error) {
                                console.error('Error drawing image to canvas:', error);
                                reject(error);
                            }
                        };
                        img.onerror = function(error) {
                            console.error('Error loading image:', error);
                            reject(new Error('Failed to load rendered image: ' + error));
                        };
                        img.src = imageUrl;
                    });
                } else {
                    console.error('â PDF canvas element not found!');
                    throw new Error('PDF canvas element not found');
                }
                
                // No overlay layers - pure backend rendering
                if (pageNum) pageNum.textContent = pageNumber;
                window.pdfEditorVars.currentPage = pageNumber;
                
                // Update page buttons
                updatePageButtons();
                
            } catch (error) {
                console.error('Error rendering page from backend:', error);
                showError('Failed to render page: ' + error.message);
            }
        }
        
        // Apply OCR texts to PDF natively
        async function applyOCRTextsToPDF() {
            try {
                if (!window.pdfEditorVars.ocrTextsForPDF || window.pdfEditorVars.ocrTextsForPDF.length === 0) {
                    return;
                }
                
                const currentPdfData = window.pdfEditorVars.currentPdfData;
                if (!currentPdfData) {
                    throw new Error('No PDF loaded');
                }
                
                let apiUrl = '/api/pdf/edit';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit';
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: currentPdfData,
                        edits: {
                            ocrTexts: window.pdfEditorVars.ocrTextsForPDF
                        }
                    })
                });
                
                if (response.success) {
                    const result = response;
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    await reloadPDF();
                    window.pdfEditorVars.ocrTextsForPDF = []; // Clear after embedding
                } else {
                    throw new Error(result.error || 'Failed to embed OCR text');
                }
            } catch (error) {
                console.error('Error applying OCR texts:', error);
                showError('Failed to embed OCR text: ' + error.message);
            }
        }
        
        // Apply native text edit using pdf-lib backend (NO HTML overlays - direct PDF editing)
        // Sends text edits to /api/pdf/edit-text endpoint for actual PDF modification
        async function applyNativeTextEdit(editData) {
            try {
                let { pageIndex, oldText, newText, x, y, fontSize, fontName, fontColor } = editData;
                
                // Use font properties from properties panel if not provided
                if (!fontSize && fontSizeInput) {
                    fontSize = parseFloat(fontSizeInput.value) || 12;
                }
                if (!fontName && fontFamilySelect) {
                    fontName = fontFamilySelect.value || 'Helvetica';
                }
                if (!fontColor && textColorInput) {
                    const hexColor = textColorInput.value || '#000000';
                    const rgbColor = hexToRgb(hexColor);
                    fontColor = [rgbColor.r, rgbColor.g, rgbColor.b];
                } else if (fontColor && typeof fontColor === 'string' && fontColor.startsWith('#')) {
                    // Convert hex to RGB if needed
                    const rgbColor = hexToRgb(fontColor);
                    fontColor = [rgbColor.r, rgbColor.g, rgbColor.b];
                }
                
                // Get file ID for backend editing
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                
                if (!fileId) {
                    showError('No file ID available. Please upload PDF first.');
                    return false;
                }
                
                showLoading('Applying text edit to PDF using pdf-lib...', 30);
                
                updateProgress(50, 'Sending edit to server...');
                
                // Determine if this is a replacement or new text
                const isReplacement = oldText && newText && oldText !== newText;
                
                // Prepare request body for /api/pdf/edit-text endpoint
                const requestBody = {
                    fileId: fileId
                };
                
                if (isReplacement) {
                    // Text replacement: send as textReplacements
                    requestBody.textReplacements = [{
                        pageIndex: pageIndex || 0,
                        oldText: oldText,
                        newText: newText,
                        x: x || 0,
                        y: y || 0,
                        fontSize: fontSize || 12,
                        fontName: fontName || 'Helvetica',
                        fontColor: fontColor || [0, 0, 0]
                    }];
                } else {
                    // New text: send as textEdits
                    requestBody.textEdits = [{
                        pageIndex: pageIndex || 0,
                        x: x || 0,
                        y: y || 0,
                        text: newText || '',
                        fontSize: fontSize || 12,
                        fontName: fontName || 'Helvetica',
                        fontColor: fontColor || [0, 0, 0]
                    }];
                }
                
                // Send text edits to /api/pdf/edit-text endpoint for actual PDF modification
                const apiBaseUrl = getApiBaseUrl();
                const apiUrl = `${apiBaseUrl}/api/pdf/edit-text`;
                
                updateProgress(60, 'Sending edit to server...');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Server error: ' + response.status);
                }
                
                updateProgress(70, 'Processing edit with pdf-lib...');
                const result = await response.json();
                
                // Wait for backend confirmation before updating the UI
                if (result.success) {
                    updateProgress(90, 'Reloading page from backend...');
                    // Re-render page using backend /page/render (NO overlay, native changes)
                    await renderPage(window.pdfEditorVars.currentPage || 1);
                    updateProgress(100, 'Edit applied successfully!');
                    setTimeout(() => {
                        hideLoading();
                    }, 300);
                    return true;
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Native text edit error:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error applying text edit: ' + error.message);
                return false;
            }
        }
        
        /* Overlay functions removed - using native PDF editing only */
        
        // Delete text element - Native PDF editing using backend API
        async function deleteTextElement(element) {
            if (!element) return;
            
            if (!currentSessionId) {
                showError('No active PDF session. Please upload PDF first.');
                return;
            }
            
            const x = parseFloat(element.style.left) || 0;
            const y = parseFloat(element.style.top) || 0;
            const fontSize = parseFloat(element.style.fontSize) || 12;
            const textWidth = element.offsetWidth || Math.max(element.textContent.length * fontSize * 0.6, 20);
            const textHeight = Math.max(fontSize * 1.2, fontSize);
            
            // Apply deletion directly to PDF using backend API
            try {
                showLoading('Deleting text from PDF...', 10);
                
                // Get current user ID
                const userId = await getCurrentUserId();
                
                // Import backend API
                const { deleteText } = await import('./js/pdf-editor-api.js');
                
                updateProgress(30, 'Sending deletion to server...');
                
                // Calculate bbox [x0, y0, x1, y1]
                const bbox = [x, y, x + textWidth, y + textHeight];
                
                await deleteText(
                    currentSessionId,
                    window.pdfEditorVars.currentPage,
                    bbox,
                    userId
                );
                
                updateProgress(90, 'Reloading page from backend...');
                
                // Re-render page using backend /page/render to show changes (NO overlay)
                await renderPage(window.pdfEditorVars.currentPage);
                
                updateProgress(100, 'Text deleted successfully!');
                setTimeout(() => {
                    hideLoading();
                }, 300);
            } catch (error) {
                console.error('Error deleting text:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error deleting text: ' + error.message);
            }
            
            // Remove element from view
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            
            if (window.pdfEditorVars.selectedTextElement === element) {
                window.pdfEditorVars.selectedTextElement = null;
            }
        }
        
        // Fast Server-Side OCR
        if (ocrBtn) {
            ocrBtn.addEventListener('click', async function() {
                console.log('OCR button clicked');
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Starting OCR...', 5);
                    updateProgress(10, 'Getting page image from backend...');
                    
                    // Use backend /page/render to get PNG image (NO PDF.js)
                    if (!currentSessionId) {
                        throw new Error('No active PDF session');
                    }
                    
                    const { renderPage: renderPageBackend } = await import('./js/pdf-editor-api.js');
                    const imageUrl = await renderPageBackend(currentSessionId, window.pdfEditorVars.currentPage, 2.0);
                    
                    // Convert image URL to data URL for OCR
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    const imageData = await new Promise((resolve, reject) => {
                        img.onload = function() {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            resolve(canvas.toDataURL('image/png'));
                            URL.revokeObjectURL(imageUrl);
                        };
                        img.onerror = reject;
                        img.src = imageUrl;
                    });
                    
                    updateProgress(30, 'Image ready for OCR...');
                    
                    updateProgress(40, 'Sending to OCR service...');
                    
                    let result = null;
                    let useClientSideOCR = false;
                    
                    // Skip old API endpoint - use backend OCR directly
                    useClientSideOCR = true;
                    
                    // Use backend OCR
                    if (useClientSideOCR || !result) {
                        updateProgress(50, 'Using server-side OCR...');
                        console.log('Starting server-side OCR...');
                        try {
                            // Call backend OCR API
                            const { ocrPage } = await import('./js/pdf-editor-api.js');
                            if (!currentSessionId) {
                                throw new Error('No active PDF session. Please upload PDF first.');
                            }
                            
                            const currentPage = window.pdfEditorVars?.currentPage || 1;
                            
                            const userId = await getCurrentUserId();
                            const ocrResult = await ocrPage(currentSessionId, currentPage, userId);
                            
                            updateProgress(95, 'Processing OCR results...');
                            
                            // Backend returns 'results' not 'texts'
                            const ocrTexts = ocrResult.results || ocrResult.texts || [];
                            
                            if (!ocrTexts || ocrTexts.length === 0) {
                                throw new Error('No text found in the image');
                            }
                            
                            result = {
                                success: true,
                                text: ocrTexts.map(t => t.text || '').join(' '),
                                words: ocrTexts.map(word => {
                                    // Handle bbox format - can be array of 4 points or [x0, y0, x1, y1]
                                    let bbox = word.bbox || [];
                                    let x0 = 0, y0 = 0, x1 = 0, y1 = 0;
                                    
                                    if (Array.isArray(bbox)) {
                                        if (bbox.length === 4 && typeof bbox[0] === 'number') {
                                            // [x0, y0, x1, y1]
                                            [x0, y0, x1, y1] = bbox;
                                        } else if (bbox.length === 4 && Array.isArray(bbox[0])) {
                                            // [[x0,y0], [x1,y1], [x2,y2], [x3,y3]]
                                            const xs = bbox.map(p => p[0]);
                                            const ys = bbox.map(p => p[1]);
                                            x0 = Math.min(...xs);
                                            y0 = Math.min(...ys);
                                            x1 = Math.max(...xs);
                                            y1 = Math.max(...ys);
                                        }
                                    }
                                    
                                    return {
                                        text: word.text || '',
                                        boundingBox: {
                                            x: x0,
                                            y: y0,
                                            width: x1 - x0,
                                            height: y1 - y0
                                        },
                                        confidence: word.confidence || 0.9
                                    };
                                }),
                                method: 'Server-Side OCR'
                            };
                        } catch (ocrError) {
                            console.error('OCR error:', ocrError);
                            hideLoading();
                            const errorMsg = ocrError.message || 'OCR processing failed. Please try again or check your internet connection.';
                            alert(errorMsg);
                            return;
                        }
                    }
                    
                    if (result && result.success && result.words && result.words.length > 0) {
                        // Process OCR results and embed directly into PDF (Native editing - NO HTML overlays)
                        updateProgress(95, 'Embedding OCR text into PDF natively...');
                        
                        // Get PDF page dimensions from canvas (backend rendered PNG)
                        const pdfPageHeight = pdfCanvas.height;
                        const pdfPageWidth = pdfCanvas.width;
                        
                        // Image dimensions (OCR was done on 2.0x scale image)
                        const imageWidth = pdfCanvas.width;
                        const imageHeight = pdfCanvas.height;
                        
                        // Prepare text edits for native PDF embedding using pdf-lib
                        const textEdits = [];
                        
                        result.words.forEach((word) => {
                            if (word.text && word.boundingBox && word.text.trim()) {
                                // Convert image coordinates to PDF coordinates
                                // Image: top-left origin, Y increases downward
                                // PDF: bottom-left origin, Y increases upward
                                
                                let imageX = word.boundingBox.x || 0;
                                let imageY = word.boundingBox.y || 0;
                                
                                // Handle different coordinate formats
                                if (word.pdfCoordinates) {
                                    // Use PDF coordinates if available (from server OCR)
                                    imageX = word.pdfCoordinates.x || imageX;
                                    imageY = word.pdfCoordinates.y || imageY;
                                } else {
                                    // Convert from image coordinates
                                    // Normalize to 0-1 range
                                    const normalizedX = imageX / imageWidth;
                                    const normalizedY = 1 - ((imageY + (word.boundingBox.height || 12)) / imageHeight);
                                    
                                    // Map to PDF coordinates
                                    imageX = normalizedX * pdfPageWidth;
                                    imageY = normalizedY * pdfPageHeight;
                                }
                                
                                // Calculate font size based on bounding box height
                                const fontSize = Math.max(8, Math.min(20, (word.boundingBox.height || 12) * (pdfPageHeight / imageHeight)));
                                
                                textEdits.push({
                                    pageIndex: window.pdfEditorVars.currentPage - 1,
                                    x: imageX,
                                    y: imageY,
                                    text: word.text.trim(),
                                    fontSize: fontSize,
                                    fontName: 'Helvetica',
                                    fontColor: [0, 0, 0] // Black
                                });
                            }
                        });
                        
                        if (textEdits.length > 0) {
                            // Use backend session-based text add API
                            if (!currentSessionId) {
                                throw new Error('No active PDF session. Please upload PDF first.');
                            }
                            
                            // Add each OCR text using backend /text/add API
                            updateProgress(98, 'Applying OCR text to PDF natively...');
                            
                            const { addText } = await import('./js/pdf-editor-api.js');
                            const userId = await getCurrentUserId();
                            
                            let addedCount = 0;
                            for (const textEdit of textEdits) {
                                try {
                                    await addText(
                                        currentSessionId,
                                        textEdit.pageIndex + 1,
                                        textEdit.x,
                                        textEdit.y,
                                        textEdit.text,
                                        textEdit.fontName || 'Helvetica',
                                        textEdit.fontSize || 12,
                                        textEdit.fontColor || [0, 0, 0],
                                        userId
                                    );
                                    addedCount++;
                                    
                                    // Track expected text for validation
                                    if (!window.pdfEditorVars.expectedTexts) {
                                        window.pdfEditorVars.expectedTexts = [];
                                    }
                                    window.pdfEditorVars.expectedTexts.push(textEdit.text);
                                } catch (addError) {
                                    console.warn('Failed to add OCR text:', textEdit.text, addError);
                                }
                            }
                            
                            updateProgress(100, 'OCR text embedded natively into PDF!');
                            
                            // Reload PDF to show native changes
                            await renderPage(window.pdfEditorVars.currentPage);
                            
                            setTimeout(() => {
                                hideLoading();
                                alert(`â OCR completed! ${addedCount} words embedded into PDF natively. Text is now part of the PDF structure.`);
                            }, 500);
                        } else {
                            hideLoading();
                            alert('OCR completed but no valid text found to embed.');
                        }
                    } else {
                        hideLoading();
                        alert('OCR completed but no text found.');
                    }
                } catch (error) {
                    console.error('OCR error:', error);
                    hideLoading();
                    alert('Error performing OCR: ' + error.message);
                }
            });
        }
        
        // Fast OCR removed - OCR functionality merged into single OCR button
        
        // Download with server processing - Returns edited PDF
        if (downloadBtn) {
            downloadBtn.addEventListener('click', async function() {
                console.log('Download button clicked');
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Preparing download...', 10);
                    
                    // Get file ID from sessionStorage
                    const fileId = sessionStorage.getItem('pdfFileId') || window.pdfEditorVars.currentFileId;
                    
                    if (fileId) {
                        // Use fileId-based download endpoint (returns edited PDF)
                        updateProgress(30, 'Fetching edited PDF from server...');
                        
                        const apiBaseUrl = getApiBaseUrl();
                        const downloadUrl = `${apiBaseUrl}/api/pdf/download/${fileId}`;
                        
                        const response = await fetch(downloadUrl);
                        
                        if (!response.ok) {
                            throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                        }
                        
                        updateProgress(70, 'Receiving PDF data...');
                        
                        // Get PDF as blob
                        const pdfBlob = await response.blob();
                        
                        updateProgress(90, 'Preparing download...');
                        
                        // Validate exported PDF contains actual text objects (not images)
                        const expectedTexts = window.pdfEditorVars.expectedTexts || [];
                        if (expectedTexts.length > 0) {
                            try {
                                updateProgress(92, 'Validating exported PDF...');
                                const { validatePDF } = await import('./js/pdf-editor-api.js');
                                const validationResult = await validatePDF(
                                    pdfBlob,
                                    expectedTexts,
                                    window.pdfEditorVars.currentPage
                                );
                                
                                // Log validation result to console for debugging
                                console.group('ð PDF Export Validation');
                                console.log('â Validation completed:', validationResult.valid ? 'PASS' : 'FAIL');
                                console.log('ð Summary:', validationResult.summary);
                                console.log('ð Results:', validationResult.results);
                                
                                if (validationResult.valid) {
                                    console.log('â All expected texts found in exported PDF (actual text objects, not images)');
                                } else {
                                    console.warn('â ï¸ Some expected texts not found in exported PDF');
                                    const missing = validationResult.results.filter(r => !r.found);
                                    console.warn('Missing texts:', missing.map(r => r.text));
                                }
                                console.groupEnd();
                                
                                updateProgress(95, validationResult.valid ? 'Validation passed!' : 'Validation warning');
                            } catch (validationError) {
                                console.warn('Validation error (non-blocking):', validationError);
                                // Don't block download if validation fails
                            }
                        } else {
                            console.log('â¹ï¸ No expected texts to validate (no edits made yet)');
                        }
                        
                        // Create download link
                        const url = URL.createObjectURL(pdfBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        
                        // Get filename from response headers or use default
                        const contentDisposition = response.headers.get('Content-Disposition');
                        let filename = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        if (contentDisposition) {
                            const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
                            if (filenameMatch) {
                                filename = filenameMatch[1];
                            }
                        }
                        
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully:', filename);
                        }, 500);
                    } else {
                        // Use backend /export endpoint for session-based export
                        updateProgress(20, 'Exporting PDF from backend session...');
                        
                        if (!currentSessionId) {
                            throw new Error('No active PDF session');
                        }
                        
                        const { exportPDF } = await import('./js/pdf-editor-api.js');
                        const userId = await getCurrentUserId();
                        
                        // Export PDF from backend
                        const exportResult = await exportPDF(currentSessionId, 'pdf', userId);
                        
                        // Get exported PDF blob for validation
                        updateProgress(70, 'Receiving exported PDF...');
                        const { getBackendUrl } = await import('./js/pdf-editor-api.js');
                        const backendUrl = getBackendUrl();
                        const exportResponse = await fetch(`${backendUrl}/export`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                session_id: currentSessionId,
                                format: 'pdf'
                            })
                        });
                        
                        if (!exportResponse.ok) {
                            throw new Error('Export failed');
                        }
                        
                        const pdfBlob = await exportResponse.blob();
                        
                        // Validate exported PDF contains actual text objects (not images)
                        const expectedTexts = window.pdfEditorVars.expectedTexts || [];
                        if (expectedTexts.length > 0) {
                            try {
                                updateProgress(85, 'Validating exported PDF...');
                                const { validatePDF } = await import('./js/pdf-editor-api.js');
                                const validationResult = await validatePDF(
                                    pdfBlob,
                                    expectedTexts,
                                    window.pdfEditorVars.currentPage
                                );
                                
                                // Log validation result to console for debugging
                                console.group('ð PDF Export Validation');
                                console.log('â Validation completed:', validationResult.valid ? 'PASS' : 'FAIL');
                                console.log('ð Summary:', validationResult.summary);
                                console.log('ð Results:', validationResult.results);
                                
                                if (validationResult.valid) {
                                    console.log('â All expected texts found in exported PDF (actual text objects, not images)');
                                } else {
                                    console.warn('â ï¸ Some expected texts not found in exported PDF');
                                    const missing = validationResult.results.filter(r => !r.found);
                                    console.warn('Missing texts:', missing.map(r => r.text));
                                }
                                console.groupEnd();
                                
                                updateProgress(92, validationResult.valid ? 'Validation passed!' : 'Validation warning');
                            } catch (validationError) {
                                console.warn('Validation error (non-blocking):', validationError);
                                // Don't block download if validation fails
                            }
                        } else {
                            console.log('â¹ï¸ No expected texts to validate (no edits made yet)');
                        }
                        
                        updateProgress(95, 'Preparing download...');
                        
                        // Create download link
                        const url = URL.createObjectURL(pdfBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = sessionStorage.getItem('pdfFileName') || 'edited-document.pdf';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        updateProgress(100, 'Download complete!');
                        setTimeout(() => {
                            hideLoading();
                            console.log('PDF downloaded successfully');
                        }, 500);
                    }
                } catch (error) {
                    console.error('Download error:', error);
                    hideLoading();
                    alert('Error downloading PDF: ' + error.message);
                }
            });
        }
        
        // Save to Cloud
        if (saveCloudBtn) {
            saveCloudBtn.addEventListener('click', async function() {
                alert('Cloud save feature - Coming soon! This will save your PDF to Google Drive/Dropbox.');
            });
        }
        
        // Page navigation
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage > 1) {
                    window.pdfEditorVars.currentPage--;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage < window.pdfEditorVars.totalPages) {
                    window.pdfEditorVars.currentPage++;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        function updatePageButtons() {
            if (prevPageBtn) prevPageBtn.disabled = window.pdfEditorVars.currentPage <= 1;
            if (nextPageBtn) nextPageBtn.disabled = window.pdfEditorVars.currentPage >= window.pdfEditorVars.totalPages;
        }
        
        // Delete text button
        if (deleteTextBtn) {
            deleteTextBtn.addEventListener('click', function() {
                if (window.pdfEditorVars.selectedTextElement) {
                    deleteTextElement(window.pdfEditorVars.selectedTextElement);
                } else {
                    alert('Please select a text element to delete.');
                }
            });
        }
        
        // Add Text button
        if (addTextBtn) {
            addTextBtn.addEventListener('click', function() {
                console.log('Add Text button clicked');
                window.pdfEditorVars.activeTool = 'text';
                if (addTextBtn) addTextBtn.classList.add('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                // Add text on canvas click
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                    pdfCanvas.addEventListener('click', addTextOnCanvas, { once: true });
                }
            });
        }
        
        // Add Image button
        if (addImageBtn) {
            addImageBtn.addEventListener('click', function() {
                console.log('Add Image button clicked');
                window.pdfEditorVars.activeTool = 'image';
                if (addImageBtn) addImageBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (imageInput) {
                    imageInput.click();
                }
            });
        }
        
        // Highlight button
        if (highlightBtn) {
            highlightBtn.addEventListener('click', function() {
                console.log('Highlight button clicked');
                window.pdfEditorVars.activeTool = 'highlight';
                if (highlightBtn) highlightBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
            });
        }
        
        // Select tool
        if (selectTool) {
            selectTool.addEventListener('click', function() {
                console.log('Select tool clicked');
                window.pdfEditorVars.activeTool = 'select';
                if (selectTool) selectTool.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                }
            });
        }
        
        // Native PDF Text Editing - No HTML Overlays!
        // Edits are applied directly to PDF and re-rendered
        // Multi-line text editing (HIGH PRIORITY)
        let textEditDialog = null;
        let textEditTextarea = null;
        let textEditPosition = null;
        
        // Create multi-line text editing dialog
        function createTextEditDialog(x, y) {
            // Remove existing dialog if any
            if (textEditDialog) {
                textEditDialog.remove();
            }
            
            // Create dialog
            textEditDialog = document.createElement('div');
            textEditDialog.className = 'text-edit-dialog';
            // Position dialog in center of canvas or at click position (relative to canvas)
            const canvasRect = pdfCanvas ? pdfCanvas.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            const dialogX = x ? (canvasRect.left + Math.min(x, canvasRect.width - 350)) : (canvasRect.left + (canvasRect.width / 2) - 175);
            const dialogY = y ? (canvasRect.top + Math.min(y, canvasRect.height - 200)) : (canvasRect.top + (canvasRect.height / 2) - 100);
            
            textEditDialog.style.cssText = `
                position: fixed;
                left: ${dialogX}px;
                top: ${dialogY}px;
                background: #2d2d2d;
                border: 2px solid #0078d4;
                border-radius: 8px;
                padding: 15px;
                z-index: 10000;
                min-width: 300px;
                max-width: 500px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            // Create textarea for multi-line input
            textEditTextarea = document.createElement('textarea');
            textEditTextarea.className = 'text-edit-textarea';
            textEditTextarea.style.cssText = `
                width: 100%;
                min-height: 100px;
                max-height: 300px;
                padding: 10px;
                background: #1e1e1e;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                color: #e5e5e5;
                font-size: 14px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                resize: vertical;
                outline: none;
            `;
            textEditTextarea.placeholder = 'Enter text (supports multiple lines)...\nPress Ctrl+Enter to save, Esc to cancel';
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 10px;
                margin-top: 10px;
                justify-content: flex-end;
            `;
            
            // Save button
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.cssText = `
                padding: 8px 16px;
                background: #0078d4;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: 600;
            `;
            saveBtn.onclick = () => saveTextEdit();
            
            // Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                padding: 8px 16px;
                background: #3a3a3a;
                color: #e5e5e5;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            `;
            cancelBtn.onclick = () => cancelTextEdit();
            
            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(saveBtn);
            
            textEditDialog.appendChild(textEditTextarea);
            textEditDialog.appendChild(buttonContainer);
            
            // Append to body (fixed positioning relative to viewport)
            document.body.appendChild(textEditDialog);
            textEditTextarea.focus();
            
            // Keyboard shortcuts
            textEditTextarea.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    saveTextEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextEdit();
                }
            });
        }
        
        // Save multi-line text edit
        async function saveTextEdit() {
            if (!textEditTextarea || !textEditPosition) return;
            
            const text = textEditTextarea.value.trim();
            if (!text) {
                cancelTextEdit();
                return;
            }
            
            if (!currentSessionId) {
                alert('No active PDF session. Please upload PDF first.');
                cancelTextEdit();
                return;
            }
            
            try {
                showLoading('Adding text to PDF...', 30);
                
                // Get font properties
                const fontSize = parseFloat(fontSizeInput?.value || 12);
                const fontName = fontFamilySelect?.value || 'Helvetica';
                const fontColor = textColorInput?.value || '#000000';
                
                // Convert hex color to RGB array [0-255]
                const rgbColor = hexToRgb(fontColor);
                const colorArray = [rgbColor.r, rgbColor.g, rgbColor.b];
                
                // Get canvas coordinates
                const rect = pdfCanvas.getBoundingClientRect();
                const canvasX = textEditPosition.x;
                const canvasY = textEditPosition.y;
                
                // Get current user ID
                const userId = await getCurrentUserId();
                
                // Import backend API
                const { addText } = await import('./js/pdf-editor-api.js');
                
                // Add text via backend (for multi-line, add each line separately)
                const lines = text.split('\n');
                const lineHeight = fontSize * 1.2;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const yOffset = i * lineHeight;
                        await addText(
                            currentSessionId,
                            window.pdfEditorVars.currentPage,
                            canvasX,
                            canvasY - yOffset,
                            lines[i],
                            fontName,
                            fontSize,
                            colorArray,
                            userId
                        );
                        
                        // Track expected text for validation
                        if (!window.pdfEditorVars.expectedTexts) {
                            window.pdfEditorVars.expectedTexts = [];
                        }
                        window.pdfEditorVars.expectedTexts.push(lines[i].trim());
                    }
                }
                
                updateProgress(90, 'Reloading PDF...');
                
                // Re-render page to show changes
                await renderPDF();
                
                hideLoading();
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                alert('Error adding text: ' + error.message);
            }
            
            cancelTextEdit();
        }
        
        // Cancel text edit
        function cancelTextEdit() {
            if (textEditDialog) {
                textEditDialog.remove();
                textEditDialog = null;
                textEditTextarea = null;
                textEditPosition = null;
            }
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        async function addTextOnCanvas(e) {
            if (window.pdfEditorVars.activeTool !== 'text') return;
            
            const rect = pdfCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Use multi-line text editing dialog instead of prompt
            textEditPosition = { x, y };
            createTextEditDialog(e.clientX, e.clientY);
            return;
            
            // OLD CODE (replaced with multi-line dialog above):
            // const text = prompt('Enter text:');
            // if (!text) return;
            
            const fontSize = fontSizeInput ? parseInt(fontSizeInput.value) || 12 : 12;
            const fontFamily = fontFamilySelect ? fontFamilySelect.value || 'Helvetica' : 'Helvetica';
            const textColor = textColorInput ? textColorInput.value || '#000000' : '#000000';
            
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255
                ] : [0, 0, 0];
            };
            
            try {
                showLoading('Adding text to PDF...', 10);
                
                // Get current PDF
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(30, 'Loading PDF...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                // Get file ID for backend editing
                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                
                if (!fileId) {
                    showError('No file ID available. Please upload PDF first.');
                    return;
                }
                
                // Apply edit directly to PDF using pdf-lib backend
                updateProgress(50, 'Applying text to PDF with pdf-lib...');
                const apiBaseUrl = getApiBaseUrl();
                const apiUrl = `${apiBaseUrl}/api/pdf/edit-text`;
                
                // Convert hex color to RGB array
                const fontColorRgb = hexToRgb(textColor);
                
                const editResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileId: fileId,
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: x,
                            y: y,
                            text: text,
                            fontSize: fontSize,
                            fontName: fontFamily,
                            fontColor: hexToRgb(textColor)
                        }]
                    })
                });
                
                updateProgress(80, 'Processing with backend...');
                
                if (!editResponse.ok) {
                    const errorData = await editResponse.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Server error: ' + editResponse.status);
                }
                
                const result = await editResponse.json();
                
                // Wait for backend confirmation before updating UI
                if (result.success) {
                    updateProgress(90, 'Reloading PDF...');
                    // Update PDF data and reload (native changes from pdf-lib)
                    // CRITICAL: Only update UI after successful backend edit
                    window.pdfEditorVars.currentPdfData = result.pdfData;
                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                    
                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                    const newUrl = URL.createObjectURL(blob);
                    sessionStorage.setItem('pdfFileURL', newUrl);
                    
                    await reloadPDF();
                    
                    updateProgress(100, 'Text added successfully!');
                    setTimeout(() => {
                        hideLoading();
                    }, 300);
                } else {
                    throw new Error(result.error || 'Failed to add text');
                }
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                // Handle backend errors gracefully
                showError('Error adding text: ' + error.message);
            }
            
            // Reset tool
            window.pdfEditorVars.activeTool = 'select';
            if (pdfCanvas) pdfCanvas.style.cursor = 'default';
            if (addTextBtn) addTextBtn.classList.remove('active');
            if (selectTool) selectTool.classList.add('active');
        }
        
        // Handle image input
        if (imageInput) {
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Add image to canvas at click position
                        if (window.pdfEditorVars.activeTool === 'image' && pdfCanvas) {
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = (window.pdfEditorVars.lastClickX || 100) - rect.left;
                            const y = (window.pdfEditorVars.lastClickY || 100) - rect.top;
                            
                            const imgElement = document.createElement('img');
                            imgElement.src = e.target.result;
                            imgElement.style.position = 'absolute';
                            imgElement.style.left = x + 'px';
                            imgElement.style.top = y + 'px';
                            imgElement.style.maxWidth = '200px';
                            imgElement.style.maxHeight = '200px';
                            
                            // Overlay removed - images are added via backend API, then page reloads
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Track canvas clicks for image placement
        if (pdfCanvas) {
            pdfCanvas.addEventListener('click', function(e) {
                if (window.pdfEditorVars.activeTool === 'image') {
                    window.pdfEditorVars.lastClickX = e.clientX;
                    window.pdfEditorVars.lastClickY = e.clientY;
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && 
                window.pdfEditorVars.selectedTextElement && 
                !window.pdfEditorVars.selectedTextElement.classList.contains('editing')) {
                e.preventDefault();
                deleteTextElement(window.pdfEditorVars.selectedTextElement);
            }
        });
        
        // ========== NEW FEATURES IMPLEMENTATION ==========
        
        // Page Management - Complete Implementation
        const rotate90Btn = document.getElementById('rotate-90-btn');
        const deleteCurrentPageBtn = document.getElementById('delete-current-page-btn');
        const rotatePageBtn = document.getElementById('rotate-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const reorderPagesBtn = document.getElementById('reorder-pages-btn');
        const extractPageBtn = document.getElementById('extract-page-btn');
        
        // Rotate Current Page 90Â°
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Rotating page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    // Page rotation temporarily disabled - backend API not yet implemented
                    // TODO: Implement /page/rotate endpoint in backend
                    hideLoading();
                    alert('Page rotation feature is temporarily unavailable. This feature will be available soon.');
                    return;
                } catch (error) {
                    console.error('Error rotating page:', error);
                    hideLoading();
                    showError('Failed to rotate page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                if (!confirm(`Delete page ${window.pdfEditorVars.currentPage}?`)) {
                    return;
                }
                
                try {
                    showLoading('Deleting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    // Page deletion temporarily disabled - backend API not yet implemented
                    // TODO: Implement /page/delete endpoint in backend
                    hideLoading();
                    alert('Page deletion feature is temporarily unavailable. This feature will be available soon.');
                    return;
                } catch (error) {
                    console.error('Error deleting page:', error);
                    hideLoading();
                    showError('Failed to delete page: ' + error.message);
                }
            });
        }
        
        // Reorder Pages
        if (reorderPagesBtn) {
            reorderPagesBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const totalPages = window.pdfEditorVars.totalPages;
                const currentOrder = Array.from({ length: totalPages }, (_, i) => i);
                const newOrderStr = prompt(`Enter new page order (comma-separated, 1-${totalPages}):\nExample: 3,1,2,4`, currentOrder.map(i => i + 1).join(','));
                
                if (!newOrderStr) return;
                
                try {
                    const newOrder = newOrderStr.split(',').map(s => parseInt(s.trim()) - 1).filter(n => !isNaN(n) && n >= 0 && n < totalPages);
                    
                    if (newOrder.length !== totalPages) {
                        throw new Error('Invalid page order');
                    }
                    
                    showLoading('Reordering pages...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    // Page reordering temporarily disabled - backend API not yet implemented
                    // TODO: Implement /page/reorder endpoint in backend
                    hideLoading();
                    alert('Page reordering feature is temporarily unavailable. This feature will be available soon.');
                    return;
                } catch (error) {
                    console.error('Error reordering pages:', error);
                    hideLoading();
                    showError('Failed to reorder pages: ' + error.message);
                }
            });
        }
        
        // Extract Page
        if (extractPageBtn) {
            extractPageBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const pageNum = window.pdfEditorVars.currentPage;
                if (!confirm(`Extract page ${pageNum} as a new PDF?`)) {
                    return;
                }
                
                try {
                    showLoading('Extracting page...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    // Page extraction temporarily disabled - backend API not yet implemented
                    // TODO: Implement /page/extract endpoint in backend
                    hideLoading();
                    alert('Page extraction feature is temporarily unavailable. This feature will be available soon.');
                    return;
                } catch (error) {
                    console.error('Error extracting page:', error);
                    hideLoading();
                    showError('Failed to extract page: ' + error.message);
                }
            });
        }
        
        // Forms - Complete Implementation
        const fillFormBtn = document.getElementById('fill-form-btn');
        const detectFormBtn = document.getElementById('detect-form-btn');
        
        // Detect Form Fields
        if (detectFormBtn) {
            detectFormBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (detectResponse.ok) {
                        const result = await detectResponse.json();
                        if (result.success && result.formFields) {
                            updateProgress(100, 'Form fields detected!');
                            setTimeout(() => hideLoading(), 300);
                            
                            const fieldsList = result.formFields.map(f => 
                                `- ${f.name} (${f.type}): ${f.value || '(empty)'}`
                            ).join('\n');
                            
                            alert(`Found ${result.formFields.length} form field(s):\n\n${fieldsList}`);
                        } else {
                            alert('No form fields found in this PDF.');
                            hideLoading();
                        }
                    } else {
                        throw new Error('Form detection failed');
                    }
                } catch (error) {
                    console.error('Error detecting form fields:', error);
                    hideLoading();
                    showError('Failed to detect form fields: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    showError('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    // First detect form fields
                    showLoading('Detecting form fields...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(20, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(40, 'Detecting form fields...');
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const detectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`
                        })
                    });
                    
                    if (!detectResponse.ok) {
                        throw new Error('Form detection failed');
                    }
                    
                    const detectResult = await detectResponse.json();
                    if (!detectResult.success || !detectResult.formFields || detectResult.formFields.length === 0) {
                        alert('No form fields found in this PDF.');
                        hideLoading();
                        return;
                    }
                    
                    // Collect form field values from user
                    const formFields = [];
                    for (const field of detectResult.formFields) {
                        let value = prompt(`Enter value for "${field.name}" (${field.type}):`, field.value || '');
                        if (value !== null) {
                            formFields.push({
                                fieldName: field.name,
                                value: value
                            });
                        }
                    }
                    
                    if (formFields.length === 0) {
                        hideLoading();
                        return;
                    }
                    
                    updateProgress(60, 'Filling form fields...');
                    apiUrl = '/api/pdf/forms/fill';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/fill';
                    }
                    
                    const fillResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            formFields: formFields
                        })
                    });
                    
                    updateProgress(80, 'Updating PDF...');
                    
                    if (fillResponse.ok) {
                        const result = await fillResponse.json();
                        if (result.success) {
                            updateProgress(90, 'Rendering...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(pdfData)));
                            window.pdfEditorVars.currentPdfData = `data:application/pdf;base64,${base64}`;
                            
                            await reloadPDF();
                            
                            updateProgress(100, 'Form filled!');
                            setTimeout(() => hideLoading(), 300);
                        } else {
                            throw new Error(result.error || 'Form filling failed');
                        }
                    } else {
                        throw new Error('Form filling request failed');
                    }
                } catch (error) {
                    console.error('Error filling form:', error);
                    hideLoading();
                    showError('Failed to fill form: ' + error.message);
                }
            });
        }
        
        // Annotations - Complete Implementation
        const commentBtn = document.getElementById('comment-btn');
        const stampBtn = document.getElementById('stamp-btn');
        const shapeBtn = document.getElementById('shape-btn');
        
        // Comment Button
        if (commentBtn) {
            commentBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'comment';
                if (commentBtn) commentBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (stampBtn) stampBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Add click handler for comment placement
                pdfCanvas.addEventListener('click', async function addCommentHandler(e) {
                    if (window.pdfEditorVars.activeTool === 'comment') {
                        pdfCanvas.removeEventListener('click', addCommentHandler);
                        const rect = pdfCanvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const commentText = prompt('Enter your comment:');
                        if (commentText) {
                            const comment = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: commentText,
                                author: 'User'
                            };
                            
                            // Apply comment directly to PDF (native editing - NO HTML overlay)
                            try {
                                showLoading('Adding comment to PDF...', 10);
                                
                                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                if (!pdfFileURL) throw new Error('PDF file not found');
                                
                                updateProgress(30, 'Loading PDF...');
                                const response = await fetch(pdfFileURL);
                                const pdfArrayBuffer = await response.arrayBuffer();
                                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                
                                updateProgress(50, 'Applying comment...');
                                let apiUrl = '/api/pdf/edit-native';
                                if (window.location.protocol === 'file:') {
                                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                                }
                                
                                const commentResponse = await fetch(apiUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        edit: {
                                            type: 'comment',
                                            data: comment
                                        }
                                    })
                                });
                                
                                updateProgress(80, 'Updating PDF...');
                                
                                if (commentResponse.ok) {
                                    const result = await commentResponse.json();
                                    if (result.success) {
                                        updateProgress(90, 'Rendering...');
                                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                        
                                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                                        const newUrl = URL.createObjectURL(blob);
                                        sessionStorage.setItem('pdfFileURL', newUrl);
                                        
                                        await renderPDF(pdfData);
                                        
                                        updateProgress(100, 'Comment added!');
                                        setTimeout(() => hideLoading(), 300);
                                        
                                        // Store in annotations
                                        window.pdfEditorVars.annotations.comments.push(comment);
                                    }
                                }
                            } catch (error) {
                                console.error('Error adding comment:', error);
                                hideLoading();
                            }
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (commentBtn) commentBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }
                }, { once: true });
            });
        }
        
        // Stamp Button
        if (stampBtn) {
            stampBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'stamp';
                if (stampBtn) stampBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (commentBtn) commentBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Show stamp type selection
                const stampType = prompt('Enter stamp type (APPROVED, REJECTED, CONFIDENTIAL, DRAFT, or custom):', 'APPROVED');
                if (stampType) {
                    pdfCanvas.addEventListener('click', function addStampHandler(e) {
                        if (window.pdfEditorVars.activeTool === 'stamp') {
                            pdfCanvas.removeEventListener('click', addStampHandler);
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const stamp = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                stampType: stampType,
                                width: 100,
                                height: 50
                            };
                            
                            window.pdfEditorVars.annotations.stamps.push(stamp);
                            
                            // Store in sessionStorage
                            const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                            if (!storedEdits.stamps) storedEdits.stamps = [];
                            storedEdits.stamps.push(stamp);
                            sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                            
                            // Apply stamp directly to PDF (native editing)
                            (async () => {
                                try {
                                    showLoading('Adding stamp to PDF...', 10);
                                    
                                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                                    if (!pdfFileURL) throw new Error('PDF file not found');
                                    
                                    updateProgress(30, 'Loading PDF...');
                                    const response = await fetch(pdfFileURL);
                                    const pdfArrayBuffer = await response.arrayBuffer();
                                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                                    
                                    updateProgress(50, 'Applying stamp...');
                                    let apiUrl = '/api/pdf/edit';
                                    if (window.location.protocol === 'file:') {
                                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                                    }
                                    
                                    // Use standard edit endpoint for stamps
                                    const stampResponse = await fetch(apiUrl, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                            edits: {
                                                stamps: [stamp]
                                            }
                                        })
                                    });
                                    
                                    updateProgress(80, 'Updating PDF...');
                                    
                                    if (stampResponse.ok) {
                                        const result = await stampResponse.json();
                                        if (result.success) {
                                            updateProgress(90, 'Rendering...');
                                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                            
                                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                                            const newUrl = URL.createObjectURL(blob);
                                            sessionStorage.setItem('pdfFileURL', newUrl);
                                            
                                            await renderPDF(pdfData);
                                            
                                            updateProgress(100, 'Stamp added!');
                                            setTimeout(() => hideLoading(), 300);
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error adding stamp:', error);
                                    hideLoading();
                                }
                            })();
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (stampBtn) stampBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }, { once: true });
                } else {
                    window.pdfEditorVars.activeTool = 'select';
                    if (stampBtn) stampBtn.classList.remove('active');
                }
            });
        }
        
        // Shape Button
        if (shapeBtn) {
            shapeBtn.addEventListener('click', function() {
                const shapeType = prompt('Enter shape type (rectangle, circle, line):', 'rectangle');
                if (shapeType && ['rectangle', 'circle', 'line'].includes(shapeType.toLowerCase())) {
                    window.pdfEditorVars.activeTool = 'shape';
                    window.pdfEditorVars.shapeType = shapeType.toLowerCase();
                    if (shapeBtn) shapeBtn.classList.add('active');
                    if (highlightBtn) highlightBtn.classList.remove('active');
                    if (commentBtn) commentBtn.classList.remove('active');
                    if (stampBtn) stampBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.remove('active');
                    
                    if (pdfCanvas) {
                        pdfCanvas.style.cursor = 'crosshair';
                    }
                }
            });
        }
        
        // Shape drawing (similar to highlight)
        let shapeStartX = null;
        let shapeStartY = null;
        let shapeRect = null;
        
        if (pdfCanvas) {
            const shapeMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    shapeStartX = e.clientX - rect.left;
                    shapeStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Shape will be added to PDF on mouseup
                }
            };
            
            const shapeMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Shape will be drawn directly in PDF on mouseup
                }
            };
            
            const shapeMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - shapeStartX);
                    const height = Math.abs(currentY - shapeStartY);
                    const left = Math.min(shapeStartX, currentX);
                    const top = Math.min(shapeStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const shape = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            shapeType: window.pdfEditorVars.shapeType,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            color: [0, 0, 0],
                            strokeWidth: 2
                        };
                        
                        // Apply shape directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Adding shape to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying shape...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const shapeResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'shape',
                                        data: shape
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (shapeResponse.ok) {
                                const result = await shapeResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Shape added!');
                                    setTimeout(() => hideLoading(), 300);
                                    
                                    // Store in annotations
                                    window.pdfEditorVars.annotations.shapes.push(shape);
                                }
                            }
                        } catch (error) {
                            console.error('Error adding shape:', error);
                            hideLoading();
                        }
                    }
                    
                    // Reset tool
                    window.pdfEditorVars.activeTool = 'select';
                    if (shapeBtn) shapeBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    shapeStartX = null;
                    shapeStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', shapeMouseDown);
            pdfCanvas.addEventListener('mousemove', shapeMouseMove);
            pdfCanvas.addEventListener('mouseup', shapeMouseUp);
        }
        
        // Export - Complete Implementation
        const exportBtn = document.getElementById('export-btn');
        const exportFormatSelect = document.getElementById('export-format-select');
        const exportWordBtn = document.getElementById('export-word-btn');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const exportPptBtn = document.getElementById('export-ppt-btn');
        const exportImageBtn = document.getElementById('export-image-btn');
        
        // Export Function
        async function exportToFormat(format) {
            if (!currentSessionId) {
                alert('No PDF loaded. Please upload a PDF first.');
                return;
            }
            
            try {
                showLoading(`Exporting to ${format.toUpperCase()}...`, 10);
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(20, 'Loading PDF data...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                let apiUrl = '';
                let mimeType = '';
                let fileExtension = '';
                
                switch(format) {
                    case 'word':
                        apiUrl = '/api/pdf/export/word';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        fileExtension = 'docx';
                        break;
                    case 'excel':
                        apiUrl = '/api/pdf/export/excel';
                        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                        fileExtension = 'xlsx';
                        break;
                    case 'powerpoint':
                        apiUrl = '/api/pdf/export/powerpoint';
                        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
                        fileExtension = 'pptx';
                        break;
                    case 'image':
                        apiUrl = '/api/pdf/export/images';
                        mimeType = 'image/png';
                        fileExtension = 'zip';
                        break;
                    default:
                        throw new Error('Unsupported export format');
                }
                
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000' + apiUrl;
                }
                
                updateProgress(40, `Sending to ${format} converter...`);
                const exportResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                });
                
                updateProgress(70, 'Processing export...');
                
                if (exportResponse.ok) {
                    const result = await exportResponse.json();
                    if (result.success) {
                        updateProgress(90, 'Preparing download...');
                        
                        if (format === 'image' && result.images) {
                            alert('Image export creates multiple files. Downloading first image as example.');
                            if (result.images[0]) {
                                const imgBase64 = Buffer.from(result.images[0].image).toString('base64');
                                const imgBytes = Uint8Array.from(atob(imgBase64), c => c.charCodeAt(0));
                                const blob = new Blob([imgBytes], { type: 'image/png' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `page-1.png`;
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                        } else if (result.fileData) {
                            const fileBase64 = result.fileData.split(',')[1] || result.fileData;
                            const fileBytes = Uint8Array.from(atob(fileBase64), c => c.charCodeAt(0));
                            const blob = new Blob([fileBytes], { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `exported-document.${fileExtension}`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                        
                        updateProgress(100, 'Export complete!');
                        setTimeout(() => {
                            hideLoading();
                            alert(`Successfully exported to ${format.toUpperCase()}!`);
                        }, 500);
                    } else {
                        throw new Error(result.error || 'Export failed');
                    }
                } else {
                    throw new Error('Export server error: ' + exportResponse.status);
                }
            } catch (error) {
                console.error('Export error:', error);
                hideLoading();
                alert(`Error exporting to ${format}: ${error.message}`);
            }
        }
        
        // Export Button Event Listeners
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    // Use download function
                    if (downloadBtn) downloadBtn.click();
                } else {
                    await exportToFormat(format);
                }
            });
        }
        
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compression & Merge/Split
        const compressPdfBtn = document.getElementById('compress-pdf-btn');
        const compressionQuality = document.getElementById('compression-quality');
        const compressBtn = document.getElementById('compress-btn');
        const mergeBtn = document.getElementById('merge-btn');
        const splitBtn = document.getElementById('split-btn');
        
        // Extra Functions - Security & Advanced
        const watermarkBtn = document.getElementById('watermark-btn');
        const signBtn = document.getElementById('sign-btn');
        const redactBtn = document.getElementById('redact-btn');
        const protectBtn = document.getElementById('protect-btn');
        
        // Watermark Implementation
        if (watermarkBtn) {
            watermarkBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const watermarkText = prompt('Enter watermark text:', 'CONFIDENTIAL');
                if (!watermarkText) return;
                
                const opacity = prompt('Enter opacity (0.1 to 1.0):', '0.3');
                const opacityValue = parseFloat(opacity) || 0.3;
                
                try {
                    showLoading('Adding watermark...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Applying watermark to all pages...');
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    const watermarkEdits = {
                        textEdits: []
                    };
                    
                    for (let i = 0; i < window.pdfEditorVars.totalPages; i++) {
                        watermarkEdits.textEdits.push({
                            pageIndex: i,
                            x: 200,
                            y: 400,
                            text: watermarkText,
                            fontSize: 48,
                            fontName: 'Helvetica',
                            fontColor: [0.7, 0.7, 0.7]
                        });
                    }
                    
                    const watermarkResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: watermarkEdits
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (watermarkResponse.ok) {
                        const result = await watermarkResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading watermarked PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Watermark added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Watermark added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Watermark failed');
                    }
                } catch (error) {
                    console.error('Watermark error:', error);
                    hideLoading();
                    alert('Error adding watermark: ' + error.message);
                }
            });
        }
        
        // Sign Implementation
        if (signBtn) {
            signBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const signerName = prompt('Enter signer name:', 'Your Name');
                if (!signerName) return;
                
                try {
                    showLoading('Adding digital signature...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Creating signature...');
                    const signatureEdits = {
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 100,
                            text: `Digitally Signed by: ${signerName}\nDate: ${new Date().toLocaleDateString()}`,
                            fontSize: 12,
                            fontName: 'Helvetica',
                            fontColor: [0, 0, 0]
                        }],
                        stamps: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 50,
                            stampType: 'SIGNED',
                            width: 150,
                            height: 50
                        }]
                    };
                    
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    updateProgress(70, 'Applying signature...');
                    const signResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: signatureEdits
                        })
                    });
                    
                    updateProgress(90, 'Processing...');
                    
                    if (signResponse.ok) {
                        const result = await signResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Signature added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Digital signature added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Signature failed');
                    }
                } catch (error) {
                    console.error('Sign error:', error);
                    hideLoading();
                    alert('Error adding signature: ' + error.message);
                }
            });
        }
        
        // Redact Implementation
        if (redactBtn) {
            redactBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'redact';
                if (redactBtn) redactBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                alert('Redact mode activated. Click and drag to select text to redact (black out).');
            });
        }
        
        // Redact drawing
        let redactStartX = null;
        let redactStartY = null;
        let redactRect = null;
        
        if (pdfCanvas && redactBtn) {
            const redactMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    redactStartX = e.clientX - rect.left;
                    redactStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    // Native editing - no HTML overlay, just track coordinates
                    // Redaction will be added to PDF on mouseup
                }
            };
            
            const redactMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    // Native editing - just track coordinates, no HTML overlay
                    // Redaction will be drawn directly in PDF on mouseup
                }
            };
            
            const redactMouseUp = async function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - redactStartX);
                    const height = Math.abs(currentY - redactStartY);
                    const left = Math.min(redactStartX, currentX);
                    const top = Math.min(redactStartY, currentY);
                    
                    if (width > 5 && height > 5) {
                        const redaction = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: left,
                            y: top,
                            width: width,
                            height: height,
                            type: 'redaction'
                        };
                        
                        // Apply redaction directly to PDF (native editing - NO HTML overlay)
                        try {
                            showLoading('Applying redaction to PDF...', 10);
                            
                            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                            if (!pdfFileURL) throw new Error('PDF file not found');
                            
                            updateProgress(30, 'Loading PDF...');
                            const response = await fetch(pdfFileURL);
                            const pdfArrayBuffer = await response.arrayBuffer();
                            const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                            
                            updateProgress(50, 'Applying redaction...');
                            let apiUrl = '/api/pdf/edit-native';
                            if (window.location.protocol === 'file:') {
                                apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                            }
                            
                            const redactResponse = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                    edit: {
                                        type: 'redaction',
                                        data: redaction
                                    }
                                })
                            });
                            
                            updateProgress(80, 'Updating PDF...');
                            
                            if (redactResponse.ok) {
                                const result = await redactResponse.json();
                                if (result.success) {
                                    updateProgress(90, 'Rendering...');
                                    const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                                    
                                    const blob = new Blob([pdfData], { type: 'application/pdf' });
                                    const newUrl = URL.createObjectURL(blob);
                                    sessionStorage.setItem('pdfFileURL', newUrl);
                                    
                                    await renderPDF(pdfData);
                                    
                                    updateProgress(100, 'Redaction applied!');
                                    setTimeout(() => hideLoading(), 300);
                                }
                            }
                        } catch (error) {
                            console.error('Error applying redaction:', error);
                            hideLoading();
                        }
                    }
                    
                    window.pdfEditorVars.activeTool = 'select';
                    if (redactBtn) redactBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    redactStartX = null;
                    redactStartY = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', redactMouseDown);
            pdfCanvas.addEventListener('mousemove', redactMouseMove);
            pdfCanvas.addEventListener('mouseup', redactMouseUp);
        }
        
        // Compression Implementation
        if (compressBtn) {
            compressBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const quality = prompt('Enter compression quality (low/medium/high):', 'medium');
                if (!quality || !['low', 'medium', 'high'].includes(quality.toLowerCase())) {
                    if (quality) alert('Invalid quality. Use: low, medium, or high');
                    return;
                }
                
                try {
                    showLoading('Compressing PDF...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Compressing...');
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            quality: quality.toLowerCase()
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading compressed PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            sessionStorage.setItem('pdfFileBase64', btoa(String.fromCharCode(...new Uint8Array(pdfData))));
                            
                            await renderPDF(pdfData);
                            updateProgress(100, 'PDF compressed!');
                            setTimeout(() => {
                                hideLoading();
                                alert(`PDF compressed successfully!\nOriginal: ${(result.originalSize / 1024).toFixed(2)} KB\nCompressed: ${(result.compressedSize / 1024).toFixed(2)} KB\nReduction: ${result.compressionRatio}%`);
                            }, 500);
                        }
                    } else {
                        throw new Error('Compression failed');
                    }
                } catch (error) {
                    console.error('Compression error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Protect PDF Implementation
        if (protectBtn) {
            protectBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const password = prompt('Enter password to protect PDF:', '');
                if (!password || password.length < 4) {
                    if (password) alert('Password must be at least 4 characters');
                    return;
                }
                
                const confirmPassword = prompt('Confirm password:', '');
                if (password !== confirmPassword) {
                    alert('Passwords do not match!');
                    return;
                }
                
                try {
                    showLoading('Protecting PDF...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Encrypting PDF...');
                    let apiUrl = '/api/pdf/protect';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/protect';
                    }
                    
                    const protectResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            userPassword: password,
                            ownerPassword: password,
                            permissions: {
                                printing: 'highResolution',
                                modifying: false,
                                copying: false,
                                annotating: false,
                                fillingForms: false,
                                contentAccessibility: false,
                                documentAssembly: false
                            }
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (protectResponse.ok) {
                        const result = await protectResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading protected PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            
                            const blob = new Blob([pdfData], { type: 'application/pdf' });
                            const newUrl = URL.createObjectURL(blob);
                            sessionStorage.setItem('pdfFileURL', newUrl);
                            sessionStorage.setItem('pdfFileBase64', btoa(String.fromCharCode(...new Uint8Array(pdfData))));
                            
                            await renderPDF(pdfData);
                            updateProgress(100, 'PDF protected!');
                            setTimeout(() => {
                                hideLoading();
                                alert('PDF protected successfully! Password required to open.');
                            }, 500);
                        }
                    } else {
                        throw new Error('Protection failed');
                    }
                } catch (error) {
                    console.error('Protection error:', error);
                    hideLoading();
                    alert('Error protecting PDF: ' + error.message);
                }
            });
        }
        
        // Rotate Page 90 degrees
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page rotated successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Rotate error:', error);
                    hideLoading();
                    alert('Error rotating page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                if (!confirm('Are you sure you want to delete this page?')) return;
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page deleted successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Delete page error:', error);
                    hideLoading();
                    alert('Error deleting page: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                // First detect form fields
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const fieldsResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                    });
                    
                    if (fieldsResponse.ok) {
                        const result = await fieldsResponse.json();
                        if (result.success && result.formFields && result.formFields.length > 0) {
                            // Show form fill dialog
                            let formHtml = '<div style="padding: 20px;"><h3>Fill Form Fields</h3>';
                            result.formFields.forEach(field => {
                                formHtml += `<div style="margin: 10px 0;">
                                    <label>${field.name} (${field.type}):</label>
                                    <input type="text" id="field-${field.name}" value="${field.value || ''}" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>`;
                            });
                            formHtml += '<button onclick="fillFormSubmit()" style="margin-top: 15px; padding: 10px 20px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer;">Fill Form</button></div>';
                            
                            const formDialog = document.createElement('div');
                            formDialog.id = 'form-fill-dialog';
                            formDialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;';
                            formDialog.innerHTML = formHtml;
                            document.body.appendChild(formDialog);
                            
                            window.fillFormSubmit = async function() {
                                const formFields = result.formFields.map(field => ({
                                    fieldName: field.name,
                                    value: document.getElementById(`field-${field.name}`).value
                                }));
                                
                                let fillUrl = '/api/pdf/forms/fill';
                                if (window.location.protocol === 'file:') {
                                    fillUrl = 'http://localhost:3000/api/pdf/forms/fill';
                                }
                                
                                const fillResponse = await fetch(fillUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        formFields: formFields
                                    })
                                });
                                
                                if (fillResponse.ok) {
                                    const fillResult = await fillResponse.json();
                                    if (fillResult.success) {
                                        const pdfData = await fetch(fillResult.pdfData).then(r => r.arrayBuffer());
                                        await renderPDF(pdfData);
                                        document.body.removeChild(formDialog);
                                        alert('Form filled successfully!');
                                    }
                                }
                                hideLoading();
                            };
                        } else {
                            alert('No form fields found in this PDF.');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Form fill error:', error);
                    hideLoading();
                    alert('Error filling form: ' + error.message);
                }
            });
        }
        
        // Export to Different Formats - Enhanced with Progress
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    if (downloadBtn) downloadBtn.click();
                    return;
                }
                
                await exportToFormat(format);
            });
        }
        
        // Individual Export Buttons
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compress PDF
        if (compressPdfBtn) {
            compressPdfBtn.addEventListener('click', async function() {
                if (!currentSessionId) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            options: { quality: compressionQuality.value }
                        })
                    });
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert(`PDF compressed! Size reduced by ${result.compressionRatio}%`);
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Compress error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Initialize all button event listeners
        function initButtonEventListeners() {
            console.log('Initializing button event listeners...');
            
            // Re-get all button elements to ensure they exist
            const uploadBtn = document.getElementById('upload-btn');
            const downloadBtn = document.getElementById('download-btn');
            const ocrBtn = document.getElementById('ocr-btn');
            const addTextBtn = document.getElementById('add-text-btn');
            const addImageBtn = document.getElementById('add-image-btn');
            const highlightBtn = document.getElementById('highlight-btn');
            const selectTool = document.getElementById('select-tool');
            const fileInput = document.getElementById('file-input');
            const imageInput = document.getElementById('image-input');
            
            // Upload button (single-click, single input dialog)
            const currentFileInput = document.getElementById('file-input');
            if (uploadBtn && currentFileInput) {
                // Remove old listener if exists
                const newUploadBtn = uploadBtn.cloneNode(true);
                uploadBtn.parentNode.replaceChild(newUploadBtn, uploadBtn);
                
                newUploadBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Upload button clicked');
                    try {
                        currentFileInput.click();
                    } catch (error) {
                        console.error('Error clicking file input:', error);
                        alert('Error opening file dialog. Please try again.');
                    }
                });
                console.log('â Upload button listener added');
            } else {
                console.error('â Upload button or file input not found!', { 
                    uploadBtn: !!uploadBtn, 
                    fileInput: !!currentFileInput 
                });
            }
            
            // Download button - already has listener, but verify
            if (downloadBtn) {
                console.log('â Download button found');
            } else {
                console.error('â Download button not found!');
            }
            
            // OCR button - already has listener, but verify
            if (ocrBtn) {
                console.log('â OCR button found');
            } else {
                console.error('â OCR button not found!');
            }
            
            // Add Text button - already has listener, but verify
            if (addTextBtn) {
                console.log('â Add Text button found');
            } else {
                console.error('â Add Text button not found!');
            }
            
            // Add Image button - already has listener, but verify
            if (addImageBtn) {
                console.log('â Add Image button found');
            } else {
                console.error('â Add Image button not found!');
            }
            
            // Highlight button - already has listener, but verify
            if (highlightBtn) {
                console.log('â Highlight button found');
            } else {
                console.error('â Highlight button not found!');
            }
            
            // Select tool - already has listener, but verify
            if (selectTool) {
                console.log('â Select tool found');
            } else {
                console.error('â Select tool not found!');
            }
            
            console.log('Button event listeners initialization complete!');
        }
        
        // Advanced Features Event Listeners
        function initAdvancedFeatures() {
            // Form Detection
            const detectFormBtn = document.getElementById('detect-form-btn');
            if (detectFormBtn) {
                detectFormBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded. Please upload a PDF first.');
                        return;
                    }
                    
                    try {
                        showLoading('Detecting form fields...', 20);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        if (!fileId) {
                            throw new Error('File ID not found');
                        }
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/forms/detect`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fileId: fileId })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success && result.formFields) {
                            hideLoading();
                            alert(`Found ${result.formFields.length} form fields:\n\n` + 
                                result.formFields.map(f => `- ${f.name} (${f.type})`).join('\n'));
                        } else {
                            throw new Error(result.error || 'No form fields found');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error detecting form fields: ' + error.message);
                    }
                });
            }
            
            // Form Filling
            const fillFormBtn = document.getElementById('fill-form-btn');
            if (fillFormBtn) {
                fillFormBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded. Please upload a PDF first.');
                        return;
                    }
                    
                    // First detect form fields
                    const apiBaseUrl = getApiBaseUrl();
                    const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                    
                    if (!fileId) {
                        alert('File ID not found. Please upload PDF first.');
                        return;
                    }
                    
                    try {
                        showLoading('Detecting form fields...', 10);
                        const detectResponse = await fetch(`${apiBaseUrl}/api/pdf/forms/detect`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fileId: fileId })
                        });
                        
                        const detectResult = await detectResponse.json();
                        
                        if (!detectResult.success || !detectResult.formFields || detectResult.formFields.length === 0) {
                            hideLoading();
                            alert('No form fields found in this PDF.');
                            return;
                        }
                        
                        hideLoading();
                        
                        // Create form filling dialog
                        let formHtml = '<div style="max-height: 400px; overflow-y: auto; margin: 10px 0;">';
                        detectResult.formFields.forEach((field, index) => {
                            formHtml += `<div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 5px; font-weight: 600;">${field.name} (${field.type}):</label>`;
                            
                            if (field.type === 'checkbox') {
                                formHtml += `<input type="checkbox" id="form-field-${index}" ${field.value ? 'checked' : ''} style="width: 20px; height: 20px;">`;
                            } else if (field.type === 'radio') {
                                formHtml += `<input type="text" id="form-field-${index}" value="${field.value || ''}" style="width: 100%; padding: 8px; border: 1px solid #3a3a3a; border-radius: 4px; background: #1e1e1e; color: #e5e5e5;">`;
                            } else {
                                formHtml += `<input type="text" id="form-field-${index}" value="${field.value || ''}" style="width: 100%; padding: 8px; border: 1px solid #3a3a3a; border-radius: 4px; background: #1e1e1e; color: #e5e5e5;">`;
                            }
                            formHtml += `</div>`;
                        });
                        formHtml += '</div>';
                        
                        const fillValue = prompt('Fill form fields:\n\n' + formHtml, '');
                        if (fillValue === null) return;
                        
                        // Build form fields array
                        const formFields = detectResult.formFields.map((field, index) => {
                            const input = document.getElementById(`form-field-${index}`);
                            let value;
                            if (field.type === 'checkbox') {
                                value = input ? input.checked : false;
                            } else {
                                value = input ? input.value : '';
                            }
                            return { fieldName: field.name, value: value };
                        });
                        
                        showLoading('Filling form fields...', 50);
                        
                        const fillResponse = await fetch(`${apiBaseUrl}/api/pdf/forms/fill`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fileId: fileId, formFields: formFields })
                        });
                        
                        const fillResult = await fillResponse.json();
                        
                        if (fillResult.success) {
                            window.pdfEditorVars.currentPdfData = fillResult.pdfData;
                            await reloadPDF();
                            hideLoading();
                            alert('Form fields filled successfully!');
                        } else {
                            throw new Error(fillResult.error || 'Failed to fill form');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error filling form: ' + error.message);
                    }
                });
            }
            
            // Page Rotation
            const rotatePageBtn = document.getElementById('rotate-page-btn');
            if (rotatePageBtn) {
                rotatePageBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    const angle = prompt('Enter rotation angle (90, 180, or 270):', '90');
                    if (!angle || !['90', '180', '270'].includes(angle)) {
                        return;
                    }
                    
                    try {
                        showLoading('Rotating page...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/pages/rotate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                rotations: [{
                                    pageIndex: window.pdfEditorVars.currentPage - 1,
                                    angle: parseInt(angle)
                                }]
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            window.pdfEditorVars.currentPdfData = result.pdfData;
                            await reloadPDF();
                            hideLoading();
                            alert('Page rotated successfully!');
                        } else {
                            throw new Error(result.error || 'Rotation failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error rotating page: ' + error.message);
                    }
                });
            }
            
            // Page Deletion
            const deletePageBtn = document.getElementById('delete-page-btn');
            if (deletePageBtn) {
                deletePageBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    if (!confirm(`Delete page ${window.pdfEditorVars.currentPage}?`)) {
                        return;
                    }
                    
                    try {
                        showLoading('Deleting page...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/pages/delete`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                pageIndices: [window.pdfEditorVars.currentPage - 1]
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            window.pdfEditorVars.currentPdfData = result.pdfData;
                            await reloadPDF();
                            hideLoading();
                            alert('Page deleted successfully!');
                        } else {
                            throw new Error(result.error || 'Deletion failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error deleting page: ' + error.message);
                    }
                });
            }
            
            // Redaction
            const redactBtn = document.getElementById('redact-btn');
            if (redactBtn) {
                redactBtn.addEventListener('click', function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    window.pdfEditorVars.activeTool = 'redact';
                    if (redactBtn) redactBtn.classList.add('active');
                    if (pdfCanvas) {
                        pdfCanvas.style.cursor = 'crosshair';
                        pdfCanvas.addEventListener('click', async function redactHandler(e) {
                            if (window.pdfEditorVars.activeTool !== 'redact') {
                                pdfCanvas.removeEventListener('click', redactHandler);
                                return;
                            }
                            
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const width = prompt('Enter redaction width (pixels):', '100');
                            const height = prompt('Enter redaction height (pixels):', '20');
                            
                            if (!width || !height) {
                                pdfCanvas.removeEventListener('click', redactHandler);
                                window.pdfEditorVars.activeTool = 'select';
                                if (redactBtn) redactBtn.classList.remove('active');
                                return;
                            }
                            
                            try {
                                showLoading('Redacting content...', 50);
                                const apiBaseUrl = getApiBaseUrl();
                                const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                                
                                const response = await fetch(`${apiBaseUrl}/api/pdf/redact`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        fileId: fileId,
                                        redactions: [{
                                            pageIndex: window.pdfEditorVars.currentPage - 1,
                                            x: x,
                                            y: y,
                                            width: parseFloat(width),
                                            height: parseFloat(height)
                                        }]
                                    })
                                });
                                
                                const result = await response.json();
                                
                                if (result.success) {
                                    window.pdfEditorVars.currentPdfData = result.pdfData;
                                    await reloadPDF();
                                    hideLoading();
                                    alert('Content redacted successfully!');
                                } else {
                                    throw new Error(result.error || 'Redaction failed');
                                }
                            } catch (error) {
                                hideLoading();
                                alert('Error redacting: ' + error.message);
                            }
                            
                            pdfCanvas.removeEventListener('click', redactHandler);
                            window.pdfEditorVars.activeTool = 'select';
                            if (redactBtn) redactBtn.classList.remove('active');
                            if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                        }, { once: false });
                    }
                });
            }
            
            // Watermark - Disabled (duplicate removed, handled in initButtonEventListeners)
            // Digital Signature - Disabled (duplicate removed, handled in initButtonEventListeners)
            // Export dropdown is handled in initAdvancedFeatures - no duplicate needed
            
            // Export dropdown toggle
            const exportDropdownBtn = document.getElementById('export-dropdown-btn');
            if (exportDropdownBtn && exportDropdown) {
                exportDropdownBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    exportDropdown.style.display = exportDropdown.style.display === 'none' ? 'block' : 'none';
                });
                
                document.addEventListener('click', function(e) {
                    if (!exportDropdownBtn.contains(e.target) && !exportDropdown.contains(e.target)) {
                        exportDropdown.style.display = 'none';
                    }
                });
            }
            
            // Reorder Pages
            const reorderPagesBtn = document.getElementById('reorder-pages-btn');
            if (reorderPagesBtn) {
                reorderPagesBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    const totalPages = window.pdfEditorVars.totalPages;
                    const currentOrder = Array.from({ length: totalPages }, (_, i) => i);
                    const newOrderStr = prompt(`Enter new page order (comma-separated, 1-${totalPages}):\nCurrent: ${currentOrder.map(i => i + 1).join(', ')}`, currentOrder.map(i => i + 1).join(', '));
                    
                    if (!newOrderStr) return;
                    
                    try {
                        const newOrder = newOrderStr.split(',').map(s => parseInt(s.trim()) - 1);
                        if (newOrder.length !== totalPages || newOrder.some(n => isNaN(n) || n < 0 || n >= totalPages)) {
                            throw new Error('Invalid page order');
                        }
                        
                        showLoading('Reordering pages...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/pages/reorder`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fileId: fileId, newOrder: newOrder })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            window.pdfEditorVars.currentPdfData = result.pdfData;
                            await reloadPDF();
                            hideLoading();
                            alert('Pages reordered successfully!');
                        } else {
                            throw new Error(result.error || 'Reorder failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error reordering pages: ' + error.message);
                    }
                });
            }
            
            // Extract Pages
            const extractPageBtn = document.getElementById('extract-page-btn');
            if (extractPageBtn) {
                extractPageBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    const pageNum = window.pdfEditorVars.currentPage;
                    const confirmExtract = confirm(`Extract page ${pageNum} as a new PDF?`);
                    if (!confirmExtract) return;
                    
                    try {
                        showLoading('Extracting page...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/pages/extract`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                pageIndices: [pageNum - 1]
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            hideLoading();
                            const link = document.createElement('a');
                            link.href = result.pdfData;
                            link.download = `page-${pageNum}.pdf`;
                            link.click();
                            alert('Page extracted successfully!');
                        } else {
                            throw new Error(result.error || 'Extraction failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error extracting page: ' + error.message);
                    }
                });
            }
            
            // Add Page
            const addPageBtn = document.getElementById('add-page-btn');
            if (addPageBtn) {
                addPageBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    const position = prompt('Add page at:\n1. After current page\n2. Before current page\n3. At the end\n\nEnter 1, 2, or 3:', '1');
                    if (!position) return;
                    
                    try {
                        showLoading('Adding page...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        let pageIndex = -1;
                        let insertAfter = true;
                        
                        if (position === '1') {
                            pageIndex = window.pdfEditorVars.currentPage - 1;
                            insertAfter = true;
                        } else if (position === '2') {
                            pageIndex = window.pdfEditorVars.currentPage - 1;
                            insertAfter = false;
                        } else {
                            pageIndex = -1;
                            insertAfter = true;
                        }
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/pages/add`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                pageIndex: pageIndex,
                                insertAfter: insertAfter
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            window.pdfEditorVars.currentPdfData = result.pdfData;
                            await reloadPDF();
                            hideLoading();
                            alert('Page added successfully!');
                        } else {
                            throw new Error(result.error || 'Add page failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error adding page: ' + error.message);
                    }
                });
            }
            
            // Merge PDFs
            const mergeBtn = document.getElementById('merge-btn');
            if (mergeBtn) {
                mergeBtn.addEventListener('click', async function() {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'application/pdf,.pdf';
                    fileInput.multiple = true;
                    
                    fileInput.onchange = async function(e) {
                        const files = Array.from(e.target.files);
                        if (files.length < 2) {
                            alert('Please select at least 2 PDF files to merge.');
                            return;
                        }
                        
                        try {
                            showLoading(`Merging ${files.length} PDFs...`, 10);
                            const apiBaseUrl = getApiBaseUrl();
                            
                            // Convert files to base64
                            const pdfDataArray = [];
                            for (let i = 0; i < files.length; i++) {
                                updateProgress(10 + (i / files.length * 80), `Processing file ${i + 1}/${files.length}...`);
                                const file = files[i];
                                const arrayBuffer = await file.arrayBuffer();
                                const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                                pdfDataArray.push(`data:application/pdf;base64,${base64}`);
                            }
                            
                            updateProgress(90, 'Merging PDFs...');
                            const response = await fetch(`${apiBaseUrl}/api/pdf/merge`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ pdfDataArray: pdfDataArray })
                            });
                            
                            const result = await response.json();
                            
                            if (result.success) {
                                hideLoading();
                                const link = document.createElement('a');
                                link.href = result.pdfData;
                                link.download = 'merged.pdf';
                                link.click();
                                alert('PDFs merged successfully!');
                            } else {
                                throw new Error(result.error || 'Merge failed');
                            }
                        } catch (error) {
                            hideLoading();
                            alert('Error merging PDFs: ' + error.message);
                        }
                    };
                    
                    fileInput.click();
                });
            }
            
            // Split PDF
            const splitBtn = document.getElementById('split-btn');
            if (splitBtn) {
                splitBtn.addEventListener('click', async function() {
                    if (!currentSessionId) {
                        alert('No PDF loaded.');
                        return;
                    }
                    
                    const totalPages = window.pdfEditorVars.totalPages;
                    const splitPointsStr = prompt(`Enter page numbers where to split (comma-separated, 1-${totalPages}):\nExample: 3,5 will create 3 PDFs: pages 1-2, 3-4, 5-${totalPages}`, '');
                    
                    if (!splitPointsStr) return;
                    
                    try {
                        const splitPoints = splitPointsStr.split(',').map(s => parseInt(s.trim()));
                        if (splitPoints.some(n => isNaN(n) || n < 1 || n > totalPages)) {
                            throw new Error('Invalid split points');
                        }
                        
                        showLoading('Splitting PDF...', 50);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        
                        const response = await fetch(`${apiBaseUrl}/api/pdf/split`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                splitPoints: splitPoints
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success && result.splits) {
                            hideLoading();
                            result.splits.forEach((split, index) => {
                                setTimeout(() => {
                                    const link = document.createElement('a');
                                    link.href = split.pdfData;
                                    link.download = `split-${split.startPage}-${split.endPage}.pdf`;
                                    link.click();
                                }, index * 500);
                            });
                            alert(`PDF split into ${result.splits.length} files!`);
                        } else {
                            throw new Error(result.error || 'Split failed');
                        }
                    } catch (error) {
                        hideLoading();
                        alert('Error splitting PDF: ' + error.message);
                    }
                });
            }
            
            // Complete Batch Processing
            const batchStartBtn = document.getElementById('batch-start-btn');
            if (batchStartBtn) {
                batchStartBtn.addEventListener('click', async function() {
                    if (window.pdfEditorVars.batchQueue.length === 0) {
                        alert('No files in batch queue.');
                        return;
                    }
                    
                    const operation = prompt('Select batch operation:\n1. Compress\n2. OCR\n3. Protect\n4. Watermark\n\nEnter 1, 2, 3, or 4:', '1');
                    if (!operation) return;
                    
                    try {
                        window.pdfEditorVars.batchProcessing = true;
                        updateBatchQueue();
                        
                        const apiBaseUrl = getApiBaseUrl();
                        
                        for (let i = 0; i < window.pdfEditorVars.batchQueue.length; i++) {
                            const item = window.pdfEditorVars.batchQueue[i];
                            item.status = 'processing';
                            item.progress = 0;
                            updateBatchQueue();
                            
                            try {
                                const file = item.file;
                                const arrayBuffer = await file.arrayBuffer();
                                const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                                
                                item.progress = 30;
                                updateBatchQueue();
                                
                                let endpoint, body;
                                if (operation === '1') {
                                    endpoint = '/compress';
                                    body = { pdfData: `data:application/pdf;base64,${base64}` };
                                } else if (operation === '2') {
                                    endpoint = '/ocr';
                                    body = { pdfData: `data:application/pdf;base64,${base64}`, pageIndex: 0 };
                                } else if (operation === '3') {
                                    endpoint = '/protect';
                                    const password = prompt(`Enter password for ${item.name}:`, '');
                                    if (!password) continue;
                                    body = { pdfData: `data:application/pdf;base64,${base64}`, userPassword: password };
                                } else if (operation === '4') {
                                    endpoint = '/watermark';
                                    body = {
                                        pdfData: `data:application/pdf;base64,${base64}`,
                                        watermark: { type: 'text', text: 'BATCH', position: 'center', opacity: 0.3 }
                                    };
                                }
                                
                                item.progress = 60;
                                updateBatchQueue();
                                
                                const response = await fetch(`${apiBaseUrl}/api/pdf${endpoint}`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(body)
                                });
                                
                                const result = await response.json();
                                
                                if (result.success) {
                                    item.progress = 100;
                                    item.status = 'completed';
                                    item.result = result.pdfData || result.fileData;
                                    updateBatchQueue();
                                    
                                    // Auto-download
                                    const link = document.createElement('a');
                                    link.href = item.result;
                                    link.download = item.name.replace('.pdf', `-processed-${operation}.pdf`);
                                    link.click();
                                } else {
                                    throw new Error(result.error || 'Processing failed');
                                }
                            } catch (error) {
                                item.status = 'error: ' + error.message;
                                updateBatchQueue();
                            }
                        }
                        
                        window.pdfEditorVars.batchProcessing = false;
                        updateBatchQueue();
                        alert('Batch processing completed!');
                    } catch (error) {
                        window.pdfEditorVars.batchProcessing = false;
                        updateBatchQueue();
                        alert('Batch processing error: ' + error.message);
                    }
                });
            }
            
            // Cloud Storage Integration
            const saveCloudBtn = document.getElementById('save-cloud-btn');
            if (saveCloudBtn) {
                saveCloudBtn.addEventListener('click', async function() {
                    if (!window.pdfEditorVars.pdfDoc || !window.pdfEditorVars.currentPdfData) {
                        alert('No PDF to save. Please load a PDF first.');
                        return;
                    }
                    
                    const cloudProvider = prompt('Select cloud storage:\n1. Google Drive\n2. Dropbox\n3. OneDrive\n\nEnter 1, 2, or 3:', '1');
                    if (!cloudProvider) return;
                    
                    try {
                        showLoading('Saving to cloud...', 20);
                        const apiBaseUrl = getApiBaseUrl();
                        const fileId = window.pdfEditorVars.currentFileId || sessionStorage.getItem('pdfFileId');
                        const fileName = sessionStorage.getItem('pdfFileName') || 'document.pdf';
                        
                        // For now, use the existing saveToCloud function
                        // In production, this would integrate with actual cloud APIs
                        const response = await fetch(`${apiBaseUrl}/api/pdf/save-cloud`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                fileId: fileId,
                                pdfData: window.pdfEditorVars.currentPdfData,
                                fileName: fileName,
                                provider: cloudProvider === '1' ? 'googledrive' : cloudProvider === '2' ? 'dropbox' : 'onedrive'
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            hideLoading();
                            alert(`PDF saved to cloud successfully!\n${result.url ? 'URL: ' + result.url : 'File saved to cloud storage.'}`);
                        } else {
                            // Fallback: Download file for manual upload
                            hideLoading();
                            const link = document.createElement('a');
                            link.href = window.pdfEditorVars.currentPdfData;
                            link.download = fileName;
                            link.click();
                            alert('Cloud save not available. File downloaded for manual upload.\n\nTo enable cloud storage, configure API keys in server settings.');
                        }
                    } catch (error) {
                        hideLoading();
                        // Fallback: Download file
                        const link = document.createElement('a');
                        link.href = window.pdfEditorVars.currentPdfData;
                        link.download = sessionStorage.getItem('pdfFileName') || 'document.pdf';
                        link.click();
                        alert('Cloud save not configured. File downloaded for manual upload.');
                    }
                });
            }
        }
        
        // Enhanced OCR is handled by ocrServerBtn in initButtonEventListeners - no duplicate needed
        
        // Theme Toggle Functionality
        function initTheme() {
            // Get saved theme preference or default to dark
            const savedTheme = localStorage.getItem('pdf-editor-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeUI(savedTheme);
        }
        
        function updateThemeUI(theme) {
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            if (themeIcon && themeText) {
                if (theme === 'light') {
                    themeIcon.className = 'fas fa-sun';
                    themeText.textContent = 'Light';
                } else {
                    themeIcon.className = 'fas fa-moon';
                    themeText.textContent = 'Dark';
                }
            }
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('pdf-editor-theme', newTheme);
            updateThemeUI(newTheme);
            
            console.log('Theme changed to:', newTheme);
        }
        
        // Initialize theme on page load
        initTheme();
        
        // Theme toggle button event listener
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        if (themeToggleBtn) {
            themeToggleBtn.addEventListener('click', toggleTheme);
        }
        
        // Get current user ID helper
        async function getCurrentUserId() {
            try {
                const { auth } = await import('./js/firebase-init.js');
                if (auth && auth.currentUser) {
                    return auth.currentUser.uid;
                }
            } catch (e) {
                console.warn('Firebase not available');
            }
            return sessionStorage.getItem('userId') || null;
        }
        
        // Load and display credit balance
        async function loadCreditBalance() {
            try {
                const { getUserCreditInfo } = await import('./js/pdf-editor-api.js');
                const creditInfo = await getUserCreditInfo();
                
                const creditDisplay = document.getElementById('credit-count');
                if (creditDisplay) {
                    if (creditInfo.unlimited || creditInfo.isPremium) {
                        creditDisplay.textContent = 'Unlimited';
                    } else {
                        creditDisplay.textContent = `${creditInfo.credits} credits`;
                    }
                }
                
                // Show free limit panel for non-premium users
                const freeLimitPanel = document.getElementById('free-limit-panel');
                if (freeLimitPanel && !creditInfo.unlimited && !creditInfo.isPremium) {
                    freeLimitPanel.style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading credit balance:', error);
            }
        }
        
        // Initialize - ensure DOM is ready
        async function initPDFEditor() {
            // Initialize button event listeners first
            initButtonEventListeners();
            
            // Initialize advanced features
            initAdvancedFeatures();
            
            // Load credit balance
            await loadCreditBalance();
            
            // Refresh credit balance every 30 seconds
            setInterval(loadCreditBalance, 30000);
            
            // Check for PDF from edit-pdf.html on page load
            // This function handles all PDF loading scenarios (server URL, file ID, blob URL, base64)
            await checkForStoredPDF();
            
            // Note: checkForStoredPDF() already handles all PDF loading cases properly
            // No need for duplicate blob URL fetching here - it causes errors
            
            // Ensure preview container is visible
            if (previewContainer) {
                previewContainer.style.display = 'flex';
                previewContainer.style.visibility = 'visible';
            }
            if (pdfPageWrapper) {
                pdfPageWrapper.style.display = 'block';
                pdfPageWrapper.style.visibility = 'visible';
            }
        }
        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPDFEditor);
        } else {
            // DOM already loaded
            initPDFEditor();
        }
    </script>

        
</body>
</html>

