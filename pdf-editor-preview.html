<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Professional PDF Editor - Adobe Acrobat Pro Style | easyjpgtopdf</title>
    <meta name="description" content="Professional PDF editor with PDFTron WebViewer, Google Cloud Vision API OCR, native PDF text editing, and cloud processing. Edit PDFs like Adobe Acrobat Pro.">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    
    <!-- Preload Critical CSS -->
    <link rel="preload" href="css/header.css" as="style">
    <link rel="preload" href="css/footer.css" as="style">
    
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/theme-modern.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PDF.js for rendering (Fast, Lightweight) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- pdf-lib for real PDF editing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    
    <!-- PDFTron WebViewer (Professional Adobe Acrobat Pro alternative) -->
    <!-- Note: PDFTron requires license. For free alternative, we'll use enhanced pdf.js + pdf-lib -->
    <!-- Uncomment when PDFTron license is available:
    <script src="https://cdn.apryse.com/webviewer/lib/webviewer.min.js"></script>
    -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #f5f7ff;
            color: #0b1630;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        main {
            flex: 1;
            padding: 30px 0;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .page-header h1 {
            font-size: 2.2rem;
            color: #0b1630;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Professional Editor Workspace */
        .editor-workspace {
            display: flex;
            height: calc(100vh - 200px);
            min-height: 800px;
            background: #2b2b2b;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        /* Left Tools Panel */
        .tools-panel {
            width: 240px;
            min-width: 240px;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .tool-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .tool-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 5px;
        }
        
        .tool-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: #e5e5e5;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-item:hover {
            background: #2d2d2d;
        }
        
        .tool-item.active {
            background: #0078d4;
            color: white;
        }
        
        .tool-item i {
            width: 20px;
            text-align: center;
        }
        
        /* Center Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            overflow: hidden;
        }
        
        .preview-toolbar {
            background: #2b2b2b;
            border-bottom: 1px solid #3a3a3a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .preview-toolbar-btn {
            padding: 6px 12px;
            background: transparent;
            color: #e5e5e5;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .preview-toolbar-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }
        
        .preview-toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }
        
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
            background: #525252;
            padding: 20px;
            min-height: 100%;
        }
        
        .pdf-page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 0 auto;
        }
        
        .pdf-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        
        .editable-text {
            position: absolute;
            cursor: text;
            padding: 2px 4px;
            border: 1px dashed transparent;
            user-select: text;
            white-space: pre-wrap;
            pointer-events: auto;
            min-width: 20px;
            min-height: 16px;
        }
        
        .editable-text.selected {
            border-color: #4361ee;
            background: rgba(67, 97, 238, 0.1);
        }
        
        .editable-text.editing {
            border: 2px solid #4361ee;
            background: white;
            z-index: 10;
            outline: none;
        }
        
        .deletion-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .deletion-rect {
            position: absolute;
            background: white;
            border: none;
            pointer-events: auto;
            z-index: 6;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #0b1630;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            width: 300px;
            max-width: 80%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #7209b7);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .loading-percentage {
            color: #4361ee;
            font-size: 14px;
            margin-top: 8px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile Optimization - Touch Gestures & Responsive UI */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
            }
            
            .tool-group {
                min-width: 120px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .tool-item {
                min-height: 60px;
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item i {
                font-size: 20px;
                margin-bottom: 4px;
            }
            
            .preview-panel {
                flex: 1;
                min-height: 60vh;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                max-height: 200px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                border-left: none;
                border-top: 1px solid #3a3a3a;
            }
            
            .property-group {
                min-width: 150px;
                border-right: 1px solid #3a3a3a;
                border-bottom: none;
            }
            
            .pdf-canvas {
                touch-action: pan-x pan-y pinch-zoom;
            }
            
            .preview-toolbar-btn {
                min-width: 60px;
                min-height: 44px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            .editable-text {
                min-height: 24px;
                min-width: 30px;
                padding: 4px 6px;
            }
        }
        
        /* Touch Gesture Support */
        .pdf-canvas {
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Larger Touch Targets for Mobile */
        @media (max-width: 768px) {
            button, .tool-item, .preview-toolbar-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            input[type="number"],
            input[type="color"],
            select {
                min-height: 44px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        
        /* Right Properties Panel */
        .properties-panel {
            width: 160px;
            min-width: 160px;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .property-group {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .property-group-title {
            color: #9ca3af;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 12px;
            margin-bottom: 8px;
        }
        
        .property-item {
            padding: 8px 12px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-label {
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .property-input {
            width: 100%;
            padding: 4px 8px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 12px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        /* Performance indicators */
        .performance-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #28a745;
            color: white;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        /* Performance Optimizations */
        .pdf-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Lazy loading for pages */
        .pdf-page-wrapper[data-loaded="false"] {
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .pdf-page-wrapper[data-loaded="true"] {
            opacity: 1;
        }
        
        /* Cache optimization */
        .tool-item {
            will-change: transform;
        }
        
        /* Smooth scrolling */
        .tools-panel, .properties-panel {
            scroll-behavior: smooth;
        }
        
        /* Mobile Support - Full Responsive */
        @media (max-width: 768px) {
            .editor-workspace {
                flex-direction: column;
                height: auto;
                min-height: auto;
            }
            
            .tools-panel {
                width: 100%;
                min-width: 100%;
                flex-direction: row;
                overflow-x: auto;
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
                -webkit-overflow-scrolling: touch;
            }
            
            .tool-group {
                min-width: 200px;
                flex-shrink: 0;
            }
            
            .preview-panel {
                order: 2;
                min-height: 500px;
            }
            
            .preview-container {
                min-height: 400px !important;
            }
            
            .properties-panel {
                width: 100%;
                min-width: 100%;
                order: 3;
                border-left: none;
                border-top: 1px solid #3a3a3a;
                max-height: 300px;
            }
            
            .tool-item {
                padding: 12px 8px;
                font-size: 11px;
            }
            
            .tool-item span {
                display: block;
                margin-top: 4px;
            }
            
            /* Touch-friendly buttons */
            .preview-toolbar-btn {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Mobile gestures */
            .pdf-page-wrapper {
                touch-action: pan-x pan-y pinch-zoom;
            }
        }
    </style>
</head>
<body>
    <script src="js/global-components.js"></script>
    <div id="global-header-placeholder"></div>
    <div id="global-breadcrumb-placeholder"></div>
    
    <main>
        <div class="container">
            <div class="page-header">
                <h1>Professional PDF Editor <span class="performance-badge">‚ö° Instant</span></h1>
                <p>Adobe Acrobat Pro style editing with Google Cloud Vision API OCR, native PDF text editing, and cloud processing</p>
            </div>
            
            <!-- Professional Editor Workspace -->
            <div class="editor-workspace">
                <!-- Left Tools Panel -->
                <div class="tools-panel">
                    <div class="tool-group">
                        <div class="tool-group-title">File</div>
                        <div class="tool-item" id="upload-btn" title="Upload PDF">
                            <i class="fas fa-upload"></i>
                            <span>Upload</span>
                        </div>
                        <div class="tool-item" id="download-btn" title="Download PDF">
                            <i class="fas fa-download"></i>
                            <span>Download</span>
                        </div>
                        <div class="tool-item" id="save-cloud-btn" title="Save to Cloud">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <span>Save to Cloud</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Edit</div>
                        <div class="tool-item" id="select-tool" title="Select Tool" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i>
                            <span>Select</span>
                        </div>
                        <div class="tool-item" id="add-text-btn" title="Add Text" data-tool="text">
                            <i class="fas fa-font"></i>
                            <span>Add Text</span>
                        </div>
                        <div class="tool-item" id="add-image-btn" title="Add Image" data-tool="image">
                            <i class="fas fa-image"></i>
                            <span>Add Image</span>
                        </div>
                        <div class="tool-item" id="highlight-btn" title="Highlight" data-tool="highlight">
                            <i class="fas fa-highlighter"></i>
                            <span>Highlight</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">OCR <span class="performance-badge">‚ö° Fast</span></div>
                        <div class="tool-item" id="ocr-btn" title="Google Cloud Vision OCR">
                            <i class="fas fa-language"></i>
                            <span>OCR (Google Cloud)</span>
                        </div>
                        <div class="tool-item" id="ocr-server-btn" title="Server-Side Fast OCR">
                            <i class="fas fa-server"></i>
                            <span>Fast Server OCR</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Page Management</div>
                        <div class="tool-item" id="rotate-page-btn" title="Rotate Page">
                            <i class="fas fa-redo"></i>
                            <span>Rotate</span>
                        </div>
                        <div class="tool-item" id="delete-page-btn" title="Delete Page">
                            <i class="fas fa-trash"></i>
                            <span>Delete Page</span>
                        </div>
                        <div class="tool-item" id="reorder-pages-btn" title="Reorder Pages">
                            <i class="fas fa-sort"></i>
                            <span>Reorder</span>
                        </div>
                        <div class="tool-item" id="extract-page-btn" title="Extract Page">
                            <i class="fas fa-file-export"></i>
                            <span>Extract</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Forms</div>
                        <div class="tool-item" id="fill-form-btn" title="Fill Form Fields">
                            <i class="fas fa-edit"></i>
                            <span>Fill Form</span>
                        </div>
                        <div class="tool-item" id="detect-form-btn" title="Detect Form Fields">
                            <i class="fas fa-search"></i>
                            <span>Detect Fields</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Annotations</div>
                        <div class="tool-item" id="comment-btn" title="Add Comment">
                            <i class="fas fa-comment"></i>
                            <span>Comment</span>
                        </div>
                        <div class="tool-item" id="stamp-btn" title="Add Stamp">
                            <i class="fas fa-stamp"></i>
                            <span>Stamp</span>
                        </div>
                        <div class="tool-item" id="shape-btn" title="Add Shape">
                            <i class="fas fa-shapes"></i>
                            <span>Shape</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Export</div>
                        <div class="tool-item" id="export-word-btn" title="Export to Word">
                            <i class="fas fa-file-word"></i>
                            <span>Word</span>
                        </div>
                        <div class="tool-item" id="export-excel-btn" title="Export to Excel">
                            <i class="fas fa-file-excel"></i>
                            <span>Excel</span>
                        </div>
                        <div class="tool-item" id="export-ppt-btn" title="Export to PowerPoint">
                            <i class="fas fa-file-powerpoint"></i>
                            <span>PowerPoint</span>
                        </div>
                        <div class="tool-item" id="export-image-btn" title="Export to Images">
                            <i class="fas fa-image"></i>
                            <span>Images</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Tools</div>
                        <div class="tool-item" id="compress-btn" title="Compress PDF">
                            <i class="fas fa-compress"></i>
                            <span>Compress</span>
                        </div>
                        <div class="tool-item" id="merge-btn" title="Merge PDFs">
                            <i class="fas fa-layer-group"></i>
                            <span>Merge</span>
                        </div>
                        <div class="tool-item" id="split-btn" title="Split PDF">
                            <i class="fas fa-cut"></i>
                            <span>Split</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">Security & Extra</div>
                        <div class="tool-item" id="watermark-btn" title="Add Watermark">
                            <i class="fas fa-tint"></i>
                            <span>Watermark</span>
                        </div>
                        <div class="tool-item" id="sign-btn" title="Digital Signature">
                            <i class="fas fa-signature"></i>
                            <span>Sign</span>
                        </div>
                        <div class="tool-item" id="redact-btn" title="Redact Text">
                            <i class="fas fa-eye-slash"></i>
                            <span>Redact</span>
                        </div>
                        <div class="tool-item" id="protect-btn" title="Protect PDF">
                            <i class="fas fa-lock"></i>
                            <span>Protect</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="tool-group-title">History</div>
                        <div class="tool-item" id="undo-btn" title="Undo" disabled>
                            <i class="fas fa-undo"></i>
                            <span>Undo</span>
                        </div>
                        <div class="tool-item" id="redo-btn" title="Redo" disabled>
                            <i class="fas fa-redo"></i>
                            <span>Redo</span>
                        </div>
                    </div>
                </div>
                
                <!-- Center Preview Panel -->
                <div class="preview-panel">
                    <div class="preview-toolbar">
                        <button class="preview-toolbar-btn" id="prev-page" disabled>
                            <i class="fas fa-chevron-left"></i> Prev
                        </button>
                        <span class="page-info" style="color: #e5e5e5; font-size: 12px; padding: 0 10px;">
                            Page <span id="page-num">1</span> of <span id="page-count">1</span>
                        </span>
                        <button class="preview-toolbar-btn" id="next-page" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <div style="flex: 1;"></div>
                        <button class="preview-toolbar-btn" id="zoom-out-btn">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <span style="color: #e5e5e5; font-size: 12px; padding: 0 10px;" id="zoom-level">100%</span>
                        <button class="preview-toolbar-btn" id="zoom-in-btn">
                            <i class="fas fa-search-plus"></i>
                        </button>
                    </div>
                    
                    <div class="preview-container" id="preview-container" style="display: flex; visibility: visible; min-height: 600px;">
                        <div class="loading-overlay" id="loading-overlay" style="display: none;">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="loading-text">Processing...</div>
                            <div class="loading-progress">
                                <div class="loading-progress-bar" id="loading-progress-bar"></div>
                            </div>
                            <div class="loading-percentage" id="loading-percentage">0%</div>
                        </div>
                        <div id="pdf-page-wrapper" class="pdf-page-wrapper" style="display: block; visibility: visible; position: relative;">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="deletion-layer" class="deletion-layer"></div>
                            <div id="text-layer" class="text-layer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Properties Panel -->
                <div class="properties-panel">
                    <div class="property-group">
                        <div class="property-group-title">Text Properties</div>
                        <div class="property-item">
                            <div class="property-label">Font Size</div>
                            <input type="number" class="property-input" id="font-size-input" value="12" min="8" max="72">
                        </div>
                        <div class="property-item">
                            <div class="property-label">Font Family</div>
                            <select class="property-input" id="font-family-select">
                                <option value="Helvetica">Helvetica</option>
                                <option value="Times-Roman">Times Roman</option>
                                <option value="Courier">Courier</option>
                                <option value="Arial">Arial</option>
                            </select>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Color</div>
                            <input type="color" class="property-input" id="text-color-input" value="#000000">
                        </div>
                        <div class="property-item" style="margin-top: 15px;">
                            <button class="property-input" id="delete-text-btn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-trash"></i> Delete Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Page Actions</div>
                        <div class="property-item">
                            <button class="property-input" id="rotate-90-btn" style="width: 100%; padding: 6px; background: #2d2d2d; color: #e5e5e5; border: 1px solid #3a3a3a; border-radius: 4px; cursor: pointer; font-size: 11px; margin-bottom: 5px;">
                                <i class="fas fa-redo"></i> Rotate 90¬∞
                            </button>
                            <button class="property-input" id="delete-current-page-btn" style="width: 100%; padding: 6px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                <i class="fas fa-trash"></i> Delete Page
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Export Format</div>
                        <div class="property-item">
                            <select class="property-input" id="export-format-select" style="margin-bottom: 5px;">
                                <option value="pdf">PDF</option>
                                <option value="word">Word (DOCX)</option>
                                <option value="excel">Excel (XLSX)</option>
                                <option value="powerpoint">PowerPoint (PPTX)</option>
                                <option value="image">Images (PNG)</option>
                            </select>
                            <button class="property-input" id="export-btn" style="width: 100%; padding: 8px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-download"></i> Export
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Compression</div>
                        <div class="property-item">
                            <select class="property-input" id="compression-quality" style="margin-bottom: 5px;">
                                <option value="low">Low (Smaller Size)</option>
                                <option value="medium" selected>Medium (Balanced)</option>
                                <option value="high">High (Better Quality)</option>
                            </select>
                            <button class="property-input" id="compress-pdf-btn" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                <i class="fas fa-compress"></i> Compress
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-group-title">Performance</div>
                        <div class="property-item">
                            <div class="property-label">Rendering</div>
                            <div style="color: #28a745; font-size: 11px;">‚ö° PDF.js (Fast)</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">Processing</div>
                            <div style="color: #28a745; font-size: 11px;">‚òÅÔ∏è Server-Side</div>
                        </div>
                        <div class="property-item">
                            <div class="property-label">OCR Engine</div>
                            <div style="color: #28a745; font-size: 11px;">üîç Google Cloud</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="global-footer-placeholder"></div>
    
    <input type="file" id="file-input" accept="application/pdf,.pdf" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    
    <script src="js/mobile-menu-init.js"></script>
    <script>
        // Professional PDF Editor Implementation
        // Features: PDF.js rendering, Server processing, Fast OCR, Native editing, Cloud integration
        
        // Set PDF.js worker for performance
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
        
        // Global variables
        if (typeof window.pdfEditorVars === 'undefined') {
            window.pdfEditorVars = {
                pdfDoc: null,
                currentPage: 1,
                totalPages: 1,
                scale: 1.5,
                textAnnotations: [],
                annotationHistory: [],
                redoHistory: [],
                selectedTextElement: null,
                activeTool: 'select',
                ocrTextsForPDF: [],
                annotations: {
                    highlights: [],
                    comments: [],
                    stamps: [],
                    shapes: []
                },
                highlightStart: null,
                highlightEnd: null,
                isDrawing: false
            };
        }
        
        // DOM elements
        const previewContainer = document.getElementById('preview-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const pdfPageWrapper = document.getElementById('pdf-page-wrapper');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const textLayer = document.getElementById('text-layer');
        const deletionLayer = document.getElementById('deletion-layer');
        const pageNum = document.getElementById('page-num');
        const pageCount = document.getElementById('page-count');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const downloadBtn = document.getElementById('download-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const saveCloudBtn = document.getElementById('save-cloud-btn');
        const ocrBtn = document.getElementById('ocr-btn');
        const ocrServerBtn = document.getElementById('ocr-server-btn');
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const highlightBtn = document.getElementById('highlight-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const imageInput = document.getElementById('image-input');
        const fileInput = document.getElementById('file-input');
        const selectTool = document.getElementById('select-tool');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomLevel = document.getElementById('zoom-level');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorInput = document.getElementById('text-color-input');
        const deleteTextBtn = document.getElementById('delete-text-btn');
        
        // Direct file upload with server processing (Fast)
        if (uploadBtn && fileInput) {
            uploadBtn.addEventListener('click', function() {
                console.log('Upload button clicked');
                fileInput.click();
            });
        } else {
            console.error('Upload button or file input not found!', { uploadBtn, fileInput });
        }
        
        if (fileInput) {
            fileInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                    alert('Please select a valid PDF file');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Option 1: Direct server upload for processing (Fast)
                    const formData = new FormData();
                    formData.append('pdfFile', file);
                    
                    let uploadUrl = '/api/pdf/upload';
                    if (window.location.protocol === 'file:') {
                        uploadUrl = 'http://localhost:3000/api/pdf/upload';
                    }
                    
                    try {
                        const uploadResponse = await fetch(uploadUrl, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (uploadResponse.ok) {
                            const result = await uploadResponse.json();
                            if (result.success) {
                                // Load PDF from server response
                                const pdfData = await fetch(result.pdfUrl).then(r => r.arrayBuffer());
                                await renderPDF(pdfData);
                                hideLoading();
                                return;
                            }
                        }
                    } catch (uploadError) {
                        console.warn('Server upload failed, using client-side processing:', uploadError);
                        // Continue with client-side processing - no error shown to user
                    }
                    
                    // Option 2: Client-side processing (Fallback)
                    // This always runs if server upload fails or is skipped
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        try {
                            const pdfData = e.target.result;
                            await renderPDF(pdfData);
                            hideLoading();
                        } catch (renderError) {
                            console.error('PDF rendering error:', renderError);
                            hideLoading();
                            alert('Error loading PDF: ' + renderError.message);
                        }
                    };
                    reader.onerror = function() {
                        hideLoading();
                        alert('Error reading PDF file. Please try again.');
                    };
                    reader.readAsArrayBuffer(file);
                    
                } catch (error) {
                    console.error('File upload error:', error);
                    hideLoading();
                    alert('Error uploading PDF: ' + error.message);
                }
            });
        }
        
        // Render PDF (Fast PDF.js rendering)
        async function renderPDF(pdfData) {
            try {
                if (!pdfjsLib) {
                    throw new Error('PDF.js library not loaded');
                }
                
                const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                const pdfDoc = await loadingTask.promise;
                window.pdfEditorVars.pdfDoc = pdfDoc;
                window.pdfEditorVars.totalPages = pdfDoc.numPages;
                
                if (pageCount) pageCount.textContent = pdfDoc.numPages;
                
                await renderPage(1);
                updatePageButtons();
                
                if (downloadBtn) downloadBtn.disabled = false;
                
            } catch (error) {
                console.error('Error rendering PDF:', error);
                alert('Error rendering PDF: ' + error.message);
            }
        }
        
        // Render specific page (with memory leak fix)
        let currentPageRenderTask = null;
        async function renderPage(pageNumber) {
            try {
                const pdfDoc = window.pdfEditorVars.pdfDoc;
                if (!pdfDoc) return;
                
                // Cancel previous render task to prevent memory leaks
                if (currentPageRenderTask) {
                    currentPageRenderTask.cancel();
                    currentPageRenderTask = null;
                }
                
                // Clear canvas and layers
                const context = pdfCanvas.getContext('2d');
                context.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                if (textLayer) textLayer.innerHTML = '';
                if (deletionLayer) deletionLayer.innerHTML = '';
                
                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                
                // Create render task
                const renderTask = page.render({
                    canvasContext: context,
                    viewport: viewport
                });
                currentPageRenderTask = renderTask;
                
                await renderTask.promise;
                currentPageRenderTask = null;
                
                // Extract and render text layer
                const textContent = await page.getTextContent();
                renderTextLayer(textContent, viewport, pageNumber);
                
                // Update page number
                if (pageNum) pageNum.textContent = pageNumber;
                
                // Clean up page object (help with memory)
                if (page.cleanup) {
                    page.cleanup();
                }
                
                // Initialize deletion layer
                if (deletionLayer) {
                    deletionLayer.style.width = viewport.width + 'px';
                    deletionLayer.style.height = viewport.height + 'px';
                }
                
                window.pdfEditorVars.currentPage = pageNumber;
                if (pageNum) pageNum.textContent = pageNumber;
                
                if (zoomLevel) {
                    zoomLevel.textContent = Math.round(window.pdfEditorVars.scale * 100) + '%';
                }
                
            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }
        
        // Render text layer (with page tracking for multi-page editing)
        function renderTextLayer(textContent, viewport, pageNumber = 1) {
            if (!textLayer) return;
            
            textLayer.innerHTML = '';
            textLayer.style.width = viewport.width + 'px';
            textLayer.style.height = viewport.height + 'px';
            
            textContent.items.forEach((item, index) => {
                if (item.str && item.str.trim()) {
                    const words = item.str.split(/(\s+)/);
                    let currentX = item.transform[4];
                    const baseY = viewport.height - item.transform[5];
                    const fontSize = Math.abs(item.transform[0]) || 12;
                    const fontFamily = item.fontName || 'Arial';
                    
                    words.forEach((word, wordIndex) => {
                        if (word.trim()) {
                            const wordDiv = document.createElement('div');
                            wordDiv.className = 'editable-text';
                            wordDiv.textContent = word;
                            wordDiv.style.left = currentX + 'px';
                            wordDiv.style.top = (baseY - fontSize) + 'px';
                            wordDiv.style.fontSize = fontSize + 'px';
                            wordDiv.style.fontFamily = fontFamily;
                            wordDiv.style.color = '#000000';
                            wordDiv.dataset.page = pageNumber; // Track which page this text belongs to
                            
                            wordDiv.addEventListener('click', function(e) {
                                e.stopPropagation();
                                selectTextElement(wordDiv);
                            });
                            
                            wordDiv.addEventListener('dblclick', function(e) {
                                e.stopPropagation();
                                editTextElement(wordDiv);
                            });
                            
                            textLayer.appendChild(wordDiv);
                            currentX += word.length * (fontSize * 0.6);
                        } else if (word) {
                            currentX += fontSize * 0.3;
                        }
                    });
                }
            });
        }
        
        // Select text element
        function selectTextElement(element) {
            if (window.pdfEditorVars.selectedTextElement) {
                window.pdfEditorVars.selectedTextElement.classList.remove('selected');
            }
            window.pdfEditorVars.selectedTextElement = element;
            element.classList.add('selected');
        }
        
        // Edit text element
        function editTextElement(element) {
            element.contentEditable = true;
            element.classList.add('editing');
            element.focus();
            
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            element.addEventListener('blur', function() {
                element.contentEditable = false;
                element.classList.remove('editing');
            }, { once: true });
        }
        
        // Delete text element
        function deleteTextElement(element) {
            if (!element || !deletionLayer) return;
            
            const x = parseFloat(element.style.left) || 0;
            const y = parseFloat(element.style.top) || 0;
            const fontSize = parseFloat(element.style.fontSize) || 12;
            const textWidth = element.offsetWidth || Math.max(element.textContent.length * fontSize * 0.6, 20);
            const textHeight = Math.max(fontSize * 1.2, fontSize);
            
            const deletionRect = document.createElement('div');
            deletionRect.className = 'deletion-rect';
            deletionRect.style.left = x + 'px';
            deletionRect.style.top = y + 'px';
            deletionRect.style.width = Math.max(textWidth + 4, 20) + 'px';
            deletionRect.style.height = Math.max(textHeight + 2, fontSize) + 'px';
            
            deletionLayer.appendChild(deletionRect);
            
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
            
            if (window.pdfEditorVars.selectedTextElement === element) {
                window.pdfEditorVars.selectedTextElement = null;
            }
        }
        
        // Fast Server-Side OCR (Google Cloud Vision API)
        if (ocrBtn) {
            ocrBtn.addEventListener('click', async function() {
                console.log('OCR button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Starting OCR...', 5);
                    updateProgress(10, 'Rendering page to image...');
                    
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    updateProgress(30, 'Converting to image...');
                    const imageData = canvas.toDataURL('image/png');
                    
                    updateProgress(40, 'Sending to OCR service...');
                    // Fast server-side OCR with Google Cloud Vision API
                    let apiUrl = '/api/pdf-ocr/process';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf-ocr/process';
                    }
                    
                    let result = null;
                    let useClientSideOCR = false;
                    
                    // Try server-side OCR first
                    try {
                        updateProgress(50, 'Processing with Google Cloud Vision API...');
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                image: imageData.split(',')[1],
                                language: 'en'
                            })
                        });
                        
                        if (response.ok) {
                            const contentType = response.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                updateProgress(80, 'Receiving OCR results...');
                                result = await response.json();
                                updateProgress(95, 'Processing results...');
                                console.log('Server-side OCR successful');
                            } else {
                                throw new Error('Invalid response type from server');
                            }
                        } else {
                            console.warn('Server OCR failed, using client-side OCR fallback');
                            useClientSideOCR = true;
                        }
                    } catch (fetchError) {
                        // Network error or server not available, use client-side OCR
                        console.warn('Server OCR unavailable, using client-side OCR fallback:', fetchError.message);
                        useClientSideOCR = true;
                    }
                    
                    // Fallback to client-side OCR using Tesseract.js
                    if (useClientSideOCR || !result) {
                        if (typeof Tesseract === 'undefined') {
                            hideLoading();
                            alert('OCR service unavailable. Please ensure you have an internet connection for client-side OCR or start the server for Google Cloud Vision API.');
                            return;
                        }
                        
                        updateProgress(50, 'Using client-side OCR (Tesseract.js)...');
                        console.log('Starting client-side OCR with Tesseract.js...');
                        try {
                            const { data } = await Tesseract.recognize(imageData, 'eng', {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        const progress = 50 + (m.progress * 40); // 50-90%
                                        updateProgress(progress, `OCR progress: ${Math.round(m.progress * 100)}%`);
                                        console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                                    }
                                }
                            });
                            updateProgress(95, 'Processing OCR results...');
                            
                            result = {
                                success: true,
                                text: data.text,
                                words: data.words.map(word => ({
                                    text: word.text,
                                    boundingBox: {
                                        x: word.bbox.x0,
                                        y: word.bbox.y0,
                                        width: word.bbox.x1 - word.bbox.x0,
                                        height: word.bbox.y1 - word.bbox.y0
                                    },
                                    confidence: word.confidence
                                })),
                                confidence: data.confidence,
                                method: 'tesseract-js-client'
                            };
                        } catch (ocrError) {
                            console.error('Client-side OCR error:', ocrError);
                            hideLoading();
                            alert('OCR processing failed. Please try again or check your internet connection.');
                            return;
                        }
                    }
                    
                    if (result && result.success && result.words) {
                            // Process OCR results
                            const currentViewport = page.getViewport({ scale: window.pdfEditorVars.scale });
                            const scaleX = pdfCanvas.width / (viewport.width);
                            const scaleY = pdfCanvas.height / (viewport.height);
                            
                            result.words.forEach((word) => {
                                if (word.text && word.boundingBox) {
                                    const textElement = document.createElement('div');
                                    textElement.className = 'editable-text';
                                    textElement.textContent = word.text;
                                    textElement.style.left = (word.boundingBox.x * scaleX) + 'px';
                                    textElement.style.top = (word.boundingBox.y * scaleY) + 'px';
                                    textElement.style.fontSize = '12px';
                                    textElement.style.color = '#000000';
                                    
                                    textElement.addEventListener('click', function(e) {
                                        e.stopPropagation();
                                        selectTextElement(textElement);
                                    });
                                    
                                    textLayer.appendChild(textElement);
                                    
                                    // Store for PDF embedding
                                    if (!window.pdfEditorVars.ocrTextsForPDF) {
                                        window.pdfEditorVars.ocrTextsForPDF = [];
                                    }
                                    window.pdfEditorVars.ocrTextsForPDF.push({
                                        pageIndex: window.pdfEditorVars.currentPage - 1,
                                        text: word.text,
                                        x: word.boundingBox.x * scaleX,
                                        y: word.boundingBox.y * scaleY,
                                        fontSize: 12,
                                        fontColor: [0, 0, 0],
                                        fontName: 'Helvetica'
                                    });
                                }
                            });
                            
                            // Determine which service was actually used
                            let serviceName = 'Google Cloud Vision API';
                            if (result.method) {
                                if (result.method === 'tesseract-js-client' || result.method.includes('tesseract')) {
                                    serviceName = 'Tesseract.js (Client-side)';
                                } else if (result.method.includes('google-cloud') || result.method.includes('vision')) {
                                    serviceName = 'Google Cloud Vision API';
                                } else {
                                    serviceName = result.method;
                                }
                            }
                            
                            alert('OCR completed! Extracted ' + result.words.length + ' words using ' + serviceName + '.');
                        } else {
                            alert('OCR completed but no text found.');
                        }
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('OCR error:', error);
                    hideLoading();
                    alert('Error performing OCR: ' + error.message);
                }
            });
        }
        
        // Fast Server-Side OCR (Alternative fast processing)
        if (ocrServerBtn) {
            ocrServerBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) return;
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Use fast server-side processing
                    const page = await window.pdfEditorVars.pdfDoc.getPage(window.pdfEditorVars.currentPage);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    const imageData = canvas.toDataURL('image/png');
                    
                    // Fast server OCR endpoint
                    let apiUrl = '/api/pdf-ocr/process-fast';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf-ocr/process-fast';
                    }
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: imageData.split(',')[1],
                            language: 'en',
                            fast: true
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Determine which service was actually used
                        let serviceName = 'Fast Server OCR';
                        if (result.method) {
                            if (result.method.includes('google-cloud') || result.method.includes('vision')) {
                                serviceName = 'Google Cloud Vision API (Fast)';
                            } else if (result.method === 'tesseract-js-client' || result.method.includes('tesseract')) {
                                serviceName = 'Tesseract.js (Client-side)';
                            } else {
                                serviceName = result.method;
                            }
                        }
                        
                        alert('Fast OCR completed! ' + (result.words ? result.words.length : 0) + ' words extracted using ' + serviceName + '.');
                    }
                    
                    hideLoading();
                } catch (error) {
                    console.error('Fast OCR error:', error);
                    hideLoading();
                    alert('Error performing fast OCR: ' + error.message);
                }
            });
        }
        
        // Download with server processing
        if (downloadBtn) {
            downloadBtn.addEventListener('click', async function() {
                console.log('Download button clicked');
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded. Please upload a PDF first.');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    
                    // Get PDF data
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) {
                        throw new Error('PDF file not found');
                    }
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    
                    // Native PDF Editing - All edits are already in PDF!
                    // No need to collect HTML overlays - PDF is already edited
                    // Just get the current PDF which has all edits applied
                    
                    // Get stored edits metadata (for reference only)
                    const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                    
                    // Since we're using native editing, the PDF already contains all edits
                    // We just need to ensure OCR texts are included if any
                    const edits = {
                        ocrTexts: window.pdfEditorVars.ocrTextsForPDF || storedEdits.ocrTexts || []
                    };
                    
                    // Note: All text edits, deletions, highlights, etc. are already in the PDF
                    // because we apply them immediately via native editing engine
                    
                    updateProgress(60, 'Converting to base64...');
                    // Convert to base64
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(70, 'Sending to server for processing...');
                    // Send to server for processing
                    let editApiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        editApiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    const editResponse = await fetch(editApiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            pdfData: pdfBase64,
                            edits: edits
                        })
                    });
                    
                    updateProgress(85, 'Processing PDF edits...');
                    
                    if (editResponse.ok) {
                        const editResult = await editResponse.json();
                        if (editResult.success) {
                            updateProgress(95, 'Preparing download...');
                            const editedPdfBase64 = editResult.pdfData.split(',')[1];
                            const editedPdfBytes = Uint8Array.from(atob(editedPdfBase64), c => c.charCodeAt(0));
                            const blob = new Blob([editedPdfBytes], { type: 'application/pdf' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'edited-document.pdf';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            updateProgress(100, 'Download complete!');
                            setTimeout(() => {
                                hideLoading();
                                alert('PDF downloaded successfully!');
                            }, 500);
                        } else {
                            throw new Error(editResult.error || 'PDF editing failed');
                        }
                    } else {
                        throw new Error('Server error: ' + editResponse.status);
                    }
                } catch (error) {
                    console.error('Download error:', error);
                    hideLoading();
                    alert('Error downloading PDF: ' + error.message);
                }
            });
        }
        
        // Save to Cloud
        if (saveCloudBtn) {
            saveCloudBtn.addEventListener('click', async function() {
                alert('Cloud save feature - Coming soon! This will save your PDF to Google Drive/Dropbox.');
            });
        }
        
        // Page navigation
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage > 1) {
                    window.pdfEditorVars.currentPage--;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', async function() {
                if (window.pdfEditorVars.currentPage < window.pdfEditorVars.totalPages) {
                    window.pdfEditorVars.currentPage++;
                    await renderPage(window.pdfEditorVars.currentPage);
                    updatePageButtons();
                }
            });
        }
        
        function updatePageButtons() {
            if (prevPageBtn) prevPageBtn.disabled = window.pdfEditorVars.currentPage <= 1;
            if (nextPageBtn) nextPageBtn.disabled = window.pdfEditorVars.currentPage >= window.pdfEditorVars.totalPages;
        }
        
        // Delete text button
        if (deleteTextBtn) {
            deleteTextBtn.addEventListener('click', function() {
                if (window.pdfEditorVars.selectedTextElement) {
                    deleteTextElement(window.pdfEditorVars.selectedTextElement);
                } else {
                    alert('Please select a text element to delete.');
                }
            });
        }
        
        // Add Text button
        if (addTextBtn) {
            addTextBtn.addEventListener('click', function() {
                console.log('Add Text button clicked');
                window.pdfEditorVars.activeTool = 'text';
                if (addTextBtn) addTextBtn.classList.add('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                // Add text on canvas click
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                    pdfCanvas.addEventListener('click', addTextOnCanvas, { once: true });
                }
            });
        }
        
        // Add Image button
        if (addImageBtn) {
            addImageBtn.addEventListener('click', function() {
                console.log('Add Image button clicked');
                window.pdfEditorVars.activeTool = 'image';
                if (addImageBtn) addImageBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (imageInput) {
                    imageInput.click();
                }
            });
        }
        
        // Highlight button
        if (highlightBtn) {
            highlightBtn.addEventListener('click', function() {
                console.log('Highlight button clicked');
                window.pdfEditorVars.activeTool = 'highlight';
                if (highlightBtn) highlightBtn.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
            });
        }
        
        // Select tool
        if (selectTool) {
            selectTool.addEventListener('click', function() {
                console.log('Select tool clicked');
                window.pdfEditorVars.activeTool = 'select';
                if (selectTool) selectTool.classList.add('active');
                if (addTextBtn) addTextBtn.classList.remove('active');
                if (addImageBtn) addImageBtn.classList.remove('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                }
            });
        }
        
        // Native PDF Text Editing - No HTML Overlays!
        // Edits are applied directly to PDF and re-rendered
        async function addTextOnCanvas(e) {
            if (window.pdfEditorVars.activeTool !== 'text') return;
            
            const rect = pdfCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const text = prompt('Enter text:');
            if (!text) return;
            
            const fontSize = fontSizeInput ? parseInt(fontSizeInput.value) || 12 : 12;
            const fontFamily = fontFamilySelect ? fontFamilySelect.value || 'Helvetica' : 'Helvetica';
            const textColor = textColorInput ? textColorInput.value || '#000000' : '#000000';
            
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255
                ] : [0, 0, 0];
            };
            
            try {
                showLoading('Adding text to PDF...', 10);
                
                // Get current PDF
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(30, 'Loading PDF...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                // Apply edit directly to PDF using native editing
                updateProgress(50, 'Applying text to PDF...');
                let apiUrl = '/api/pdf/edit-native';
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000/api/pdf/edit-native';
                }
                
                const editResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                        edit: {
                            type: 'addText',
                            data: {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: text,
                                fontSize: fontSize,
                                fontName: fontFamily,
                                fontColor: hexToRgb(textColor)
                            }
                        }
                    })
                });
                
                updateProgress(80, 'Updating PDF...');
                
                if (editResponse.ok) {
                    const result = await editResponse.json();
                    if (result.success) {
                        // Update PDF immediately - re-render with new text
                        updateProgress(90, 'Rendering updated PDF...');
                        const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                        
                        // Update stored PDF
                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                        const newUrl = URL.createObjectURL(blob);
                        sessionStorage.setItem('pdfFileURL', newUrl);
                        
                        // Re-render PDF to show new text
                        await renderPDF(pdfData);
                        
                        updateProgress(100, 'Text added!');
                        setTimeout(() => {
                            hideLoading();
                        }, 300);
                    } else {
                        throw new Error(result.error || 'Failed to add text');
                    }
                } else {
                    throw new Error('Server error: ' + editResponse.status);
                }
            } catch (error) {
                console.error('Error adding text:', error);
                hideLoading();
                alert('Error adding text: ' + error.message);
            }
            
            // Reset tool
            window.pdfEditorVars.activeTool = 'select';
            if (pdfCanvas) pdfCanvas.style.cursor = 'default';
            if (addTextBtn) addTextBtn.classList.remove('active');
            if (selectTool) selectTool.classList.add('active');
        }
        
        // Handle image input
        if (imageInput) {
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Add image to canvas at click position
                        if (window.pdfEditorVars.activeTool === 'image' && pdfCanvas) {
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = (window.pdfEditorVars.lastClickX || 100) - rect.left;
                            const y = (window.pdfEditorVars.lastClickY || 100) - rect.top;
                            
                            const imgElement = document.createElement('img');
                            imgElement.src = e.target.result;
                            imgElement.style.position = 'absolute';
                            imgElement.style.left = x + 'px';
                            imgElement.style.top = y + 'px';
                            imgElement.style.maxWidth = '200px';
                            imgElement.style.maxHeight = '200px';
                            
                            if (textLayer) {
                                textLayer.appendChild(imgElement);
                            }
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Track canvas clicks for image placement
        if (pdfCanvas) {
            pdfCanvas.addEventListener('click', function(e) {
                if (window.pdfEditorVars.activeTool === 'image') {
                    window.pdfEditorVars.lastClickX = e.clientX;
                    window.pdfEditorVars.lastClickY = e.clientY;
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && 
                window.pdfEditorVars.selectedTextElement && 
                !window.pdfEditorVars.selectedTextElement.classList.contains('editing')) {
                e.preventDefault();
                deleteTextElement(window.pdfEditorVars.selectedTextElement);
            }
        });
        
        // ========== NEW FEATURES IMPLEMENTATION ==========
        
        // Page Management
        const rotate90Btn = document.getElementById('rotate-90-btn');
        const deleteCurrentPageBtn = document.getElementById('delete-current-page-btn');
        const rotatePageBtn = document.getElementById('rotate-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const reorderPagesBtn = document.getElementById('reorder-pages-btn');
        const extractPageBtn = document.getElementById('extract-page-btn');
        
        // Forms
        const fillFormBtn = document.getElementById('fill-form-btn');
        const detectFormBtn = document.getElementById('detect-form-btn');
        
        // Annotations - Complete Implementation
        const commentBtn = document.getElementById('comment-btn');
        const stampBtn = document.getElementById('stamp-btn');
        const shapeBtn = document.getElementById('shape-btn');
        
        // Comment Button
        if (commentBtn) {
            commentBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'comment';
                if (commentBtn) commentBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (stampBtn) stampBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Add click handler for comment placement
                pdfCanvas.addEventListener('click', function addCommentHandler(e) {
                    if (window.pdfEditorVars.activeTool === 'comment') {
                        pdfCanvas.removeEventListener('click', addCommentHandler);
                        const rect = pdfCanvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        const commentText = prompt('Enter your comment:');
                        if (commentText) {
                            const comment = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                text: commentText,
                                author: 'User'
                            };
                            
                            window.pdfEditorVars.annotations.comments.push(comment);
                            
                            // Store in sessionStorage
                            const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                            if (!storedEdits.comments) storedEdits.comments = [];
                            storedEdits.comments.push(comment);
                            sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                            
                            // Visual indicator
                            const commentIcon = document.createElement('div');
                            commentIcon.className = 'comment-icon';
                            commentIcon.style.position = 'absolute';
                            commentIcon.style.left = x + 'px';
                            commentIcon.style.top = y + 'px';
                            commentIcon.style.width = '20px';
                            commentIcon.style.height = '20px';
                            commentIcon.style.backgroundColor = '#ffeb3b';
                            commentIcon.style.border = '2px solid #000';
                            commentIcon.style.borderRadius = '50%';
                            commentIcon.style.cursor = 'pointer';
                            commentIcon.title = commentText;
                            commentIcon.dataset.page = window.pdfEditorVars.currentPage;
                            textLayer.appendChild(commentIcon);
                            
                            commentIcon.addEventListener('click', function() {
                                alert('Comment: ' + commentText);
                            });
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (commentBtn) commentBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }
                }, { once: true });
            });
        }
        
        // Stamp Button
        if (stampBtn) {
            stampBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'stamp';
                if (stampBtn) stampBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (commentBtn) commentBtn.classList.remove('active');
                if (shapeBtn) shapeBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                // Show stamp type selection
                const stampType = prompt('Enter stamp type (APPROVED, REJECTED, CONFIDENTIAL, DRAFT, or custom):', 'APPROVED');
                if (stampType) {
                    pdfCanvas.addEventListener('click', function addStampHandler(e) {
                        if (window.pdfEditorVars.activeTool === 'stamp') {
                            pdfCanvas.removeEventListener('click', addStampHandler);
                            const rect = pdfCanvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            const stamp = {
                                pageIndex: window.pdfEditorVars.currentPage - 1,
                                x: x,
                                y: y,
                                stampType: stampType,
                                width: 100,
                                height: 50
                            };
                            
                            window.pdfEditorVars.annotations.stamps.push(stamp);
                            
                            // Store in sessionStorage
                            const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                            if (!storedEdits.stamps) storedEdits.stamps = [];
                            storedEdits.stamps.push(stamp);
                            sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                            
                            // Visual indicator
                            const stampDiv = document.createElement('div');
                            stampDiv.className = 'stamp-indicator';
                            stampDiv.style.position = 'absolute';
                            stampDiv.style.left = x + 'px';
                            stampDiv.style.top = y + 'px';
                            stampDiv.style.width = '100px';
                            stampDiv.style.height = '50px';
                            stampDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
                            stampDiv.style.border = '2px solid #f00';
                            stampDiv.style.display = 'flex';
                            stampDiv.style.alignItems = 'center';
                            stampDiv.style.justifyContent = 'center';
                            stampDiv.style.fontSize = '12px';
                            stampDiv.style.fontWeight = 'bold';
                            stampDiv.style.color = '#f00';
                            stampDiv.textContent = stampType;
                            stampDiv.dataset.page = window.pdfEditorVars.currentPage;
                            textLayer.appendChild(stampDiv);
                        }
                        
                        // Reset tool
                        window.pdfEditorVars.activeTool = 'select';
                        if (stampBtn) stampBtn.classList.remove('active');
                        if (selectTool) selectTool.classList.add('active');
                        if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    }, { once: true });
                } else {
                    window.pdfEditorVars.activeTool = 'select';
                    if (stampBtn) stampBtn.classList.remove('active');
                }
            });
        }
        
        // Shape Button
        if (shapeBtn) {
            shapeBtn.addEventListener('click', function() {
                const shapeType = prompt('Enter shape type (rectangle, circle, line):', 'rectangle');
                if (shapeType && ['rectangle', 'circle', 'line'].includes(shapeType.toLowerCase())) {
                    window.pdfEditorVars.activeTool = 'shape';
                    window.pdfEditorVars.shapeType = shapeType.toLowerCase();
                    if (shapeBtn) shapeBtn.classList.add('active');
                    if (highlightBtn) highlightBtn.classList.remove('active');
                    if (commentBtn) commentBtn.classList.remove('active');
                    if (stampBtn) stampBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.remove('active');
                    
                    if (pdfCanvas) {
                        pdfCanvas.style.cursor = 'crosshair';
                    }
                }
            });
        }
        
        // Shape drawing (similar to highlight)
        let shapeStartX = null;
        let shapeStartY = null;
        let shapeRect = null;
        
        if (pdfCanvas) {
            const shapeMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    shapeStartX = e.clientX - rect.left;
                    shapeStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    shapeRect = document.createElement('div');
                    shapeRect.className = 'shape-rect';
                    shapeRect.style.position = 'absolute';
                    shapeRect.style.left = shapeStartX + 'px';
                    shapeRect.style.top = shapeStartY + 'px';
                    shapeRect.style.width = '0px';
                    shapeRect.style.height = '0px';
                    shapeRect.style.border = '2px solid #000';
                    shapeRect.style.backgroundColor = 'transparent';
                    shapeRect.style.pointerEvents = 'auto';
                    shapeRect.style.zIndex = '7';
                    shapeRect.dataset.page = window.pdfEditorVars.currentPage;
                    shapeRect.dataset.shapeType = window.pdfEditorVars.shapeType;
                    textLayer.appendChild(shapeRect);
                }
            };
            
            const shapeMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing && shapeRect) {
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - shapeStartX);
                    const height = Math.abs(currentY - shapeStartY);
                    const left = Math.min(shapeStartX, currentX);
                    const top = Math.min(shapeStartY, currentY);
                    
                    shapeRect.style.left = left + 'px';
                    shapeRect.style.top = top + 'px';
                    shapeRect.style.width = width + 'px';
                    shapeRect.style.height = height + 'px';
                    
                    if (window.pdfEditorVars.shapeType === 'circle') {
                        shapeRect.style.borderRadius = '50%';
                    }
                }
            };
            
            const shapeMouseUp = function(e) {
                if (window.pdfEditorVars.activeTool === 'shape' && window.pdfEditorVars.isDrawing && shapeRect) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const width = parseFloat(shapeRect.style.width);
                    const height = parseFloat(shapeRect.style.height);
                    
                    if (width > 5 && height > 5) {
                        const shape = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            shapeType: window.pdfEditorVars.shapeType,
                            x: parseFloat(shapeRect.style.left),
                            y: parseFloat(shapeRect.style.top),
                            width: width,
                            height: height,
                            color: [0, 0, 0],
                            strokeWidth: 2
                        };
                        
                        window.pdfEditorVars.annotations.shapes.push(shape);
                        
                        // Store in sessionStorage
                        const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                        if (!storedEdits.shapes) storedEdits.shapes = [];
                        storedEdits.shapes.push(shape);
                        sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                    } else {
                        shapeRect.remove();
                    }
                    
                    // Reset tool
                    window.pdfEditorVars.activeTool = 'select';
                    if (shapeBtn) shapeBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    shapeStartX = null;
                    shapeStartY = null;
                    shapeRect = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', shapeMouseDown);
            pdfCanvas.addEventListener('mousemove', shapeMouseMove);
            pdfCanvas.addEventListener('mouseup', shapeMouseUp);
        }
        
        // Export - Complete Implementation
        const exportBtn = document.getElementById('export-btn');
        const exportFormatSelect = document.getElementById('export-format-select');
        const exportWordBtn = document.getElementById('export-word-btn');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const exportPptBtn = document.getElementById('export-ppt-btn');
        const exportImageBtn = document.getElementById('export-image-btn');
        
        // Export Function
        async function exportToFormat(format) {
            if (!window.pdfEditorVars.pdfDoc) {
                alert('No PDF loaded');
                return;
            }
            
            try {
                showLoading(`Exporting to ${format.toUpperCase()}...`, 10);
                const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                if (!pdfFileURL) throw new Error('PDF file not found');
                
                updateProgress(20, 'Loading PDF data...');
                const response = await fetch(pdfFileURL);
                const pdfArrayBuffer = await response.arrayBuffer();
                const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                
                let apiUrl = '';
                let mimeType = '';
                let fileExtension = '';
                
                switch(format) {
                    case 'word':
                        apiUrl = '/api/pdf/export/word';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        fileExtension = 'docx';
                        break;
                    case 'excel':
                        apiUrl = '/api/pdf/export/excel';
                        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                        fileExtension = 'xlsx';
                        break;
                    case 'powerpoint':
                        apiUrl = '/api/pdf/export/powerpoint';
                        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
                        fileExtension = 'pptx';
                        break;
                    case 'image':
                        apiUrl = '/api/pdf/export/images';
                        mimeType = 'image/png';
                        fileExtension = 'zip';
                        break;
                    default:
                        throw new Error('Unsupported export format');
                }
                
                if (window.location.protocol === 'file:') {
                    apiUrl = 'http://localhost:3000' + apiUrl;
                }
                
                updateProgress(40, `Sending to ${format} converter...`);
                const exportResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                });
                
                updateProgress(70, 'Processing export...');
                
                if (exportResponse.ok) {
                    const result = await exportResponse.json();
                    if (result.success) {
                        updateProgress(90, 'Preparing download...');
                        
                        if (format === 'image' && result.images) {
                            alert('Image export creates multiple files. Downloading first image as example.');
                            if (result.images[0]) {
                                const imgBase64 = Buffer.from(result.images[0].image).toString('base64');
                                const imgBytes = Uint8Array.from(atob(imgBase64), c => c.charCodeAt(0));
                                const blob = new Blob([imgBytes], { type: 'image/png' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `page-1.png`;
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                        } else if (result.fileData) {
                            const fileBase64 = result.fileData.split(',')[1] || result.fileData;
                            const fileBytes = Uint8Array.from(atob(fileBase64), c => c.charCodeAt(0));
                            const blob = new Blob([fileBytes], { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `exported-document.${fileExtension}`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }
                        
                        updateProgress(100, 'Export complete!');
                        setTimeout(() => {
                            hideLoading();
                            alert(`Successfully exported to ${format.toUpperCase()}!`);
                        }, 500);
                    } else {
                        throw new Error(result.error || 'Export failed');
                    }
                } else {
                    throw new Error('Export server error: ' + exportResponse.status);
                }
            } catch (error) {
                console.error('Export error:', error);
                hideLoading();
                alert(`Error exporting to ${format}: ${error.message}`);
            }
        }
        
        // Export Button Event Listeners
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    // Use download function
                    if (downloadBtn) downloadBtn.click();
                } else {
                    await exportToFormat(format);
                }
            });
        }
        
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compression & Merge/Split
        const compressPdfBtn = document.getElementById('compress-pdf-btn');
        const compressionQuality = document.getElementById('compression-quality');
        const compressBtn = document.getElementById('compress-btn');
        const mergeBtn = document.getElementById('merge-btn');
        const splitBtn = document.getElementById('split-btn');
        
        // Extra Functions - Security & Advanced
        const watermarkBtn = document.getElementById('watermark-btn');
        const signBtn = document.getElementById('sign-btn');
        const redactBtn = document.getElementById('redact-btn');
        const protectBtn = document.getElementById('protect-btn');
        
        // Watermark Implementation
        if (watermarkBtn) {
            watermarkBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const watermarkText = prompt('Enter watermark text:', 'CONFIDENTIAL');
                if (!watermarkText) return;
                
                const opacity = prompt('Enter opacity (0.1 to 1.0):', '0.3');
                const opacityValue = parseFloat(opacity) || 0.3;
                
                try {
                    showLoading('Adding watermark...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Applying watermark to all pages...');
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    const watermarkEdits = {
                        textEdits: []
                    };
                    
                    for (let i = 0; i < window.pdfEditorVars.totalPages; i++) {
                        watermarkEdits.textEdits.push({
                            pageIndex: i,
                            x: 200,
                            y: 400,
                            text: watermarkText,
                            fontSize: 48,
                            fontName: 'Helvetica',
                            fontColor: [0.7, 0.7, 0.7]
                        });
                    }
                    
                    const watermarkResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: watermarkEdits
                        })
                    });
                    
                    updateProgress(80, 'Processing...');
                    
                    if (watermarkResponse.ok) {
                        const result = await watermarkResponse.json();
                        if (result.success) {
                            updateProgress(95, 'Loading watermarked PDF...');
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Watermark added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Watermark added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Watermark failed');
                    }
                } catch (error) {
                    console.error('Watermark error:', error);
                    hideLoading();
                    alert('Error adding watermark: ' + error.message);
                }
            });
        }
        
        // Sign Implementation
        if (signBtn) {
            signBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const signerName = prompt('Enter signer name:', 'Your Name');
                if (!signerName) return;
                
                try {
                    showLoading('Adding digital signature...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    updateProgress(30, 'Loading PDF...');
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    updateProgress(50, 'Creating signature...');
                    const signatureEdits = {
                        textEdits: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 100,
                            text: `Digitally Signed by: ${signerName}\nDate: ${new Date().toLocaleDateString()}`,
                            fontSize: 12,
                            fontName: 'Helvetica',
                            fontColor: [0, 0, 0]
                        }],
                        stamps: [{
                            pageIndex: window.pdfEditorVars.totalPages - 1,
                            x: 100,
                            y: 50,
                            stampType: 'SIGNED',
                            width: 150,
                            height: 50
                        }]
                    };
                    
                    let apiUrl = '/api/pdf/edit';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/edit';
                    }
                    
                    updateProgress(70, 'Applying signature...');
                    const signResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            edits: signatureEdits
                        })
                    });
                    
                    updateProgress(90, 'Processing...');
                    
                    if (signResponse.ok) {
                        const result = await signResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            updateProgress(100, 'Signature added!');
                            setTimeout(() => {
                                hideLoading();
                                alert('Digital signature added successfully!');
                            }, 500);
                        }
                    } else {
                        throw new Error('Signature failed');
                    }
                } catch (error) {
                    console.error('Sign error:', error);
                    hideLoading();
                    alert('Error adding signature: ' + error.message);
                }
            });
        }
        
        // Redact Implementation
        if (redactBtn) {
            redactBtn.addEventListener('click', function() {
                window.pdfEditorVars.activeTool = 'redact';
                if (redactBtn) redactBtn.classList.add('active');
                if (highlightBtn) highlightBtn.classList.remove('active');
                if (selectTool) selectTool.classList.remove('active');
                
                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                }
                
                alert('Redact mode activated. Click and drag to select text to redact (black out).');
            });
        }
        
        // Redact drawing
        let redactStartX = null;
        let redactStartY = null;
        let redactRect = null;
        
        if (pdfCanvas && redactBtn) {
            const redactMouseDown = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact') {
                    const rect = pdfCanvas.getBoundingClientRect();
                    redactStartX = e.clientX - rect.left;
                    redactStartY = e.clientY - rect.top;
                    window.pdfEditorVars.isDrawing = true;
                    
                    redactRect = document.createElement('div');
                    redactRect.className = 'redact-rect';
                    redactRect.style.position = 'absolute';
                    redactRect.style.left = redactStartX + 'px';
                    redactRect.style.top = redactStartY + 'px';
                    redactRect.style.width = '0px';
                    redactRect.style.height = '0px';
                    redactRect.style.backgroundColor = '#000000';
                    redactRect.style.border = 'none';
                    redactRect.style.pointerEvents = 'auto';
                    redactRect.style.zIndex = '8';
                    redactRect.dataset.page = window.pdfEditorVars.currentPage;
                    if (deletionLayer) deletionLayer.appendChild(redactRect);
                }
            };
            
            const redactMouseMove = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing && redactRect) {
                    const rect = pdfCanvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - redactStartX);
                    const height = Math.abs(currentY - redactStartY);
                    const left = Math.min(redactStartX, currentX);
                    const top = Math.min(redactStartY, currentY);
                    
                    redactRect.style.left = left + 'px';
                    redactRect.style.top = top + 'px';
                    redactRect.style.width = width + 'px';
                    redactRect.style.height = height + 'px';
                }
            };
            
            const redactMouseUp = function(e) {
                if (window.pdfEditorVars.activeTool === 'redact' && window.pdfEditorVars.isDrawing && redactRect) {
                    window.pdfEditorVars.isDrawing = false;
                    
                    const width = parseFloat(redactRect.style.width);
                    const height = parseFloat(redactRect.style.height);
                    
                    if (width > 5 && height > 5) {
                        const redaction = {
                            pageIndex: window.pdfEditorVars.currentPage - 1,
                            x: parseFloat(redactRect.style.left),
                            y: parseFloat(redactRect.style.top),
                            width: width,
                            height: height,
                            type: 'redaction'
                        };
                        
                        const storedEdits = JSON.parse(sessionStorage.getItem('pdfEdits') || '{}');
                        if (!storedEdits.deletions) storedEdits.deletions = [];
                        storedEdits.deletions.push(redaction);
                        sessionStorage.setItem('pdfEdits', JSON.stringify(storedEdits));
                    } else {
                        redactRect.remove();
                    }
                    
                    window.pdfEditorVars.activeTool = 'select';
                    if (redactBtn) redactBtn.classList.remove('active');
                    if (selectTool) selectTool.classList.add('active');
                    if (pdfCanvas) pdfCanvas.style.cursor = 'default';
                    
                    redactStartX = null;
                    redactStartY = null;
                    redactRect = null;
                }
            };
            
            pdfCanvas.addEventListener('mousedown', redactMouseDown);
            pdfCanvas.addEventListener('mousemove', redactMouseMove);
            pdfCanvas.addEventListener('mouseup', redactMouseUp);
        }
        
        // Protect PDF Implementation
        if (protectBtn) {
            protectBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const password = prompt('Enter password to protect PDF:', '');
                if (!password) return;
                
                const confirmPassword = prompt('Confirm password:', '');
                if (password !== confirmPassword) {
                    alert('Passwords do not match!');
                    return;
                }
                
                alert('PDF password protection requires server-side encryption. This feature will be available in the next update with /api/pdf/protect endpoint.');
            });
        }
        
        // Rotate Page 90 degrees
        if (rotate90Btn) {
            rotate90Btn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/rotate';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/rotate';
                    }
                    
                    const rotateResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            rotations: [{ pageIndex: window.pdfEditorVars.currentPage - 1, angle: 90 }]
                        })
                    });
                    
                    if (rotateResponse.ok) {
                        const result = await rotateResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page rotated successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Rotate error:', error);
                    hideLoading();
                    alert('Error rotating page: ' + error.message);
                }
            });
        }
        
        // Delete Current Page
        if (deleteCurrentPageBtn) {
            deleteCurrentPageBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                if (!confirm('Are you sure you want to delete this page?')) return;
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/pages/delete';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/pages/delete';
                    }
                    
                    const deleteResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            pageIndices: [window.pdfEditorVars.currentPage - 1]
                        })
                    });
                    
                    if (deleteResponse.ok) {
                        const result = await deleteResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert('Page deleted successfully!');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Delete page error:', error);
                    hideLoading();
                    alert('Error deleting page: ' + error.message);
                }
            });
        }
        
        // Fill Form Fields
        if (fillFormBtn) {
            fillFormBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                // First detect form fields
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/forms/get-fields';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/forms/get-fields';
                    }
                    
                    const fieldsResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pdfData: `data:application/pdf;base64,${pdfBase64}` })
                    });
                    
                    if (fieldsResponse.ok) {
                        const result = await fieldsResponse.json();
                        if (result.success && result.formFields && result.formFields.length > 0) {
                            // Show form fill dialog
                            let formHtml = '<div style="padding: 20px;"><h3>Fill Form Fields</h3>';
                            result.formFields.forEach(field => {
                                formHtml += `<div style="margin: 10px 0;">
                                    <label>${field.name} (${field.type}):</label>
                                    <input type="text" id="field-${field.name}" value="${field.value || ''}" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>`;
                            });
                            formHtml += '<button onclick="fillFormSubmit()" style="margin-top: 15px; padding: 10px 20px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer;">Fill Form</button></div>';
                            
                            const formDialog = document.createElement('div');
                            formDialog.id = 'form-fill-dialog';
                            formDialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;';
                            formDialog.innerHTML = formHtml;
                            document.body.appendChild(formDialog);
                            
                            window.fillFormSubmit = async function() {
                                const formFields = result.formFields.map(field => ({
                                    fieldName: field.name,
                                    value: document.getElementById(`field-${field.name}`).value
                                }));
                                
                                let fillUrl = '/api/pdf/forms/fill';
                                if (window.location.protocol === 'file:') {
                                    fillUrl = 'http://localhost:3000/api/pdf/forms/fill';
                                }
                                
                                const fillResponse = await fetch(fillUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        pdfData: `data:application/pdf;base64,${pdfBase64}`,
                                        formFields: formFields
                                    })
                                });
                                
                                if (fillResponse.ok) {
                                    const fillResult = await fillResponse.json();
                                    if (fillResult.success) {
                                        const pdfData = await fetch(fillResult.pdfData).then(r => r.arrayBuffer());
                                        await renderPDF(pdfData);
                                        document.body.removeChild(formDialog);
                                        alert('Form filled successfully!');
                                    }
                                }
                                hideLoading();
                            };
                        } else {
                            alert('No form fields found in this PDF.');
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Form fill error:', error);
                    hideLoading();
                    alert('Error filling form: ' + error.message);
                }
            });
        }
        
        // Export to Different Formats - Enhanced with Progress
        if (exportBtn) {
            exportBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                const format = exportFormatSelect ? exportFormatSelect.value : 'pdf';
                if (format === 'pdf') {
                    if (downloadBtn) downloadBtn.click();
                    return;
                }
                
                await exportToFormat(format);
            });
        }
        
        // Individual Export Buttons
        if (exportWordBtn) {
            exportWordBtn.addEventListener('click', () => exportToFormat('word'));
        }
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', () => exportToFormat('excel'));
        }
        if (exportPptBtn) {
            exportPptBtn.addEventListener('click', () => exportToFormat('powerpoint'));
        }
        if (exportImageBtn) {
            exportImageBtn.addEventListener('click', () => exportToFormat('image'));
        }
        
        // Compress PDF
        if (compressPdfBtn) {
            compressPdfBtn.addEventListener('click', async function() {
                if (!window.pdfEditorVars.pdfDoc) {
                    alert('No PDF loaded');
                    return;
                }
                
                try {
                    showLoading('Processing...', 10);
                    const pdfFileURL = sessionStorage.getItem('pdfFileURL');
                    if (!pdfFileURL) throw new Error('PDF file not found');
                    
                    const response = await fetch(pdfFileURL);
                    const pdfArrayBuffer = await response.arrayBuffer();
                    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfArrayBuffer)));
                    
                    let apiUrl = '/api/pdf/compress';
                    if (window.location.protocol === 'file:') {
                        apiUrl = 'http://localhost:3000/api/pdf/compress';
                    }
                    
                    const compressResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdfData: `data:application/pdf;base64,${pdfBase64}`,
                            options: { quality: compressionQuality.value }
                        })
                    });
                    
                    if (compressResponse.ok) {
                        const result = await compressResponse.json();
                        if (result.success) {
                            const pdfData = await fetch(result.pdfData).then(r => r.arrayBuffer());
                            await renderPDF(pdfData);
                            alert(`PDF compressed! Size reduced by ${result.compressionRatio}%`);
                        }
                    }
                    hideLoading();
                } catch (error) {
                    console.error('Compress error:', error);
                    hideLoading();
                    alert('Error compressing PDF: ' + error.message);
                }
            });
        }
        
        // Initialize all button event listeners
        function initButtonEventListeners() {
            console.log('Initializing button event listeners...');
            
            // Re-get all button elements to ensure they exist
            const uploadBtn = document.getElementById('upload-btn');
            const downloadBtn = document.getElementById('download-btn');
            const ocrBtn = document.getElementById('ocr-btn');
            const addTextBtn = document.getElementById('add-text-btn');
            const addImageBtn = document.getElementById('add-image-btn');
            const highlightBtn = document.getElementById('highlight-btn');
            const selectTool = document.getElementById('select-tool');
            const fileInput = document.getElementById('file-input');
            const imageInput = document.getElementById('image-input');
            
            // Upload button
            if (uploadBtn && fileInput) {
                uploadBtn.addEventListener('click', function() {
                    console.log('Upload button clicked');
                    fileInput.click();
                });
                console.log('‚úÖ Upload button listener added');
            } else {
                console.error('‚ùå Upload button or file input not found!', { uploadBtn, fileInput });
            }
            
            // Download button - already has listener, but verify
            if (downloadBtn) {
                console.log('‚úÖ Download button found');
            } else {
                console.error('‚ùå Download button not found!');
            }
            
            // OCR button - already has listener, but verify
            if (ocrBtn) {
                console.log('‚úÖ OCR button found');
            } else {
                console.error('‚ùå OCR button not found!');
            }
            
            // Add Text button - already has listener, but verify
            if (addTextBtn) {
                console.log('‚úÖ Add Text button found');
            } else {
                console.error('‚ùå Add Text button not found!');
            }
            
            // Add Image button - already has listener, but verify
            if (addImageBtn) {
                console.log('‚úÖ Add Image button found');
            } else {
                console.error('‚ùå Add Image button not found!');
            }
            
            // Highlight button - already has listener, but verify
            if (highlightBtn) {
                console.log('‚úÖ Highlight button found');
            } else {
                console.error('‚ùå Highlight button not found!');
            }
            
            // Select tool - already has listener, but verify
            if (selectTool) {
                console.log('‚úÖ Select tool found');
            } else {
                console.error('‚ùå Select tool not found!');
            }
            
            console.log('Button event listeners initialization complete!');
        }
        
        // Initialize - ensure DOM is ready
        function initPDFEditor() {
            // Initialize button event listeners
            initButtonEventListeners();
            
            // Try to load PDF from storage
            const pdfFileURL = sessionStorage.getItem('pdfFileURL');
            if (pdfFileURL) {
                fetch(pdfFileURL)
                    .then(r => r.arrayBuffer())
                    .then(data => renderPDF(data))
                    .catch(e => console.warn('Could not load PDF from storage:', e));
            }
            
            // Ensure preview container is visible
            if (previewContainer) {
                previewContainer.style.display = 'flex';
                previewContainer.style.visibility = 'visible';
            }
            if (pdfPageWrapper) {
                pdfPageWrapper.style.display = 'block';
                pdfPageWrapper.style.visibility = 'visible';
            }
        }
        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPDFEditor);
        } else {
            // DOM already loaded
            initPDFEditor();
        }
    </script>
</body>
</html>

