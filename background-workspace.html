<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Background Removal Workspace - Edit & Download Transparent Images | easyjpgtopdf</title>
    <meta name="description" content="Background removal workspace. Edit and download transparent PNG images. Remove background from image online. Free AI background remover tool with instant processing.">
    <meta name="keywords" content="background removal workspace, remove background, transparent image, background remover, remove image background, ai background remover, transparent png, background removal tool, free background remover">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Background Removal Workspace - Edit & Download Transparent Images">
    <meta property="og:description" content="Edit and download transparent PNG images. Remove background from image online with AI.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://easyjpgtopdf.com/background-workspace.html">
<link href="css/footer.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<script type="importmap">
    {
      "imports": {
        "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.21.0/dist/ort.min.mjs"
      }
    }
  </script>
<style>
    :root {
      --primary: #4361ee;
      --secondary: #3a0ca3;
      --accent: #4cc9f0;
      --dark: #212529;
      --muted: #7a7f8c;
      --surface: #ffffff;
      --border: rgba(18, 20, 58, 0.1);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background: linear-gradient(180deg, #f3f4ff 0%, #f8f9ff 100%); color: var(--dark); min-height: 100vh; display: flex; flex-direction: column; }
    .topbar { background: var(--surface); box-shadow: 0 12px 30px rgba(14, 32, 86, 0.1); position: sticky; top: 0; z-index: 20; }
    .topbar .inner { max-width: 1200px; margin: 0 auto; padding: 14px 24px; display: flex; justify-content: space-between; align-items: center; gap: 18px; }
    .brand { display: flex; gap: 10px; align-items: center; font-weight: 700; font-size: 20px; color: var(--primary); text-decoration: none; }
    .quick-links { display: flex; gap: 10px; flex-wrap: wrap; }
    .quick-links a { text-decoration: none; padding: 8px 16px; border-radius: 999px; border: 1px solid var(--border); color: #253156; font-weight: 600; background: rgba(67, 97, 238, 0.08); transition: transform 0.2s, box-shadow 0.2s, background 0.2s; }
    .quick-links a:hover { background: linear-gradient(135deg, #4361ee, #3a0ca3); color: #fff; transform: translateY(-1px); box-shadow: 0 12px 24px rgba(67, 97, 238, 0.2); }
    main { flex: 1; width: 100%; max-width: 1200px; margin: 36px auto; padding: 0 24px 48px; display: grid; grid-template-columns: 1fr 40%; gap: 32px; align-items: start; }
    .panel { background: var(--surface); border-radius: 24px; padding: 28px; box-shadow: 0 20px 45px rgba(15, 30, 70, 0.08); }
    .panel h2 { font-size: 1.35rem; margin-bottom: 18px; display: flex; gap: 12px; align-items: center; color: #171f4d; }
    .preview-stage { position: relative; width: 8.5cm; height: 6cm; max-width: 100%; max-height: 100%; margin: 0 auto; border-radius: 18px; background: repeating-conic-gradient(#e5e9ff 0deg 25deg, #f8f9ff 25deg 50deg); overflow: hidden; display: flex; align-items: center; justify-content: center; }
    .preview-original, .preview-result { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; transition: opacity 0.6s ease; }
    .preview-result { opacity: 0; }
    .preview-stage.revealed .preview-result { opacity: 1; }
    .preview-stage.revealed .preview-original { opacity: 0; }
    .preview-overlay { position: absolute; inset: 0; background: rgba(17, 24, 39, 0.55); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px; color: #fff; font-weight: 600; letter-spacing: 0.03em; transition: opacity 0.4s ease; }
    .preview-stage.revealed .preview-overlay { opacity: 0; pointer-events: none; }
    .preview-stage.empty .preview-overlay { display: none; }
    .preview-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px; text-align: center; color: var(--muted); font-weight: 600; letter-spacing: 0.03em; }
    .preview-placeholder.hidden { display: none; }
    .preview-spinner { width: 34px; height: 34px; border: 3px solid rgba(255, 255, 255, 0.4); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    .actions { margin-top: 24px; display: flex; flex-wrap: wrap; gap: 14px; }
    .btn { display: inline-flex; align-items: center; gap: 8px; padding: 10px 22px; border-radius: 999px; border: none; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: transform 0.2s, box-shadow 0.2s; }
    .btn-primary { background: linear-gradient(135deg, #4361ee, #3a0ca3); color: #fff; box-shadow: 0 16px 30px rgba(67, 97, 238, 0.25); }
    .btn-outline { background: #fff; border: 1px solid var(--border); color: #233050; }
    .btn[disabled] { opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none; }
    .status-card { display: flex; flex-direction: column; gap: 18px; color: var(--muted); font-size: 0.95rem; line-height: 1.6; }
    .status-card strong { color: #1e254d; font-size: 1.05rem; }
    footer { text-align: center; padding: 24px 16px 40px; font-size: 0.85rem; color: var(--muted); }
    @keyframes spin { to { transform: rotate(360deg); } }
    @media (max-width: 960px) {
      main { grid-template-columns: 1fr; }
      .actions { justify-content: center; }
    }
  </style>
<link href="css/header.css" rel="stylesheet"/>
<link href="css/theme-modern.css" rel="stylesheet"/>
<link rel="stylesheet" href="css/voice-assistant.css">
<script src="js/voice-assistant.js" defer></script>
</head>
<body>
    <!-- Global Header Placeholder - Loaded by global-components.js -->
    <div id="global-header-placeholder"></div>
    <nav aria-label="Breadcrumb" style="padding: 15px 0; background: #f8f9ff; border-bottom: 1px solid #e2e6ff;">
        <div class="container" style="max-width: 1200px; margin: 0 auto; padding: 0 24px;">
            <ol style="list-style: none; display: flex; flex-wrap: wrap; gap: 10px; margin: 0; padding: 0; align-items: center;">
                <li><a href="index.html" style="color: #4361ee; text-decoration: none; font-weight: 500; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">Home</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="login.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Sign In</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="signup.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Signup</a></li>
            </ol>
        </div>
    </nav>
<main>
<section class="panel">
<h1>Free AI Background Remover - Remove Background from Image</h1>
<div class="preview-stage" id="previewStage">
<img alt="Original" class="preview-original" hidden="" id="previewOriginal"/>
<img alt="Result" class="preview-result" hidden="" id="previewResult"/>
<div class="preview-overlay" id="previewOverlay">
<div class="preview-spinner"></div>
<span>AI Processing...</span>
</div>
<div class="preview-placeholder hidden" id="previewPlaceholder">
<i class="fas fa-image" style="font-size:3rem;opacity:0.3;"></i>
<span>No image loaded</span>
</div>
</div>
<div class="actions">
<button class="btn btn-outline" disabled="" id="backgroundChange">
<i class="fas fa-palette"></i> Change Background
        </button>
<button class="btn btn-primary" disabled="" id="downloadPng">
<i class="fas fa-download"></i> Download PNG
        </button>
<button class="btn btn-primary" id="newUploadBtn" style="margin-left: 8px;">
<i class="fas fa-plus"></i> New Upload
        </button>
</div>
</section>
<section class="panel">
<h2>Processing Information</h2>
<div class="status-card" id="statusMessage"></div>
<!-- Animated Demo -->
<div style="margin: 16px 0; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(67,97,238,0.15);">
<img alt="AI Processing Demo" src="images/bg-removal-jungle-demo.svg" style="width: 100%; height: auto; display: block;"/>
</div>
<div class="status-card">
<strong>? Professional AI Processing</strong>
<p>ÔøΩ Fast and accurate background removal</p>
<p>ÔøΩ Automatic processing for optimal results</p>
<p>ÔøΩ Professional quality output</p>
<p>ÔøΩ Unlimited uploads and downloads</p>
<p>ÔøΩ High-quality transparent PNG output</p>
</div>
</section>
</main>
<script type="module">
    const STORAGE_KEYS = {
      original: 'bgRemover:original',
      filename: 'bgRemover:filename',
      foreground: 'bgRemover:foreground',
      dimensions: 'bgRemover:dimensions'
    };

    const previewStage = document.getElementById('previewStage');
    const previewOriginal = document.getElementById('previewOriginal');
    const previewResult = document.getElementById('previewResult');
    const previewOverlay = document.getElementById('previewOverlay');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const backgroundChangeBtn = document.getElementById('backgroundChange');
    const downloadBtn = document.getElementById('downloadPng');
    const statusMessage = document.getElementById('statusMessage');

    let resultCanvas = null;
    let resultContext = null;
    let resultDataURL = null;
    
    // IMG.LY library REMOVED - Using backend only for best quality

    function dataURLToBlob(dataURL) {
      const [meta, encoded] = dataURL.split(',');
      const mimeMatch = meta.match(/data:(.*?);/);
      const mime = mimeMatch ? mimeMatch[1] : 'image/png';
      const binary = atob(encoded);
      const len = binary.length;
      const buffer = new Uint8Array(len);
      for (let i = 0; i < len; i++) buffer[i] = binary.charCodeAt(i);
      return new Blob([buffer], { type: mime });
    }

    async function blobFromSource(source, meta) {
      if (!source) return null;
      if (source.startsWith('data:')) {
        return dataURLToBlob(source);
      }
      if (source.startsWith('blob:')) {
        return await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', source);
          xhr.responseType = 'blob';
          xhr.onload = () => {
            const responseBlob = xhr.response;
            if (responseBlob && meta?.type && responseBlob.type !== meta.type) {
              resolve(responseBlob.slice(0, responseBlob.size, meta.type));
            } else {
              resolve(responseBlob);
            }
          };
          xhr.onerror = () => reject(new Error('Failed to read blob URL.'));
          xhr.send();
        });
      }
      const response = await fetch(source);
      return await response.blob();
    }

    function blobToDataURL(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function showError(message) {
      statusMessage.innerHTML = `<div style="padding:16px;border-radius:14px;background:rgba(220,38,38,0.12);color:#7f1d1d;font-weight:600;">${message}</div>`;
    }

    function showStatus(message) {
      statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(34,197,94,0.12);color:#065f46;font-weight:600;">${message}</div>`;
      setTimeout(() => {
        if (statusMessage.textContent?.includes(message)) {
          clearStatus();
        }
      }, 3000);
    }

    function clearStatus() {
      statusMessage.innerHTML = '';
    }

    function ensureCanvas(width, height) {
      if (!resultCanvas) {
        resultCanvas = document.createElement('canvas');
        resultContext = resultCanvas.getContext('2d');
      }
      resultCanvas.width = width;
      resultCanvas.height = height;
    }

    // ============================================
    // HIGH QUALITY AI BACKGROUND REMOVER
    // Professional AI Processing System
    // ============================================
    // Use proxy endpoint for processing
    // ============================================
    
    // Device Fingerprinting - REMOVED (not needed for browser MODNet)
    // All processing is done in browser - no backend needed
    
    // ============================================
    // MODNet Browser-Based Background Remover
    // Unlimited, High-Quality, Original Quality
    // Runs entirely in browser - No backend needed
    // ============================================
    
    let modnetSession = null;
    let modnetModelLoaded = false;
    const MODNET_MODEL_URL = 'https://github.com/ZHKKKe/MODNet/releases/download/v1.0.0/modnet_webcam_portrait_matting.onnx';
    
    // Load MODNet model using ONNX Runtime Web
    async function loadMODNetModel() {
      if (modnetModelLoaded && modnetSession) {
        return modnetSession;
      }
      
      try {
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">?? Loading MODNet AI model...</div>`;
        
        const ort = await import('onnxruntime-web');
        
        // Use GitHub releases URL (more reliable than jsdelivr)
        // Try multiple sources for better reliability
        const modelUrls = [
          MODNET_MODEL_URL, // GitHub releases (primary)
          'https://github.com/ZHKKKe/MODNet/releases/download/v1.0.0/modnet_webcam_portrait_matting.onnx',
          'https://raw.githubusercontent.com/ZHKKKe/MODNet/master/pretrained/modnet_webcam_portrait_matting.onnx'
        ];
        
        let lastError = null;
        for (const modelUrl of modelUrls) {
          try {
            console.log(`üîÑ Trying to load MODNet from: ${modelUrl}`);
            modnetSession = await ort.InferenceSession.create(modelUrl, {
              executionProviders: ['wasm'], // Use WebAssembly for better performance
              graphOptimizationLevel: 'all'
            });
            modnetModelLoaded = true;
            console.log('‚úÖ MODNet model loaded successfully from:', modelUrl);
            return modnetSession;
          } catch (urlError) {
            console.warn(`‚ö†Ô∏è Failed to load from ${modelUrl}:`, urlError);
            lastError = urlError;
            continue; // Try next URL
          }
        }
        
        // If all URLs failed, throw the last error
        throw lastError || new Error('All MODNet model URLs failed');
      } catch (error) {
        console.error('‚ùå Failed to load MODNet model:', error);
        throw new Error('MODNet model failed to load. Please refresh the page.');
      }
    }
    
    // Preprocess image for MODNet (resize to 512x512, normalize)
    function preprocessImageForMODNet(image) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const targetSize = 512;
      
      canvas.width = targetSize;
      canvas.height = targetSize;
      
      // Draw image maintaining aspect ratio
      ctx.drawImage(image, 0, 0, targetSize, targetSize);
      
      // Get image data
      const imageData = ctx.getImageData(0, 0, targetSize, targetSize);
      const data = imageData.data;
      
      // Convert to tensor format (normalize to 0-1, RGB format for MODNet)
      const tensor = new Float32Array(3 * targetSize * targetSize);
      
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        const idx = Math.floor(i / 4);
        // RGB format and normalize (MODNet expects RGB)
        tensor[idx] = (r / 255.0 - 0.5) / 0.5; // Normalize to [-1, 1]
        tensor[idx + targetSize * targetSize] = (g / 255.0 - 0.5) / 0.5;
        tensor[idx + 2 * targetSize * targetSize] = (b / 255.0 - 0.5) / 0.5;
      }
      
      return {
        tensorData: tensor,
        tensorShape: [1, 3, targetSize, targetSize],
        originalWidth: image.width,
        originalHeight: image.height
      };
    }
    
    // Helper to create ONNX tensor
    async function createONNXTensor(tensorData, tensorShape) {
      const ort = await import('onnxruntime-web');
      return new ort.Tensor('float32', tensorData, tensorShape);
    }
    
    // Postprocess MODNet output (resize mask to original size, apply to image)
    function postprocessMODNetMask(maskTensor, originalWidth, originalHeight, originalImage) {
      const maskData = maskTensor.data;
      const maskSize = Math.sqrt(maskData.length);
      
      // Create mask canvas
      const maskCanvas = document.createElement('canvas');
      const maskCtx = maskCanvas.getContext('2d');
      maskCanvas.width = maskSize;
      maskCanvas.height = maskSize;
      
      const maskImageData = maskCtx.createImageData(maskSize, maskSize);
      
      for (let i = 0; i < maskData.length; i++) {
        const alpha = Math.min(255, Math.max(0, maskData[i] * 255));
        const idx = i * 4;
        maskImageData.data[idx] = alpha;     // R
        maskImageData.data[idx + 1] = alpha; // G
        maskImageData.data[idx + 2] = alpha; // B
        maskImageData.data[idx + 3] = alpha; // A
      }
      
      maskCtx.putImageData(maskImageData, 0, 0);
      
      // Resize mask to original image size
      const resizedMaskCanvas = document.createElement('canvas');
      const resizedMaskCtx = resizedMaskCanvas.getContext('2d');
      resizedMaskCanvas.width = originalWidth;
      resizedMaskCanvas.height = originalHeight;
      resizedMaskCtx.drawImage(maskCanvas, 0, 0, originalWidth, originalHeight);
      
      // Apply mask to original image
      const outputCanvas = document.createElement('canvas');
      const outputCtx = outputCanvas.getContext('2d');
      outputCanvas.width = originalWidth;
      outputCanvas.height = originalHeight;
      
      // Draw original image
      outputCtx.drawImage(originalImage, 0, 0);
      
      // Apply mask as alpha channel
      const outputImageData = outputCtx.getImageData(0, 0, originalWidth, originalHeight);
      const maskImageDataResized = resizedMaskCtx.getImageData(0, 0, originalWidth, originalHeight);
      
      for (let i = 0; i < outputImageData.data.length; i += 4) {
        const alpha = maskImageDataResized.data[i]; // Use R channel as alpha
        outputImageData.data[i + 3] = alpha; // Set alpha channel
      }
      
      outputCtx.putImageData(outputImageData, 0, 0);
      
      return outputCanvas.toDataURL('image/png');
    }
    
    // Process image with MODNet (browser-based)
    async function processWithMODNet(dataURL) {
      try {
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">?? Processing with MODNet AI...</div>`;
        
        // Load model if not loaded
        const session = await loadMODNetModel();
        
        // Load original image
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = dataURL;
        });
        
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">?? Running AI inference...</div>`;
        
        // Preprocess
        const { tensorData, tensorShape, originalWidth, originalHeight } = preprocessImageForMODNet(img);
        
        // Create ONNX tensor
        const tensor = await createONNXTensor(tensorData, tensorShape);
        
        // Run inference
        const feeds = { input: tensor };
        const results = await session.run(feeds);
        const maskTensor = results.output || results[Object.keys(results)[0]];
        
        // Postprocess
        const resultDataURL = postprocessMODNetMask(maskTensor, originalWidth, originalHeight, img);
        
        return {
          success: true,
          dataUrl: resultDataURL,
          processedWith: 'MODNet Browser AI'
        };
      } catch (error) {
        console.error('MODNet processing error:', error);
        return {
          success: false,
          error: `MODNet processing failed: ${error.message}`
        };
      }
    }
    
    // Processing config - Always use browser MODNet (unlimited, high quality)
    function getProcessingConfig(fileSize) {
      const sizeMB = fileSize / (1024 * 1024);
      
      return {
        useBrowser: true,
        description: 'MODNet Browser AI',
        message: `Processing ${sizeMB.toFixed(1)} MB with MODNet AI`,
        tier: 'browser-ai',
        info: '?? MODNet Browser AI Processing',
        quality: 1.0 // Original quality
      };
    }

    // OLD BACKEND FUNCTION - REMOVED (Now using MODNet browser version)
    // This function is kept for reference but NOT USED
    async function processWithBackend_OLD_UNUSED(dataURL, backendUrl, config) {
      try {
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">?? Uploading for AI processing...</div>`;
        
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 180000);
        
        // Log request details for debugging (OLD BACKEND - NOT USED)
        const imageSize = Math.ceil((dataURL.split(',')[1]?.length || 0) * 0.75 / 1024);
        console.log('?? [OLD BACKEND] Image size:', imageSize, 'KB');
        
        // Use JSON format (proxy handles conversion)
        let response = null;
        
        try {
          // Get user info and device ID
          const userInfo = await getUserInfo();
          
          // OLD BACKEND - NOT USED (MODNet browser version is used instead)
          response = await fetch('/api/background-remove-pytorch-DISABLED', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'X-User-ID': userInfo.userId,
              'X-User-Type': userInfo.userType,
              'X-Device-ID': DEVICE_ID,
              'X-Auth-Token': userInfo.authToken || ''
            },
            body: JSON.stringify({ imageData: dataURL }),
            signal: controller.signal
          });
          
          console.log('?? Response received:', {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok,
            headers: Object.fromEntries(response.headers.entries())
          });
        } catch (fetchError) {
          console.error('? Request failed:', {
            name: fetchError.name,
            message: fetchError.message,
            stack: fetchError.stack
          });
          throw fetchError;
        }
        
        clearTimeout(timeout);

        // Check response status
        if (!response || !response.ok) {
          // If we have a response but it's not OK, handle the error
          if (response && !response.ok) {
            const errorText = await response.text();
            let errorData = {};
            try {
              errorData = JSON.parse(errorText);
            } catch (e) {
              errorData = { error: errorText || `Server error: ${response.status}` };
            }
            console.error('? Server error:', {
              status: response.status,
              statusText: response.statusText,
              error: errorData
            });
            throw new Error(errorData.error || `Server error: ${response.status} ${response.statusText}`);
          } else {
            throw new Error('No response from server. Please check your connection.');
          }
        }

        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(34,197,94,0.12);color:#065f46;font-weight:600;">? Processing with professional AI...</div>`;
        
        const result = await response.json();
        console.log('? Processing result:', {
          success: result.success,
          hasResultImage: !!result.resultImage,
          outputSize: result.outputSizeMB || 'unknown'
        });
        
        if (result.success && result.resultImage) {
          return { 
            success: true, 
            dataUrl: result.resultImage, 
            processedWith: result.processedWith || config.description,
            outputSize: result.outputSize,
            outputSizeMB: result.outputSizeMB
          };
        } else {
          throw new Error(result.error || 'Processing failed on server');
        }
      } catch (error) {
        console.error('? Backend processing error:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        
        if (error.name === 'AbortError') {
          return { 
            success: false, 
            error: 'Request timeout. The file may be too large or the server is busy. Please try again or use a smaller image.' 
          };
        }
        
        // Provide more specific error messages - NO FALLBACK
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          return { 
            success: false, 
            error: 'Network error. Please check your internet connection and try again. If the problem persists, the server may be temporarily unavailable. Backend processing is required - no fallback available.' 
          };
        }
        
        // Check if error message contains service unavailable info
        let errorMessage = error.message || 'Backend processing failed. Please try again.';
        
        // Extract nested error messages from proxy responses
        if (errorMessage.includes('service is temporarily unavailable')) {
          errorMessage = 'Service is warming up. Please wait 15-20 seconds and try again. The service is configured to stay warm, but first request may take longer.';
        } else if (errorMessage.includes('cold starting') || errorMessage.includes('warming up')) {
          errorMessage = 'Service is warming up. Please wait 15-20 seconds and try again.';
        }
        
        return { 
          success: false, 
          error: `Backend processing failed: ${errorMessage}. Please try again or contact support.` 
        };
      }
    }

    async function processImage(dataURL) {
      clearStatus();
      previewPlaceholder.classList.add('hidden');
      previewStage.classList.remove('revealed');
      previewStage.classList.remove('empty');
      previewOverlay.style.opacity = 1;

      try {
        previewOriginal.hidden = false;
        previewOriginal.src = dataURL;
        
        // Get file size and optimal config
        const fileSize = Number(sessionStorage.getItem('bgRemover:originalSize') || 0);
        const config = getProcessingConfig(fileSize);
        
        // Check for error (file too large)
        if (config.error) {
          showError(config.message);
          previewStage.classList.add('empty');
          previewOverlay.style.opacity = 0;
          previewPlaceholder.classList.remove('hidden');
          return;
        }
        
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">${config.message}...</div>`;

        let resultUrl = null;
        let processingMethod = 'Browser AI';

        // ===== Browser MODNet Processing =====
        if (config.useBrowser) {
          statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(67,97,238,0.08);color:#1f2559;font-weight:600;">${config.info}</div>`;
          
          const modnetResult = await processWithMODNet(dataURL);
          
          if (modnetResult.success) {
            resultUrl = modnetResult.dataUrl;
            processingMethod = modnetResult.processedWith || config.description;
            
            console.log('‚úÖ MODNet processing successful:', {
              tier: config.tier,
              method: processingMethod
            });
          } else {
            throw new Error(modnetResult.error || 'MODNet processing failed');
          }
        }
        
        if (!resultUrl) {
          throw new Error('Image processing failed. Please try again.');
        }
        
        sessionStorage.setItem(STORAGE_KEYS.foreground, resultUrl);

        const foregroundImage = new Image();
        foregroundImage.crossOrigin = 'anonymous';
        foregroundImage.src = resultUrl;
        await foregroundImage.decode();

        previewResult.hidden = false;
        previewResult.src = resultUrl;

        ensureCanvas(foregroundImage.width, foregroundImage.height);
        resultContext.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
        resultContext.drawImage(foregroundImage, 0, 0, resultCanvas.width, resultCanvas.height);
        resultDataURL = resultCanvas.toDataURL('image/png');

        sessionStorage.setItem(STORAGE_KEYS.dimensions, JSON.stringify({ width: resultCanvas.width, height: resultCanvas.height }));
        previewOverlay.style.opacity = 0;
        requestAnimationFrame(() => previewStage.classList.add('revealed'));
        backgroundChangeBtn.disabled = false;
        downloadBtn.disabled = false;
        
        // Success message
        const sizeInMB = (fileSize / (1024 * 1024)).toFixed(1);
        const methodLabel = processingMethod || config.description;
        statusMessage.innerHTML = `<div style="padding:12px 16px;border-radius:12px;background:rgba(34,197,94,0.12);color:#065f46;font-weight:600;">? Background removed! (${sizeInMB} MB file processed with ${methodLabel})</div>`;
        setTimeout(() => clearStatus(), 4000);
        
      } catch (error) {
        console.error('Background removal failed', error);
        let errorMsg = '';
        
        // Extract error message from error object
        const errorMessage = error.message || error.error || 'Unknown error';
        
        // Handle different error types
        if (errorMessage.includes('fetch') || errorMessage.includes('NetworkError') || errorMessage.includes('Failed to fetch')) {
          errorMsg = 'Network error. Please check your internet connection and try again.';
        } else if (errorMessage.includes('timeout') || errorMessage.includes('AbortError')) {
          errorMsg = 'Request timeout. The image may be too large or the server is busy. Please try again with a smaller image.';
        } else if (errorMessage.includes('memory') || errorMessage.includes('too large')) {
          errorMsg = 'Image too large or complex. Please try a smaller image (max 10MB).';
        } else if (errorMessage.includes('Processing failed') || errorMessage.includes('Internal server error')) {
          errorMsg = 'Processing failed. Please try again with a different image. If the problem persists, the service may be temporarily unavailable.';
        } else if (errorMessage.includes('temporarily unavailable') || errorMessage.includes('warming up')) {
          errorMsg = 'Service is warming up. Please wait 15-20 seconds and try again.';
        } else if (errorMessage.includes('Invalid image') || errorMessage.includes('Failed to load image')) {
          errorMsg = 'Invalid image file. Please ensure you are uploading a valid image (JPG, PNG, etc.).';
        } else {
          // Use the actual error message if available
          errorMsg = errorMessage || 'Failed to remove background. Please try again.';
        }
        
        showError(errorMsg);
        previewStage.classList.add('empty');
        previewOverlay.style.opacity = 0;
        previewPlaceholder.classList.remove('hidden');
      }
    }

    // OLD BACKEND WARMUP CODE - REMOVED (MODNet browser version doesn't need backend)
    // All processing is done in browser - no warmup needed
    
    const storedOriginal = sessionStorage.getItem(STORAGE_KEYS.original);
    if (!storedOriginal) {
      previewStage.classList.add('empty');
      previewPlaceholder.classList.remove('hidden');
      showError('No image found. Please upload a file first.');
      backgroundChangeBtn.disabled = true;
      downloadBtn.disabled = true;
    } else {
      processImage(storedOriginal);
    }

    backgroundChangeBtn.addEventListener('click', () => {
      if (backgroundChangeBtn.disabled) return;
      window.location.href = 'background-style.html';
    });

    downloadBtn.addEventListener('click', () => {
      if (!resultDataURL) return;
      
      try {
        // Download
        const link = document.createElement('a');
        const filename = sessionStorage.getItem(STORAGE_KEYS.filename) || 'background-removed.png';
        link.href = resultDataURL;
        link.download = filename.endsWith('.png') ? filename : `${filename.replace(/\.[^/.]+$/, '') || 'background-removed'}.png`;
        link.click();
        
        // Show success message
        showStatus('Downloaded successfully.');
      } catch (error) {
        console.error('Download error:', error);
        showError('Download failed. Please try again.');
      }
    });

    // New Upload button - redirect to upload page
    const newUploadBtn = document.getElementById('newUploadBtn');
    if (newUploadBtn) {
      newUploadBtn.addEventListener('click', () => {
        window.location.href = 'background-remover.html';
      });
    }

    const footerYear = document.getElementById('footerYear');
    if (footerYear) {
      footerYear.textContent = new Date().getFullYear();
    }
    
    // Initialize MODNet model on page load (preload for faster processing)
    loadMODNetModel().catch(err => {
      console.warn('MODNet preload failed (will load on first use):', err);
    });
  </script>
    
    <!-- Auth and Firebase scripts loaded by global-components.js -->

    <!-- Global Footer Placeholder - Loaded by global-components.js -->
    <div id="global-footer-placeholder"></div>
    
    <!-- Load global header and footer components -->
    <script src="js/global-components.js"></script>
    <script>
    // Ensure header loads - multiple attempts to guarantee it works
    (function() {
        function tryLoadHeader() {
            if (typeof loadGlobalHeader === 'function') {
                try {
                    loadGlobalHeader();
                    return true;
                } catch (e) {
                    console.error('Error calling loadGlobalHeader:', e);
                }
            }
            return false;
        }
        
        // Try immediately if script already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            if (!tryLoadHeader()) {
                // Script not loaded yet, wait for it
                var attempts = 0;
                var maxAttempts = 60; // 3 seconds total
                var checkHeader = setInterval(function() {
                    attempts++;
                    if (tryLoadHeader() || attempts >= maxAttempts) {
                        clearInterval(checkHeader);
                    }
                }, 50);
            }
        } else {
            // Wait for DOM to be ready
            document.addEventListener('DOMContentLoaded', function() {
                if (!tryLoadHeader()) {
                    var attempts = 0;
                    var maxAttempts = 40;
                    var checkHeader = setInterval(function() {
                        attempts++;
                        if (tryLoadHeader() || attempts >= maxAttempts) {
                            clearInterval(checkHeader);
                        }
                    }, 50);
                }
            });
        }
        
        // Final backup attempt on window load
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (!document.querySelector('header') && typeof loadGlobalHeader === 'function') {
                    loadGlobalHeader();
                }
            }, 100);
        });
    })();
    </script>
</body>
</html>

