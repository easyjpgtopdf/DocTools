<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Background Style - Online Free Tool | easyjpgtopdf</title>
    <meta name="description" content="Use our free Background Style tool online. Fast, secure, and easy to use.">
    <meta name="keywords" content="background-style, background style, free background-style, online background-style">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://easyjpgtopdf.com/background-style.html">
    <meta name="author" content="easyjpgtopdf">
    <meta property="og:title" content="Background Style Editor - Change Image Background Colors & Styles">
    <meta property="og:description" content="Change background style and colors of images. Edit image backgrounds with custom colors and styles.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://easyjpgtopdf.com/background-style.html">
<link href="css/footer.css" rel="stylesheet"/>
<script type="module" src="js/device-fingerprint.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
    :root {
      --primary: #4361ee;
      --secondary: #3a0ca3;
      --accent: #4cc9f0;
      --dark: #1a214d;
      --muted: #6f7694;
      --surface: #ffffff;
      --border: rgba(20, 28, 72, 0.12);
      --chip-bg: rgba(67, 97, 238, 0.08);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background: linear-gradient(180deg, #f3f4ff 0%, #f8f9ff 100%); color: var(--dark); min-height: 100vh; display: flex; flex-direction: column; }
    
    .container { width: 100%; max-width: 1200px; margin: 0 auto; padding: 0 24px; }

    .logo i { color: var(--secondary); }
    
    .nav-links > a,
    .dropdown-toggle { display: inline-flex; align-items: center; gap: 6px; color: var(--dark); font-weight: 500; text-decoration: none; font-size: 0.95rem; padding: 8px 0; }
    .nav-links > a:hover,
    .nav-links > a.active,
    .dropdown > a:hover { color: var(--primary); }
    
    .dropdown-toggle::after { content: '\f107'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 0.75rem; }
    
    .dropdown-content a { display: block; padding: 10px 20px; color: var(--dark); white-space: nowrap; }
    .dropdown-content a:hover { background: rgba(67, 97, 238, 0.08); }
    .dropdown:hover 
    .btn-outline { background: transparent; border: 1px solid rgba(67, 97, 238, 0.35); color: var(--primary); }
    .btn-outline:hover { background: rgba(67, 97, 238, 0.08); }
    .auth-buttons { display: flex; gap: 10px; align-items: center; }
    .topbar { max-width: 1200px; margin: 0 auto; padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; gap: 16px; }
    .topbar h1 { font-size: 1.6rem; color: #131a48; }
    .breadcrumbs { display: flex; gap: 8px; align-items: center; font-size: 0.95rem; color: var(--muted); }
    .breadcrumbs a { color: var(--primary); text-decoration: none; }
    .stage { flex: 1; width: 100%; max-width: 1200px; margin: 36px auto; padding: 0 24px 60px; display: grid; grid-template-columns: minmax(320px, 1fr) minmax(360px, 420px); gap: 28px; align-items: start; }
    .panel { background: var(--surface); border-radius: 24px; padding: 28px; box-shadow: 0 22px 45px rgba(16, 30, 70, 0.08); border: 1px solid var(--border); }
    .panel h2 { font-size: 1.25rem; margin-bottom: 18px; color: #121a4c; display: flex; align-items: center; gap: 10px; }
    .preview-stage { position: relative; width: 8.5cm; height: 6cm; max-width: 100%; max-height: 100%; margin: 0 auto; border-radius: 18px; background: repeating-conic-gradient(#e5e9ff 0deg 25deg, #f8f9ff 25deg 50deg); overflow: hidden; display: flex; align-items: center; justify-content: center; }
    .preview-original, .preview-result { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; transition: opacity 0.6s ease; border: none; outline: none; box-shadow: none; }
    .preview-result { opacity: 0; }
    .preview-stage.revealed .preview-result { opacity: 1; }
    .preview-stage.revealed .preview-original { opacity: 0; }
    .preview-overlay { position: absolute; inset: 0; background: rgba(17, 24, 39, 0.55); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px; color: #fff; font-weight: 600; letter-spacing: 0.03em; transition: opacity 0.4s ease; }
    .preview-stage.revealed .preview-overlay { opacity: 0; pointer-events: none; }
    .preview-stage.empty .preview-overlay { display: none; }
    .preview-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px; text-align: center; color: var(--muted); font-weight: 600; letter-spacing: 0.03em; }
    .preview-placeholder.hidden { display: none; }
    .preview-spinner { width: 34px; height: 34px; border: 3px solid rgba(255, 255, 255, 0.4); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    .preview-frame { border-radius: 20px; width: 8.6cm; height: 8.6cm; max-width: 100%; max-height: 100%; overflow: hidden; position: relative; background: #f1f1ff; margin: 0 auto; display: flex; align-items: center; justify-content: center; }
    .preview-frame canvas { 
      width: 100%; 
      height: 100%; 
      object-fit: contain; 
      display: block;
      border: none;
      outline: none;
      box-shadow: none;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
    .category-tabs { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px; }
    .tab-button { border-radius: 999px; padding: 8px 18px; border: 1px solid var(--border); background: var(--chip-bg); color: #243163; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s, background 0.2s; }
    .tab-button.active { background: linear-gradient(135deg, #4361ee, #3a0ca3); color: #fff; box-shadow: 0 16px 30px rgba(67, 97, 238, 0.2); }
    .tab-button:hover { transform: translateY(-1px); }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(1.5cm, 1.5cm)); grid-auto-rows: 1.5cm; gap: 8px; width: 8.6cm; max-width: 100%; max-height: 8.6cm; margin: 0 auto 24px; padding-right: 6px; overflow-y: auto; justify-content: center; }
    .thumb { position: relative; width: 1.5cm; height: 1.5cm; border-radius: 10px; overflow: hidden; cursor: pointer; border: 2px solid transparent; box-shadow: 0 10px 20px rgba(18, 30, 60, 0.12); transition: transform 0.2s, border-color 0.2s; }
    .thumb img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .thumb span { position: absolute; bottom: 4px; left: 4px; right: 4px; text-align: center; background: rgba(15, 23, 42, 0.6); color: #fff; padding: 2px 4px; border-radius: 999px; font-size: 0.55rem; font-weight: 600; letter-spacing: 0.03em; line-height: 1.2; }
    .thumb:hover { transform: translateY(-3px); }
    .thumb.selected { border-color: var(--primary); }
    .color-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 14px; }
    .color-chip { width: 100%; padding-bottom: 100%; border-radius: 16px; position: relative; cursor: pointer; border: 2px solid transparent; box-shadow: 0 12px 25px rgba(16, 32, 70, 0.08); }
    .color-chip .fill { position: absolute; inset: 0; border-radius: 14px; }
    .color-chip.selected { border-color: var(--primary); }
    .actions { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 24px; }
    .btn { display: inline-flex; align-items: center; gap: 8px; border-radius: 999px; padding: 10px 22px; border: none; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: transform 0.2s, box-shadow 0.2s; }
    .btn-primary { background: linear-gradient(135deg, #4361ee, #3a0ca3); color: #fff; box-shadow: 0 16px 30px rgba(67, 97, 238, 0.25); }
    .btn-outline { background: #fff; border: 1px solid var(--border); color: #233150; }
    .btn[disabled] { opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none; }
    .status { font-size: 0.92rem; color: var(--muted); margin-top: 14px; min-height: 1.2rem; }
    .overlay-deck { width: 100%; max-width: 1200px; margin: 0 auto 60px; padding: 0 24px; }
    .overlay-panel { margin-top: 0; }
    .overlay-controls { background: rgba(67, 97, 238, 0.08); border: 1px solid rgba(67, 97, 238, 0.15); border-radius: 18px; padding: 16px 18px; display: flex; flex-direction: column; gap: 14px; }
    .overlay-controls 
    .overlay-switch { display: flex; align-items: center; gap: 8px; font-weight: 600; cursor: pointer; }
    .overlay-fields { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
    .overlay-fields.hidden { display: none; }
    .overlay-fields label { display: flex; flex-direction: column; gap: 6px; font-size: 0.85rem; color: var(--muted); font-weight: 600; }
    .overlay-fields textarea { border: 1px solid rgba(20, 28, 72, 0.16); border-radius: 12px; padding: 10px 14px; font-size: 0.95rem; color: #1f2559; background: #fff; min-height: 90px; resize: vertical; }
    .overlay-fields input[type="color"] { width: 100%; height: 44px; border: 1px solid rgba(20, 28, 72, 0.16); border-radius: 12px; padding: 6px; background: #fff; }
    .overlay-fields select, .overlay-fields input[type="range"] { appearance: none; border: 1px solid rgba(20,28,72,0.16); border-radius: 12px; padding: 8px 12px; font-size: 0.95rem; color: #1f2559; background: #fff; }
    .overlay-fields input:disabled, .overlay-fields select:disabled { opacity: 0.5; cursor: not-allowed; }
    .overlay-range-value { font-weight: 600; color: #1f2559; font-size: 0.9rem; }
    .overlay-manual { display: flex; flex-direction: column; gap: 6px; }
    /* Download Modal Styles */
    .download-modal { display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.6); z-index: 1000; align-items: center; justify-content: center; }
    .download-modal.active { display: flex; }
    .download-modal-content { background: #fff; border-radius: 20px; padding: 32px; max-width: 480px; width: 90%; box-shadow: 0 24px 60px rgba(0, 0, 0, 0.3); }
    .download-modal-
    .download-modal-header h3 { font-size: 1.4rem; color: #1a214d; margin-bottom: 8px; }
    .download-modal-header p { color: var(--muted); font-size: 0.95rem; }
    .download-options { display: flex; flex-direction: column; gap: 16px; margin-bottom: 24px; }
    .download-option { border: 2px solid var(--border); border-radius: 16px; padding: 20px; cursor: pointer; transition: all 0.3s; background: #fff; }
    .download-option:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 20px rgba(67, 97, 238, 0.15); }
    .download-option.disabled { opacity: 0.6; cursor: not-allowed; background: #f5f5f5; }
    .download-option-
    .download-option-title { font-weight: 700; font-size: 1.1rem; color: #1a214d; }
    .download-option-badge { padding: 4px 12px; border-radius: 999px; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
    .download-option-badge.free { background: rgba(34, 197, 94, 0.15); color: #059669; }
    .download-option-badge.premium { background: rgba(67, 97, 238, 0.15); color: var(--primary); }
    .download-option-details { color: var(--muted); font-size: 0.9rem; line-height: 1.6; }
    .download-option-details strong { color: #1a214d; }
    .size-selection { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); display: none; }
    .size-selection.active { display: block; }
    .size-selection label { display: block; font-size: 0.85rem; color: var(--muted); margin-bottom: 8px; font-weight: 600; }
    .size-select { width: 100%; padding: 10px 14px; border: 1px solid var(--border); border-radius: 12px; font-size: 0.95rem; color: #1a214d; background: #fff; cursor: pointer; transition: border-color 0.2s; }
    .size-select:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1); }
    .size-info { margin-top: 8px; font-size: 0.8rem; color: var(--muted); }
    .download-modal-actions { display: flex; gap: 12px; justify-content: flex-end; }
    @media (max-width: 640px) {
      .download-modal-content { padding: 24px; max-width: 95%; }
      .size-select { font-size: 0.9rem; padding: 8px 12px; }
    }
    .download-modal-actions button { padding: 10px 20px; border-radius: 999px; border: none; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: transform 0.2s; }
    .download-modal-actions button:hover { transform: translateY(-1px); }
    .download-modal-actions .btn-cancel { background: #f5f5f5; color: #666; }
    .download-modal-actions .btn-download { background: linear-gradient(135deg, #4361ee, #3a0ca3); color: #fff; box-shadow: 0 16px 30px rgba(67, 97, 238, 0.25); }
    .download-option.selected { border-color: var(--primary); background: rgba(67, 97, 238, 0.05); }
    footer { background: #0d1530; color: #e8ecff; padding: 50px 0 30px; margin-top: auto; }
    .footer-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 30px; margin-bottom: 30px; }
    .footer-grid h3 { margin-bottom: 12px; font-size: 1rem; }
    .footer-links { list-style: none; display: flex; flex-direction: column; gap: 8px; }
    .footer-links a { color: rgba(232, 236, 255, 0.75); text-decoration: none; font-size: 0.95rem; }
    .footer-links a:hover { color: #fff; }
    .footer-links i { margin-right: 6px; }
    .copyright { text-align: center; border-top: 1px solid rgba(232, 236, 255, 0.16); padding-top: 20px; font-size: 0.85rem; color: rgba(232,236,255,0.6); }
    @media (max-width: 980px) {
      .stage { grid-template-columns: 1fr; }
    }
  </style>
<link href="css/header.css" rel="stylesheet"/>
<link href="css/theme-modern.css" rel="stylesheet"/>
<link rel="stylesheet" href="css/voice-assistant.css">
<script src="js/voice-assistant.js" defer></script>
                <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Background Style - Online Free Tool | easyjpgtopdf",
      "description": "Use our free Background Style tool online. Fast, secure, and easy to use.",
      "url": "https://easyjpgtopdf.com/background-style.html",
      "inLanguage": "en-US",
      "isPartOf": {
        "@type": "WebSite",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com"
      },
      "publisher": {
        "@type": "Organization",
        "name": "easyjpgtopdf",
        "url": "https://easyjpgtopdf.com"
      }
    }
    </script>
</head>
<body>
    <div id="global-header-placeholder"></div>


        <nav aria-label="Breadcrumb" style="padding: 15px 0; background: #f8f9ff; border-bottom: 1px solid #e2e6ff;">
        <div class="container" style="max-width: 1200px; margin: 0 auto; padding: 0 24px;">
            <ol style="list-style: none; display: flex; flex-wrap: wrap; gap: 10px; margin: 0; padding: 0; align-items: center;">
                <li><a href="index.html" style="color: #4361ee; text-decoration: none; font-weight: 500; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">Home</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="login.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Sign In</a></li>
                <li><span style="margin: 0 8px; color: #9ca3af;">|</span></li>
                <li><a href="signup.html" style="color: #56607a; font-weight: 500; text-decoration: none; transition: color 0.3s;" onmouseover="this.style.color='#4361ee'" onmouseout="this.style.color='#56607a'">Signup</a></li>
            </ol>
        </div>
    </nav>

<section class="hero" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: #fff; padding: 50px 0 70px; text-align: center; margin-bottom: 50px;">
    <div class="container">
        <h1 style="font-size: 3rem; margin-bottom: 20px; font-weight: 700;">Background Style - Change Image Background Colors & Styles Online Free</h1>
        <p style="font-size: 1.2rem; max-width: 700px; margin: 0 auto 30px; opacity: 0.95;">Edit image backgrounds with custom colors, styles, and patterns. Transform your photos with professional background styling tools.</p>
    </div>
</section>

<main class="stage">
<section class="panel">
<h2>Upload File</h2>
<!-- Preview Stage (like workspace) -->
<div class="preview-stage" id="previewStage">
<img alt="Original" class="preview-original" hidden id="previewOriginal"/>
<img alt="Result" class="preview-result" hidden id="previewResult"/>
<div class="preview-overlay" id="previewOverlay">
<div class="preview-spinner"></div>
<span>Loading...</span>
</div>
<div class="preview-placeholder hidden" id="previewPlaceholder">
<i class="fas fa-image" style="font-size:3rem;opacity:0.3;"></i>
<span>No image loaded</span>
</div>
</div>
<!-- Canvas for background styling (hidden, used for processing) -->
<div style="display: none;">
<canvas id="previewCanvas"></canvas>
</div>
<!-- Multiple Images Grid Preview -->
<div id="multipleImagesGrid" style="display: none; margin-top: 24px; padding: 20px; background: #f8f9ff; border-radius: 12px; border: 1px solid #e2e6ff;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="font-size: 1.1rem; color: #1f2559; margin: 0;">
            <i class="fas fa-images" style="margin-right: 8px; color: #4361ee;"></i>
            Images (<span id="imageCount">0</span>)
        </h3>
        <button id="clearAllImages" class="btn btn-outline" style="padding: 6px 12px; font-size: 0.85rem;">
            <i class="fas fa-trash"></i> Clear All
        </button>
    </div>
    <div id="imagesGridContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(1cm, 1cm)); gap: 8px; max-height: 300px; overflow-y: auto; padding: 8px; background: white; border-radius: 8px;">
        <!-- Images will be added here -->
    </div>
    <div style="margin-top: 16px; display: flex; gap: 12px; flex-wrap: wrap;">
        <button id="applyBgToAllBtn" class="btn btn-primary" style="flex: 1; min-width: 150px;">
            <i class="fas fa-magic"></i> Apply BG Style to All
        </button>
        <button id="downloadAllBtn" class="btn btn-primary" disabled style="flex: 1; min-width: 150px;">
            <i class="fas fa-download"></i> Download All (ZIP)
        </button>
    </div>
</div>
<div class="status" id="status"></div>
<div class="actions">
<button class="btn btn-outline" id="backToPreview"><i class="fas fa-arrow-left"></i> Back to Workspace</button>
<button class="btn btn-outline" disabled="" id="resetBackground"><i class="fas fa-undo"></i> Reset</button>
<button class="btn btn-primary" disabled="" id="downloadImage"><i class="fas fa-download"></i> Download</button>
</div>
</section>
<section class="panel">
<h2><i class="fas fa-magic"></i> Pick a Background</h2>
<div class="category-tabs">
<button class="tab-button active" data-tab="magic">Magic Photos</button>
<button class="tab-button" data-tab="photos">Cityscapes</button>
<button class="tab-button" data-tab="tech">Tech &amp; Infra</button>
<button class="tab-button" data-tab="colors">Solid Colours</button>
<button class="tab-button" data-tab="transparent">Transparent</button>
</div>
<div class="tab-content" data-tab="magic">
<div class="grid" id="magicGrid"></div>
</div>
<div class="tab-content" data-tab="photos" hidden="">
<div class="grid" id="photoGrid"></div>
</div>
<div class="tab-content" data-tab="tech" hidden="">
<div class="grid" id="techGrid"></div>
</div>
<div class="tab-content" data-tab="colors" hidden="">
<div class="color-grid" id="colorGrid"></div>
</div>
<div class="tab-content" data-tab="transparent" hidden="">
<p style="color:var(--muted);">Set background to transparent and download instantly.</p>
</div>
</section>

<section class="panel">
<h2>About This Tool</h2>
<div class="status-card">
<strong>Background Style Editor</strong>
<p>Apply custom backgrounds to your processed images</p>
<p>Choose from magic photos, cityscapes, tech backgrounds, or solid colors</p>
<p>Add text overlays with custom fonts and positioning</p>
<p><strong>Premium Features:</strong></p>
<p> Batch background style application to multiple images</p>
<p> Download all styled images as ZIP file</p>
<p> Grid preview of all images</p>
<p> Apply same style to all or customize individually</p>
<p><strong>Free Users:</strong> One image at a time</p>
</div>
</section>
    
    <section class="faq-section" style="margin: 40px 0; padding: 40px; background: #f8f9ff; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <h2 style="font-size: 2rem; color: #4361ee; margin-bottom: 30px; text-align: center;">
            <i class="fas fa-question-circle" style="margin-right: 10px;"></i>
            Frequently Asked Questions
        </h2>
        <div class="faq-container" style="max-width: 800px; margin: 0 auto;">
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    How accurate is the conversion?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Our conversion tools maintain 99% accuracy, preserving all formatting, fonts, and layout from your original files.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    What file sizes are supported?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Free users can convert files up to 10MB. Premium users can process files up to 100MB with faster processing.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    Will my data be secure?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Yes, all files are processed securely and automatically deleted after conversion. We never store or share your documents.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    Can I convert multiple files at once?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    Yes, premium users can convert multiple files simultaneously. Free users can process one file at a time.
                </div>
            </div>
            <div class="faq-item" style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 12px; border-left: 4px solid #4361ee; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <h3 style="font-size: 1.2rem; color: #0b1630; margin-bottom: 10px; cursor: pointer; display: flex; align-items: center;" onclick="toggleFaq(this)">
                    <i class="fas fa-chevron-right" style="color: #4361ee; margin-right: 10px; transition: transform 0.3s;"></i>
                    What formats are supported?
                </h3>
                <div class="faq-answer" style="font-size: 1rem; color: #56607a; line-height: 1.6; margin-top: 10px; display: none; padding-left: 30px;">
                    We support all major file formats. Check the tool page for specific format compatibility.
                </div>
            </div>
        </div>
    </section>

    <script>
    function toggleFaq(element) {
        const answer = element.nextElementSibling;
        const icon = element.querySelector('i');
        const isOpen = answer.style.display === 'block';

        answer.style.display = isOpen ? 'none' : 'block';
        icon.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(90deg)';
    }
    </script>

    

    <section class="feedback-section" style="margin: 40px 0; padding: 40px; background: #f8f9ff; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <h2 style="font-size: 2rem; color: #4361ee; margin-bottom: 30px; text-align: center;">
            <i class="fas fa-comments" style="margin-right: 10px;"></i>
            Reviews & Comments
        </h2>
        <div style="text-align: center; margin-bottom: 30px;">
            <a href="feedback.html" style="display: inline-flex; align-items: center; gap: 8px; color: #4361ee; text-decoration: none; font-weight: 600; font-size: 1rem; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">
                <i class="fas fa-external-link-alt"></i>
                View All Comments
            </a>
        </div>
        
        <div class="feedback-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: flex-start; max-width: 1200px; margin: 0 auto;">
            <!-- Left Side: Comments List -->
            <div class="feedback-card" style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); min-height: 400px; max-height: 600px; overflow-y: auto;">
                <div class="thread-header" style="margin-bottom: 20px; border-bottom: 2px solid #e2e6ff; padding-bottom: 12px;">
                    <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 8px;">Live Comments</h3>
                    <p class="feedback-hint" style="font-size: 0.85rem; color: #9ca3af; margin: 0;">Share your experience and see what others are saying.</p>
                </div>
                <ul class="comment-list" id="feedbackList" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 16px;">
                    <li class="feedback-muted" id="feedback-empty-state" style="text-align: center; padding: 40px 20px; color: #9ca3af; font-size: 0.95rem;">No comments yet. Start the conversation!</li>
                </ul>
            </div>
            
            <!-- Right Side: Feedback Form -->
            <div class="feedback-form-card" style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); position: sticky; top: 20px;">
                <h3 style="font-size: 1.3rem; color: #0b1630; margin-bottom: 20px;">
                    <i class="fas fa-edit" style="color: #4361ee; margin-right: 8px;"></i>
                    Share Your Feedback
                </h3>
                <form id="feedbackForm" style="display: flex; flex-direction: column; gap: 15px;">
                    <div class="form-group">
                        <label for="feedbackName" style="display: block; margin-bottom: 8px; color: #56607a; font-weight: 600; font-size: 0.9rem;">Your Name</label>
                        <input type="text" id="feedbackName" placeholder="Enter your name" required style="width: 100%; padding: 12px 16px; border: 1px solid #e2e6ff; border-radius: 8px; font-size: 0.95rem; transition: border-color 0.3s; box-sizing: border-box;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#e2e6ff'">
                    </div>
                    <div class="form-group">
                        <label for="feedbackMessage" style="display: block; margin-bottom: 8px; color: #56607a; font-weight: 600; font-size: 0.9rem;">Your Comment</label>
                        <textarea id="feedbackMessage" placeholder="Write your feedback or comment here..." required rows="5" style="width: 100%; padding: 12px 16px; border: 1px solid #e2e6ff; border-radius: 8px; font-size: 0.95rem; resize: vertical; transition: border-color 0.3s; font-family: inherit; box-sizing: border-box;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#e2e6ff'"></textarea>
                    </div>
                    <button type="submit" style="background: linear-gradient(135deg, #4361ee, #3a0ca3); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; width: 100%;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(67, 97, 238, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        <i class="fas fa-paper-plane" style="margin-right: 8px;"></i>
                        Submit Feedback
                    </button>
                </form>
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e6ff;">
                    <a href="feedback.html" style="color: #4361ee; text-decoration: none; font-weight: 600; font-size: 0.9rem; display: inline-flex; align-items: center; gap: 8px; transition: color 0.3s;" onmouseover="this.style.color='#3a0ca3'" onmouseout="this.style.color='#4361ee'">
                        <i class="fas fa-arrow-right"></i>
                        View All Feedback
                    </a>
                </div>
            </div>
        </div>
    </section>

    <style>
    @media (max-width: 768px) {
        .feedback-grid {
            grid-template-columns: 1fr !important;
        }
        .feedback-form-card {
            position: static !important;
        }
    }
    </style>

    <script>
    // Store feedback in localStorage (in production, use backend API)
    const currentPage = window.location.pathname.split('/').pop() || 'index.html';
    
    // Load feedbacks for this page (max 3, only genuine user comments)
    function loadFeedbacks() {
        const storedFeedbacks = JSON.parse(localStorage.getItem('feedbacks') || '{}');
        const pageFeedbacks = (storedFeedbacks[currentPage] || []).slice(0, 3);
        const feedbackList = document.getElementById('feedbackList');
        const emptyState = document.getElementById('feedback-empty-state');
        
        if (!feedbackList) return;
        
        // Clear existing content
        feedbackList.innerHTML = '';
        
        if (pageFeedbacks.length === 0) {
            // Show empty state
            if (emptyState) {
                feedbackList.appendChild(emptyState);
            } else {
                const empty = document.createElement('li');
                empty.className = 'feedback-muted';
                empty.id = 'feedback-empty-state';
                empty.style.cssText = 'text-align: center; padding: 40px 20px; color: #9ca3af; font-size: 0.95rem;';
                empty.textContent = 'No comments yet. Start the conversation!';
                feedbackList.appendChild(empty);
            }
            return;
        }
        
        // Remove empty state
        if (emptyState) {
            emptyState.remove();
        }
        
        // Display genuine user feedbacks
        pageFeedbacks.forEach(fb => {
            const li = document.createElement('li');
            li.className = 'live-comment';
            li.style.cssText = 'background: #f8f9ff; padding: 16px; border-radius: 8px; border-left: 3px solid #4361ee; margin-bottom: 12px;';
            
            const header = document.createElement('div');
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;';
            
            const nameDiv = document.createElement('div');
            const name = document.createElement('h4');
            name.style.cssText = 'font-size: 1rem; color: #0b1630; margin: 0 0 4px 0; font-weight: 600;';
            name.textContent = fb.name || 'Anonymous';
            
            const time = document.createElement('span');
            time.style.cssText = 'font-size: 0.8rem; color: #9ca3af;';
            time.textContent = fb.date || 'Recently';
            
            nameDiv.appendChild(name);
            nameDiv.appendChild(time);
            header.appendChild(nameDiv);
            
            li.appendChild(header);
            
            const body = document.createElement('p');
            body.style.cssText = 'color: #56607a; line-height: 1.6; margin: 0 0 12px 0; font-size: 0.9rem;';
            body.textContent = fb.message || '';
            li.appendChild(body);
            
            // Add reply if exists
            if (fb.reply) {
                const replyDiv = document.createElement('div');
                replyDiv.style.cssText = 'margin-left: 20px; padding: 12px; background: white; border-radius: 6px; margin-top: 10px; border-left: 2px solid #4361ee;';
                
                const replyHeader = document.createElement('div');
                replyHeader.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-bottom: 6px;';
                
                const replyIcon = document.createElement('i');
                replyIcon.className = 'fas fa-reply';
                replyIcon.style.cssText = 'color: #4361ee; font-size: 0.85rem;';
                
                const replyLabel = document.createElement('strong');
                replyLabel.style.cssText = 'color: #4361ee; font-size: 0.85rem;';
                replyLabel.textContent = 'Admin Reply:';
                
                replyHeader.appendChild(replyIcon);
                replyHeader.appendChild(replyLabel);
                replyDiv.appendChild(replyHeader);
                
                const replyText = document.createElement('p');
                replyText.style.cssText = 'color: #56607a; font-size: 0.85rem; line-height: 1.5; margin: 0;';
                replyText.textContent = fb.reply;
                replyDiv.appendChild(replyText);
                
                li.appendChild(replyDiv);
            }
            
            feedbackList.appendChild(li);
        });
    }
    
    // Handle feedback form submission
    const feedbackForm = document.getElementById('feedbackForm');
    if (feedbackForm) {
        feedbackForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const name = document.getElementById('feedbackName').value.trim();
            const message = document.getElementById('feedbackMessage').value.trim();
            
            if (!name || !message) {
                alert('Please fill in all fields');
                return;
            }
            
            const feedback = {
                name: name,
                message: message,
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
                page: currentPage
            };
            
            // Store in localStorage
            const storedFeedbacks = JSON.parse(localStorage.getItem('feedbacks') || '{}');
            if (!storedFeedbacks[currentPage]) {
                storedFeedbacks[currentPage] = [];
            }
            storedFeedbacks[currentPage].unshift(feedback);
            localStorage.setItem('feedbacks', JSON.stringify(storedFeedbacks));
            
            // Reset form
            this.reset();
            
            // Reload feedbacks
            loadFeedbacks();
            
            alert('Thank you for your feedback!');
        });
    }
    
    // Load feedbacks on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadFeedbacks);
    } else {
        loadFeedbacks();
    }
    </script>
<div class="trust-badges" style="text-align: center; padding: 20px; background: linear-gradient(135deg, #f8f9ff, #ffffff); border-radius: 12px; margin: 30px 0; border: 2px solid #e2e6ff;">
        <div style="display: flex; justify-content: center; align-items: center; gap: 40px; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-shield-alt" style="font-size: 2rem; color: #4361ee;"></i>
                <div style="text-align: left;">
                    <div style="color: #0b1630; font-weight: 600; font-size: 1.1rem;">SSL Secured</div>
                    <div style="color: #56607a; font-size: 0.9rem;">256-bit Encryption</div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-lock" style="font-size: 2rem; color: #4361ee;"></i>
                <div style="text-align: left;">
                    <div style="color: #0b1630; font-weight: 600; font-size: 1.1rem;">100% Secure</div>
                    <div style="color: #56607a; font-size: 0.9rem;">Files Auto-Deleted</div>
                </div>
            </div>
            
        </div>
    </div>
</main>
<div class="overlay-deck">
<section class="panel overlay-panel">
<div class="overlay-controls">

<div class="overlay-fields hidden" id="overlayFields">
<label>
            Text (multiline supported)
            <textarea id="overlayText" placeholder="Enter caption"></textarea>
</label>
<label>
            Font Family
            <select id="overlayFont">
<option value="'Segoe UI', sans-serif">Segoe UI</option>
<option value="'Poppins', sans-serif">Poppins</option>
<option value="'Roboto', sans-serif">Roboto</option>
<option value="'Montserrat', sans-serif">Montserrat</option>
<option value="'Playfair Display', serif">Playfair Display</option>
</select>
</label>
<label>
            Font Weight
            <select id="overlayWeight">
<option value="400">Regular</option>
<option value="500">Medium</option>
<option selected="" value="600">Semi Bold</option>
<option value="700">Bold</option>
<option value="800">Extra Bold</option>
</select>
</label>
<label>
            Font Size
            <div style="display:flex;align-items:center;gap:10px;">
<input id="overlaySize" max="96" min="16" type="range" value="42"/>
<span class="overlay-range-value" id="overlaySizeValue">42px</span>
</div>
</label>
<label>
            Position
            <select id="overlayPosition">
<option value="top-left">Top Left</option>
<option value="top-right">Top Right</option>
<option selected="" value="center">Center</option>
<option value="bottom-left">Bottom Left</option>
<option value="bottom-right">Bottom Right</option>
<option value="bottom-center">Bottom Center</option>
<option value="manual">Manual (use sliders)</option>
</select>
</label>
<label class="overlay-manual hidden" id="overlayManualX">
            Horizontal Offset
            <div style="display:flex;align-items:center;gap:10px;">
<input id="overlayOffsetX" max="100" min="-100" type="range" value="0"/>
<span class="overlay-range-value" id="overlayOffsetXValue">0%</span>
</div>
</label>
<label class="overlay-manual hidden" id="overlayManualY">
            Vertical Offset
            <div style="display:flex;align-items:center;gap:10px;">
<input id="overlayOffsetY" max="100" min="-100" type="range" value="0"/>
<span class="overlay-range-value" id="overlayOffsetYValue">0%</span>
</div>
</label>
<label>
            Text Colour
            <input id="overlayColor" type="color" value="#ffffff"/>
</label>
<label>
            Shadow Strength
            <div style="display:flex;align-items:center;gap:10px;">
<input id="overlayShadow" max="30" min="0" type="range" value="12"/>
<span class="overlay-range-value" id="overlayShadowValue">12px</span>
</div>
</label>
</div>
</div>
</section>
</div>
<!-- Download Modal -->
<div id="downloadModal" class="download-modal">
  <div class="download-modal-content">
    <div class="download-modal-header">
      <h3><i class="fas fa-download"></i> Download Image</h3>
      <p>Choose your download quality</p>
    </div>
    <div class="download-options">
      <div class="download-option" id="freeDownloadOption" data-quality="free">
        <div class="download-option-header">
          <div class="download-option-title">Free Preview</div>
          <span class="download-option-badge free">Free</span>
        </div>
        <div class="download-option-details">
          <strong>512px</strong> • No credits required • Instant download
        </div>
      </div>
      <div class="download-option" id="premiumDownloadOption" data-quality="premium">
        <div class="download-option-header">
          <div class="download-option-title">Premium HD – up to 25 Megapixels</div>
          <span class="download-option-badge premium">Premium</span>
        </div>
        <div class="download-option-details">
          <strong>Up to 25 Megapixels</strong> • 2 credits per image • High-resolution quality
        </div>
        <div class="size-selection" id="premiumSizeSelection">
          <label for="premiumSizeSelect"><i class="fas fa-expand-arrows-alt"></i> Select Resolution:</label>
          <select id="premiumSizeSelect" class="size-select">
            <option value="original">Original Size (Preserved if ≤ 25 MP)</option>
            <option value="1920x1080">1920×1080 (2.07 MP) - Full HD</option>
            <option value="2048x2048">2048×2048 (4.19 MP) - Square HD</option>
            <option value="3000x2000">3000×2000 (6 MP) - 3:2 Ratio</option>
            <option value="3000x3000">3000×3000 (9 MP) - Square</option>
            <option value="4000x3000">4000×3000 (12 MP) - 4:3 Ratio</option>
            <option value="4000x4000">4000×4000 (16 MP) - Square</option>
            <option value="5000x3000">5000×3000 (15 MP) - 5:3 Ratio</option>
            <option value="5000x5000">5000×5000 (25 MP) - Maximum</option>
          </select>
          <div class="size-info" id="premiumSizeInfo">Original resolution will be preserved if within 25 MP limit</div>
        </div>
        <div id="premiumCreditInfo" style="margin-top: 8px; padding: 8px; background: rgba(67, 97, 238, 0.08); border-radius: 8px; font-size: 0.85rem; color: #56607a; display: none;">
          <span id="premiumCreditText">Checking credits...</span>
        </div>
      </div>
    </div>
    <div class="download-modal-actions">
      <button class="btn-cancel" id="cancelDownload">Cancel</button>
      <button class="btn-download" id="confirmDownload" disabled>
        <i class="fas fa-download"></i> Download
      </button>
    </div>
  </div>
</div>
<script type="module">
    // Import Firebase modules (optional - works without Firebase for file:// protocol)
    let auth = null;
    let db = null;
    let getDoc = null;
    let doc = null;
    let onAuthStateChanged = null;
    
    // Try to load Firebase, but don't fail if file:// protocol
    const isLocalFile = window.location.protocol === 'file:';
    
    if (!isLocalFile) {
      try {
        const firebaseInit = await import('./js/firebase-init.js');
        const firestore = await import('https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js');
        const firebaseAuth = await import('https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js');
        
        auth = firebaseInit.auth;
        db = firebaseInit.db;
        getDoc = firestore.getDoc;
        doc = firestore.doc;
        onAuthStateChanged = firebaseAuth.onAuthStateChanged;
        
        console.log('? Firebase loaded successfully');
      } catch (error) {
        console.warn('?? Firebase not available (file:// protocol or network issue):', error.message);
      }
    } else {
      console.log('?? Running on file:// protocol - Firebase disabled (download will work without auth)');
    }

    const STORAGE_KEYS = {
      original: 'bgRemover:original',
      foreground: 'bgRemover:foreground',
      filename: 'bgRemover:filename',
      dimensions: 'bgRemover:dimensions',
      multipleImages: 'bgRemover:multipleImages',
      processedImages: 'bgRemover:processedImages'
    };
    
    let multipleImages = []; // Array to store multiple images with bg styles
    let isPremiumUser = false;
    let currentImageIndex = 0;

    // Limits - Same as background-workspace.html
    const FREE_UPLOAD_LIMIT = 1 * 1024 * 1024; // 1 MB - Free upload limit per image
    const FREE_MONTHLY_UPLOAD_LIMIT = 10 * 1024 * 1024; // 10 MB - Free monthly upload limit
    const FREE_DOWNLOAD_LIMIT = 150 * 1024; // 150 KB - Free download limit (compressed)
    const FREE_MONTHLY_DOWNLOAD_LIMIT = 5 * 1024 * 1024; // 5 MB - Free monthly download limit
    const FREE_PREVIEW_LIMIT = 150 * 1024; // 150 KB - Free preview without compression
    const FREE_PREVIEW_MAX = 400 * 1024; // 400 KB - Max preview size for free users
    const FREE_QUOTA_PER_MONTH = 40;
    // Limits for Premium Users
    const PREMIUM_UPLOAD_LIMIT = 50 * 1024 * 1024; // 50 MB - Premium upload limit per image
    const PREMIUM_MONTHLY_UPLOAD_LIMIT = 500 * 1024 * 1024; // 500 MB - Premium monthly upload limit
    const PREMIUM_MONTHLY_DOWNLOAD_LIMIT = 500 * 1024 * 1024; // 500 MB - Premium monthly download limit // 40 images per month for free users

    let currentUser = null;
    let userSubscription = null;
    let deviceInfo = null;

    // Check user subscription status (only if Firebase available)
    async function checkUserSubscription(user) {
      if (!user || !auth || !db || !doc || !getDoc) return null;
      try {
        const userDocRef = doc(db, 'users', user.uid);
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
          const data = userDoc.data();
          const plan = data.plan || 'free';
          const subscriptionEnd = data.subscriptionEnd || null;
          const isPremium = plan === 'premium' || plan === 'pro';
          
          // Check if subscription is valid (not expired)
          let isValid = false;
          if (isPremium && subscriptionEnd) {
            const endDate = new Date(subscriptionEnd);
            const now = new Date();
            isValid = endDate > now;
          }
          
          return {
            plan: plan,
            isPremium: isPremium,
            isValid: isValid,
            subscriptionEnd: subscriptionEnd
          };
        }
      } catch (error) {
        console.error('Error checking subscription:', error);
      }
      return null;
    }

    // Monitor auth state (only if Firebase available)
    if (auth && onAuthStateChanged) {
      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        if (user) {
          userSubscription = await checkUserSubscription(user);
        } else {
          userSubscription = null;
        }
      });
    } else {
      console.log('?? Running without authentication - all features available');
    }

    // Initialize device fingerprinting
    async function initDeviceTracking() {
      try {
        const { getDeviceInfo } = await import('./js/device-fingerprint.js');
        deviceInfo = await getDeviceInfo();
        console.log('✅ Device tracking initialized:', {
          deviceId: deviceInfo.deviceId,
          ip: deviceInfo.ip,
          fingerprint: deviceInfo.fingerprint.substring(0, 20) + '...'
        });
      } catch (error) {
        console.warn('⚠️ Device fingerprinting not available:', error);
      }
    }
    initDeviceTracking();

    const fallbackBackgrounds = {
      magic: [
        { label: 'Aurora Night', url: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Mountain Sunrise', url: 'https://images.unsplash.com/photo-1500534623283-312aade485b7?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Golden Forest', url: 'https://images.unsplash.com/photo-1470770903676-69b98201ea1c?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Desert Dream', url: 'https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Lavender Field', url: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1600&q=80&sat=-20' },
        { label: 'Sea Mist', url: 'https://images.unsplash.com/photo-1474871256005-c5f7eb1d77f1?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Canyon Glow', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Foggy Pines', url: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Snow Valley', url: 'https://images.unsplash.com/photo-1508261305430-1e1c5237c11f?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Moody Lake', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Cherry Blossoms', url: 'https://images.unsplash.com/photo-1494475673543-6a6a27143b22?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Palm Horizon', url: 'https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Beach Sunset', url: 'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Autumn Path', url: 'https://images.unsplash.com/photo-1476041800959-2f6bb412c8ce?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Starry Ridge', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&sat=-30' },
        { label: 'Emerald Hills', url: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'River Glow', url: 'https://images.unsplash.com/photo-1477414348463-c0eb7f1359b6?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Purple Mountains', url: 'https://images.unsplash.com/photo-1500534625967-5b1fd4700f39?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Rolling Clouds', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&sat=-50' },
        { label: 'Glacier Lagoon', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&hue=190' },
        { label: 'Tropical Blush', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&sat=-10' },
        { label: 'Winter Sunrise', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&hue=0' }
      ],
      photos: [
        { label: 'New York Skyline', url: 'https://images.unsplash.com/photo-1534447677768-be436bb09401?auto=format&fit=crop&w=1600&q=80' },
        { label: 'London Bridge', url: 'https://images.unsplash.com/photo-1498887960847-2a25ef84c54b?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Paris Eiffel', url: 'https://images.unsplash.com/photo-1502602898657-3e91760cbb34?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Tokyo Lights', url: 'https://images.unsplash.com/photo-1549693578-d683be217e58?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Dubai Skyline', url: 'https://images.unsplash.com/photo-1533104816931-20fa691ff6ca?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Singapore Marina', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Sydney Opera', url: 'https://images.unsplash.com/photo-1506976785307-8732e854ad89?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Hong Kong', url: 'https://images.unsplash.com/photo-1505767641034-1b3f0a7ab1d2?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Barcelona Streets', url: 'https://images.unsplash.com/photo-1505761671935-60b3a7427bad?auto=format&fit=crop&w=1600&q=80' },
        { label: 'San Francisco', url: 'https://images.unsplash.com/photo-1465446751832-9c63a0470b97?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Seoul Skyline', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-20' },
        { label: 'Shanghai Tower', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&hue=210' },
        { label: 'Amsterdam Canals', url: 'https://images.unsplash.com/photo-1444676632488-26a136c45b9b?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Rome Sunrise', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-60' },
        { label: 'Los Angeles', url: 'https://images.unsplash.com/photo-1505761671935-60b3a7427bad?auto=format&fit=crop&w=1600&q=80&hue=15' },
        { label: 'Rio de Janeiro', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&hue=5' },
        { label: 'Berlin Lights', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&sat=-10' },
        { label: 'Istanbul', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&hue=30' },
        { label: 'Cape Town', url: 'https://images.unsplash.com/photo-1470770841072-f978cf4d019e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Moscow', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&hue=340' },
        { label: 'Vancouver', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&sat=-80' },
        { label: 'Mumbai', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-30' }
      ],
      tech: [
        { label: 'Data Center', url: 'https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Neon Grid', url: 'https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Modern Office', url: 'https://images.unsplash.com/photo-1498050108023-c5249f4df085?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Blue Circuit', url: 'https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1600&q=80&sat=-60' },
        { label: 'Server Aisle', url: 'https://images.unsplash.com/photo-1520607162513-77705c0f0d4a?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Drone City', url: 'https://images.unsplash.com/photo-1485827404703-89b55fcc595e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Futuristic Lobby', url: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1600&q=80&hue=200' },
        { label: 'Cyber Lines', url: 'https://images.unsplash.com/photo-1535223289827-42f1e9919769?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Innovation Hub', url: 'https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=1600&q=80&sat=-30' },
        { label: 'Neon Tunnel', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&hue=280' },
        { label: 'VR Experience', url: 'https://images.unsplash.com/photo-1520607162513-77705c0f0d4a?auto=format&fit=crop&w=1600&q=80&sat=-40' },
        { label: 'Innovation Lab', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&sat=-20' },
        { label: 'Neon Bridge', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&sat=-20' },
        { label: 'Tech Expo', url: 'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1600&q=80&hue=300' },
        { label: 'Smart City', url: 'https://images.unsplash.com/photo-1535223289827-42f1e9919769?auto=format&fit=crop&w=1600&q=80&sat=-45' },
        { label: 'AI Circuit', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-70' },
        { label: 'Digital Wave', url: 'https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1600&q=80&hue=220' },
        { label: 'Tech Vibes', url: 'https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1600&q=80&hue=340' },
        { label: 'Quantum Lab', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-15' },
        { label: 'Hologram Hall', url: 'https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1600&q=80&hue=180' },
        { label: 'Innovation Bridge', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&sat=-5' },
        { label: 'Satellite View', url: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?auto=format&fit=crop&w=1600&q=80&sat=-70' },
        { label: 'IoT Hub', url: 'https://images.unsplash.com/photo-1542838132-92c53300491e?auto=format&fit=crop&w=1600&q=80' },
        { label: 'Digital Aurora', url: 'https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1600&q=80&sat=-5' },
        { label: 'Smart Grid', url: 'https://images.unsplash.com/photo-1526481280695-3c469928b67b?auto=format&fit=crop&w=1600&q=80&hue=250' }
      ]
    };

    const colorPalette = [
      { label: 'Transparent', value: 'transparent' },
      { label: 'Pure White', value: '#ffffff' },
      { label: 'Charcoal', value: '#111827' },
      { label: 'Sky Blue', value: '#bfdbfe' },
      { label: 'Sunset', value: '#fb7185' },
      { label: 'Mint', value: '#bbf7d0' },
      { label: 'Lavender', value: '#c4b5fd' },
      { label: 'Peach', value: '#fed7aa' },
      { label: 'Slate', value: '#475569' },
      { label: 'Golden', value: '#facc15' },
      { label: 'Emerald', value: '#34d399' }
    ];

    const previewCanvas = document.getElementById('previewCanvas');
    const statusEl = document.getElementById('status');
    const resetBtn = document.getElementById('resetBackground');
    const downloadBtn = document.getElementById('downloadImage');
    const backToPreview = document.getElementById('backToPreview');

    if (!previewCanvas) {
      console.error('Preview canvas not found!');
    }

    let previewContext = previewCanvas ? previewCanvas.getContext('2d') : null;
    let originalDataUrl = sessionStorage.getItem(STORAGE_KEYS.original);
    let foregroundDataUrl = sessionStorage.getItem(STORAGE_KEYS.foreground);
    let dimensions = sessionStorage.getItem(STORAGE_KEYS.dimensions);
    
    console.log('SessionStorage data:', {
      original: !!originalDataUrl,
      foreground: !!foregroundDataUrl,
      dimensions: dimensions
    });

    // Check for multiple images first
    loadMultipleImages();
    
    // If no multiple images but single image exists, convert it
    if (multipleImages.length === 0 && foregroundDataUrl) {
      const filename = sessionStorage.getItem(STORAGE_KEYS.filename) || 'image.png';
      multipleImages.push({
        id: 'img_single',
        dataURL: originalDataUrl,
        resultURL: foregroundDataUrl,
        filename: filename,
        processed: true,
        bgStyled: false,
        bgStyle: null,
        styledDataURL: null
      });
      saveMultipleImages();
    }
    
    if (!originalDataUrl || !foregroundDataUrl || !dimensions) {
      // Check if we have multiple images
      if (multipleImages.length > 0) {
        // Load first image
        const firstImg = multipleImages[0];
        originalDataUrl = firstImg.dataURL;
        foregroundDataUrl = firstImg.resultURL || firstImg.dataURL;
        dimensions = JSON.stringify({ width: 800, height: 600 }); // Default dimensions
        sessionStorage.setItem(STORAGE_KEYS.original, originalDataUrl);
        sessionStorage.setItem(STORAGE_KEYS.foreground, foregroundDataUrl);
        sessionStorage.setItem(STORAGE_KEYS.dimensions, dimensions);
        sessionStorage.setItem(STORAGE_KEYS.filename, firstImg.filename || 'image.png');
      } else {
        statusEl.textContent = 'Missing image data. Please go back to workspace or upload an image.';
        resetBtn.disabled = true;
        downloadBtn.disabled = true;
        
        // Add helpful message and link
        const previewFrame = document.querySelector('.preview-frame');
        if (previewFrame) {
          previewFrame.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; padding: 40px; text-align: center; color: var(--muted);">
              <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: var(--primary); opacity: 0.5;"></i>
              <div>
                <h3 style="color: var(--dark); margin-bottom: 8px;">No Image Found</h3>
                <p style="margin-bottom: 16px;">Please process an image first in the workspace.</p>
                <a href="background-workspace.html" style="display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px; background: linear-gradient(135deg, #4361ee, #3a0ca3); color: white; text-decoration: none; border-radius: 999px; font-weight: 600;">
                  <i class="fas fa-arrow-left"></i> Go to Workspace
                </a>
              </div>
            </div>
          `;
        }
      }
    }

    if (previewCanvas && dimensions) {
      try {
        const { width, height } = JSON.parse(dimensions);
        if (width > 0 && height > 0) {
          previewCanvas.width = width;
          previewCanvas.height = height;
          console.log('Canvas dimensions set:', { width, height });
        } else {
          console.warn('Invalid dimensions:', { width, height });
        }
      } catch (e) {
        console.error('Error parsing dimensions:', e, dimensions);
      }
    } else {
      if (!previewCanvas) {
        console.error('Preview canvas not available');
      }
      if (!dimensions) {
        console.warn('No dimensions found in sessionStorage');
      }
    }

    const backgroundImage = new Image();
    const foregroundImage = new Image();
    const overlayToggle = document.getElementById('overlayToggle');
    const overlayFields = document.getElementById('overlayFields');
    const overlayTextInput = document.getElementById('overlayText');
    const overlayFontSelect = document.getElementById('overlayFont');
    const overlayWeightSelect = document.getElementById('overlayWeight');
    const overlaySizeRange = document.getElementById('overlaySize');
    const overlaySizeValue = document.getElementById('overlaySizeValue');
    const overlayPositionSelect = document.getElementById('overlayPosition');
    const overlayColorInput = document.getElementById('overlayColor');
    const overlayShadowRange = document.getElementById('overlayShadow');
    const overlayShadowValue = document.getElementById('overlayShadowValue');
    const overlayOffsetX = document.getElementById('overlayOffsetX');
    const overlayOffsetY = document.getElementById('overlayOffsetY');
    const overlayOffsetXValue = document.getElementById('overlayOffsetXValue');
    const overlayOffsetYValue = document.getElementById('overlayOffsetYValue');
    const overlayManualX = document.getElementById('overlayManualX');
    const overlayManualY = document.getElementById('overlayManualY');
    const overlayState = {
      enabled: false,
      text: '',
      fontFamily: "'Segoe UI', sans-serif",
      fontWeight: 600,
      fontSize: 42,
      position: 'center',
      color: '#ffffff',
      shadow: 12,
      offsetX: 0,
      offsetY: 0
    };

    function clearStatus() {
      statusEl.textContent = '';
    }

    function setStatus(message) {
      statusEl.textContent = message;
    }

    async function loadImage(image, src) {
      return new Promise((resolve, reject) => {
        image.crossOrigin = 'anonymous';
        image.onload = () => resolve(image);
        image.onerror = reject;
        image.src = src;
      });
    }

    // Compress image to reduce size (for free users) - UPDATED to match background-workspace.html
    async function compressImageForFree(dataURL, targetSizeKB = 150) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          const originalSize = Math.ceil((dataURL.split(',')[1].length * 0.75) / 1024);
          
          // If already under limit, return as is
          if (originalSize <= targetSizeKB) {
            resolve({ dataURL, width, height, size: originalSize * 1024 });
            return;
          }
          
          // Calculate scale to reduce size
          const scale = Math.sqrt(targetSizeKB / originalSize) * 0.9; // 90% to be safe
          width = Math.round(width * scale);
          height = Math.round(height * scale);
          
          // Ensure minimum dimensions
          if (width < 200) width = 200;
          if (height < 200) height = 200;
          
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          
          // High quality resize
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(img, 0, 0, width, height);
          
          // Convert to PNG with compression
          let compressedDataURL = canvas.toDataURL('image/png', 0.92);
          let compressedSize = Math.ceil((compressedDataURL.split(',')[1].length * 0.75) / 1024);
          
          // If still too large, reduce quality further
          if (compressedSize > targetSizeKB) {
            const quality = (targetSizeKB / compressedSize) * 0.9;
            compressedDataURL = canvas.toDataURL('image/png', Math.max(0.7, quality));
            compressedSize = Math.ceil((compressedDataURL.split(',')[1].length * 0.75) / 1024);
          }
          
          resolve({
            dataURL: compressedDataURL,
            width: width,
            height: height,
            size: compressedSize * 1024,
            compressed: true,
            originalSize: originalSize * 1024
          });
        };
        img.src = dataURL;
      });
    }
    
    // Compress preview for faster background styling (free users) - Same as background-workspace.html
    async function compressPreviewForRemoval(dataURL) {
      const originalSize = Math.ceil((dataURL.split(',')[1].length * 0.75));
      const originalSizeKB = originalSize / 1024;
      
      console.log('?? Original size:', originalSizeKB.toFixed(0), 'KB');
      
      // If under 150 KB, use as is
      if (originalSize <= FREE_PREVIEW_LIMIT) {
        console.log('✅ Using original size (under 150 KB)');
        return { dataURL, compressed: false, originalSize };
      }
      
      // Compress to 150 KB for free users
      console.log('⚡ Compressing preview to 150 KB...');
      const compressed = await compressImageForFree(dataURL, 150);
      console.log('? Preview compressed to:', (compressed.size / 1024).toFixed(0), 'KB');
      
      return {
        dataURL: compressed.dataURL,
        compressed: true,
        originalSize: originalSize,
        compressedSize: compressed.size
      };
    }

    // Get image dimensions and size info - Same as background-workspace.html
    function getImageInfo(dataURL) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const base64Data = dataURL.split(',')[1];
          const size = Math.ceil(base64Data.length * 0.75);
          resolve({
            width: img.width,
            height: img.height,
            size: size,
            sizeMB: (size / (1024 * 1024)).toFixed(2),
            sizeKB: (size / 1024).toFixed(0)
          });
        };
        img.src = dataURL;
      });
    }

    function applyOverlay() {
      if (!overlayState.enabled || !overlayState.text.trim()) return;
      const ctx = previewContext;
      ctx.save();
      ctx.font = `${overlayState.fontWeight} ${overlayState.fontSize}px ${overlayState.fontFamily}`;
      ctx.fillStyle = overlayState.color;
      const lines = overlayState.text.split(/\n/).map((line) => line.trimEnd());
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const shadow = overlayState.shadow;
      ctx.shadowColor = shadow > 0 ? 'rgba(0,0,0,0.45)' : 'transparent';
      ctx.shadowBlur = shadow;
      const padding = overlayState.fontSize * 0.6;
      let x = previewCanvas.width / 2;
      let y = previewCanvas.height / 2;
      if (overlayState.position === 'top-left') {
        ctx.textAlign = 'left';
        x = padding;
        y = padding;
      } else if (overlayState.position === 'top-right') {
        ctx.textAlign = 'right';
        x = previewCanvas.width - padding;
        y = padding;
      } else if (overlayState.position === 'bottom-left') {
        ctx.textAlign = 'left';
        x = padding;
        y = previewCanvas.height - padding;
      } else if (overlayState.position === 'bottom-right') {
        ctx.textAlign = 'right';
        x = previewCanvas.width - padding;
        y = previewCanvas.height - padding;
      } else if (overlayState.position === 'bottom-center') {
        ctx.textAlign = 'center';
        x = previewCanvas.width / 2;
        y = previewCanvas.height - padding;
      } else if (overlayState.position === 'manual') {
        ctx.textAlign = 'center';
        x = previewCanvas.width / 2 + (overlayState.offsetX / 100) * (previewCanvas.width / 2);
        y = previewCanvas.height / 2 + (overlayState.offsetY / 100) * (previewCanvas.height / 2);
      }
      const lineHeight = overlayState.fontSize * 1.2;
      const startY = y - ((lines.length - 1) / 2) * lineHeight;
      lines.forEach((line, index) => {
        ctx.fillText(line, x, startY + index * lineHeight);
      });
      ctx.restore();
    }

    async function drawComposite(background) {
      if (!foregroundDataUrl) {
        console.error('drawComposite: No foregroundDataUrl');
        return;
      }
      
      if (!previewCanvas || !previewContext) {
        console.error('drawComposite: Canvas or context not available');
        return;
      }
      
      if (!foregroundImage.complete || foregroundImage.naturalWidth === 0) {
        console.warn('drawComposite: Foreground image not loaded yet, waiting...');
        await new Promise((resolve) => {
          if (foregroundImage.complete) {
            resolve();
          } else {
            foregroundImage.onload = resolve;
            foregroundImage.onerror = () => {
              console.error('drawComposite: Failed to load foreground image');
              resolve();
            };
            // Timeout after 5 seconds
            setTimeout(() => {
              console.warn('drawComposite: Image load timeout');
              resolve();
            }, 5000);
          }
        });
      }
      
      clearStatus();
      if (typeof background !== 'undefined') {
        currentBackgroundRef = background;
      }
      
      if (previewCanvas.width === 0 || previewCanvas.height === 0) {
        console.error('drawComposite: Canvas dimensions are zero!', {
          width: previewCanvas.width,
          height: previewCanvas.height,
          imageWidth: foregroundImage.naturalWidth,
          imageHeight: foregroundImage.naturalHeight
        });
        // Try to set dimensions from image
        if (foregroundImage.naturalWidth > 0 && foregroundImage.naturalHeight > 0) {
          previewCanvas.width = foregroundImage.naturalWidth;
          previewCanvas.height = foregroundImage.naturalHeight;
          console.log('Canvas dimensions set from image:', {
            width: previewCanvas.width,
            height: previewCanvas.height
          });
        } else {
          return;
        }
      }
      
      previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

      if (background === 'transparent') {
        // draw checkerboard pattern
        const size = 40;
        for (let y = 0; y < previewCanvas.height; y += size) {
          for (let x = 0; x < previewCanvas.width; x += size) {
            previewContext.fillStyle = ((x / size + y / size) % 2 === 0) ? '#f1f5f9' : '#e2e8f0';
            previewContext.fillRect(x, y, size, size);
          }
        }
      } else if (typeof background === 'string') {
        previewContext.fillStyle = background;
        previewContext.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      } else if (background instanceof HTMLImageElement) {
        if (background.complete && background.naturalWidth > 0) {
          previewContext.drawImage(background, 0, 0, previewCanvas.width, previewCanvas.height);
        }
      }

      if (foregroundImage.complete && foregroundImage.naturalWidth > 0) {
        try {
          previewContext.drawImage(foregroundImage, 0, 0, previewCanvas.width, previewCanvas.height);
          console.log('Foreground image drawn to canvas successfully', {
            canvasWidth: previewCanvas.width,
            canvasHeight: previewCanvas.height,
            imageWidth: foregroundImage.naturalWidth,
            imageHeight: foregroundImage.naturalHeight
          });
        } catch (drawErr) {
          console.error('Error drawing image to canvas:', drawErr);
        }
      } else {
        console.error('drawComposite: Foreground image not ready', {
          complete: foregroundImage.complete,
          naturalWidth: foregroundImage.naturalWidth,
          naturalHeight: foregroundImage.naturalHeight,
          src: foregroundImage.src ? foregroundImage.src.substring(0, 50) + '...' : 'not set'
        });
        // Try to wait and retry
        if (!foregroundImage.complete) {
          console.log('Waiting for image to load...');
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, 2000);
            foregroundImage.onload = () => {
              clearTimeout(timeout);
              resolve();
            };
            foregroundImage.onerror = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (foregroundImage.complete && foregroundImage.naturalWidth > 0) {
            previewContext.drawImage(foregroundImage, 0, 0, previewCanvas.width, previewCanvas.height);
            console.log('Foreground image drawn after wait');
          }
        }
      }
      
      applyOverlay();
      
      // Update preview stage images (like workspace)
      const previewStage = document.getElementById('previewStage');
      const previewOriginal = document.getElementById('previewOriginal');
      const previewResult = document.getElementById('previewResult');
      const previewOverlay = document.getElementById('previewOverlay');
      const previewPlaceholder = document.getElementById('previewPlaceholder');
      
      if (previewCanvas && previewOriginal && previewResult && previewStage) {
        // Get styled result from canvas
        const styledDataURL = previewCanvas.toDataURL('image/png');
        
        // Update preview images
        if (previewOriginal) {
          const originalUrl = sessionStorage.getItem(STORAGE_KEYS.original) || foregroundDataUrl;
          if (originalUrl && !previewOriginal.src) {
            previewOriginal.src = originalUrl;
            previewOriginal.hidden = false;
          }
        }
        
        if (previewResult && styledDataURL) {
          previewResult.src = styledDataURL;
          previewResult.hidden = false;
        }
        
        // Show result (hide original)
        if (previewStage) {
          previewStage.classList.add('revealed');
          previewStage.classList.remove('empty');
        }
        
        if (previewOverlay) {
          previewOverlay.style.opacity = '0';
        }
        
        if (previewPlaceholder) {
          previewPlaceholder.classList.add('hidden');
        }
      }
      
      if (downloadBtn) downloadBtn.disabled = false;
      if (resetBtn) resetBtn.disabled = false;
      
      // Save styled image to current image in multiple images array
      if (multipleImages.length > 0 && currentImageIndex >= 0 && currentImageIndex < multipleImages.length) {
        const styledDataURL = previewCanvas.toDataURL('image/png');
        multipleImages[currentImageIndex].bgStyled = true;
        multipleImages[currentImageIndex].bgStyle = currentBackgroundRef || background;
        multipleImages[currentImageIndex].styledDataURL = styledDataURL;
        saveMultipleImages();
        updateImagesGrid();
      }
    }

    async function init() {
      if (!foregroundDataUrl || !dimensions) {
        console.error('Missing data:', { foregroundDataUrl: !!foregroundDataUrl, dimensions: !!dimensions });
        setStatus('Missing image data. Please go back and process the image again.');
        return;
      }
      try {
        // Check if user is premium
        let isPremium = false;
        if (auth && currentUser) {
          if (!userSubscription) {
            userSubscription = await checkUserSubscription(currentUser);
          }
          isPremium = userSubscription && 
                     (userSubscription.plan === 'premium' || userSubscription.plan === 'pro') && 
                     userSubscription.isValid;
        }
        
        // For free users, compress preview for faster background styling
        let previewUrl = foregroundDataUrl;
        if (!isPremium && foregroundDataUrl) {
          try {
            const previewData = await compressPreviewForRemoval(foregroundDataUrl);
            if (previewData.compressed) {
              previewUrl = previewData.dataURL;
              setStatus('Preview optimized for faster editing (400 KB). Original quality saved for download.');
              setTimeout(() => {
                setStatus('Background set to transparent. Choose a new style.');
              }, 3000);
            }
          } catch (compressErr) {
            console.warn('Compression failed, using original:', compressErr);
            previewUrl = foregroundDataUrl;
          }
        }
        
        if (previewUrl) {
          console.log('Loading foreground image from URL...');
          try {
            await loadImage(foregroundImage, previewUrl);
            console.log('Foreground image loaded:', {
              complete: foregroundImage.complete,
              naturalWidth: foregroundImage.naturalWidth,
              naturalHeight: foregroundImage.naturalHeight
            });
            
            // Ensure canvas dimensions match image if not already set
            if (previewCanvas.width === 0 || previewCanvas.height === 0) {
              if (foregroundImage.naturalWidth > 0 && foregroundImage.naturalHeight > 0) {
                previewCanvas.width = foregroundImage.naturalWidth;
                previewCanvas.height = foregroundImage.naturalHeight;
                console.log('Canvas dimensions set from image:', {
                  width: previewCanvas.width,
                  height: previewCanvas.height
                });
              }
            }
            
            // Initialize preview stage (like workspace)
            const previewStage = document.getElementById('previewStage');
            const previewOriginal = document.getElementById('previewOriginal');
            const previewResult = document.getElementById('previewResult');
            const previewOverlay = document.getElementById('previewOverlay');
            const previewPlaceholder = document.getElementById('previewPlaceholder');
            
            if (previewOriginal) {
              const originalUrl = sessionStorage.getItem(STORAGE_KEYS.original);
              if (originalUrl) {
                previewOriginal.src = originalUrl;
                previewOriginal.hidden = false;
              }
            }
            
            // Force canvas update
            await drawComposite('transparent');
            console.log('Preview drawn to canvas');
            
            // Update preview stage after drawing
            if (previewCanvas && previewResult && previewStage) {
              const styledDataURL = previewCanvas.toDataURL('image/png');
              if (styledDataURL && previewResult) {
                previewResult.src = styledDataURL;
                previewResult.hidden = false;
              }
              if (previewStage) {
                previewStage.classList.add('revealed');
                previewStage.classList.remove('empty');
              }
              if (previewOverlay) {
                previewOverlay.style.opacity = '0';
              }
              if (previewPlaceholder) {
                previewPlaceholder.classList.add('hidden');
              }
            }
            
            // Force a repaint to ensure visibility
            if (previewCanvas) {
              previewCanvas.style.display = 'none';
              previewCanvas.offsetHeight; // Trigger reflow
              previewCanvas.style.display = 'block';
            }
            
            if (isPremium || !previewUrl || previewUrl === foregroundDataUrl) {
              setStatus('Background set to transparent. Choose a new style.');
            }
          } catch (loadErr) {
            console.error('Error loading foreground image:', loadErr);
            setStatus('Failed to load image. Please try again.');
          }
        } else {
          throw new Error('No preview URL available');
        }
      } catch (err) {
        console.error('Failed to load foreground', err);
        setStatus('Failed to load the removed background. Please go back to workspace and process again.');
      }
    }

    function renderGrid(containerId, items) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      items.forEach((item) => {
        const div = document.createElement('div');
        div.className = 'thumb';
        const img = document.createElement('img');
        img.src = item.url;
        img.alt = item.label;
        const label = document.createElement('span');
        label.textContent = item.label;
        div.appendChild(img);
        div.appendChild(label);
        div.addEventListener('click', async () => {
          setStatus('Applying backgroundâ¦');
          try {
            await loadImage(backgroundImage, item.url + '&auto=compress&fit=crop&w=1200&q=80');
            document.querySelectorAll('.thumb').forEach((el) => el.classList.remove('selected'));
            div.classList.add('selected');
            await drawComposite(backgroundImage);
            setStatus(`Background set to ${item.label}.`);
          } catch (err) {
            console.error('Background load failed', err);
            setStatus('Unable to load that background. Please try another.');
          }
        });
        container.appendChild(div);
      });
    }

    function renderColours() {
      const container = document.getElementById('colorGrid');
      container.innerHTML = '';
      colorPalette.forEach((entry) => {
        if (entry.value === 'transparent') return; // handled in transparent tab
        const chip = document.createElement('div');
        chip.className = 'color-chip';
        const fill = document.createElement('div');
        fill.className = 'fill';
        fill.style.background = entry.value;
        chip.appendChild(fill);
        chip.addEventListener('click', () => {
          document.querySelectorAll('.color-chip').forEach((el) => el.classList.remove('selected'));
          chip.classList.add('selected');
          drawComposite(entry.value);
          setStatus(`Background colour set to ${entry.label}.`);
        });
        container.appendChild(chip);
      });
    }

    document.querySelectorAll('.tab-button').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach((b) => b.classList.remove('active'));
        btn.classList.add('active');
        document.querySelectorAll('.tab-content').forEach((panel) => {
          panel.hidden = panel.dataset.tab !== btn.dataset.tab;
        });
        if (btn.dataset.tab === 'transparent') {
          drawComposite('transparent');
          setStatus('Background set to transparent.');
        }
      });
    });

    resetBtn.addEventListener('click', () => {
      document.querySelectorAll('.thumb').forEach((el) => el.classList.remove('selected'));
      document.querySelectorAll('.color-chip').forEach((el) => el.classList.remove('selected'));
      drawComposite('transparent');
      setStatus('Reset to transparent background.');
      if (overlayToggle.checked) {
        overlayToggle.checked = false;
        overlayFields.classList.add('hidden');
        Object.assign(overlayState, { enabled: false, text: '' });
        overlayTextInput.value = '';
      }
    });

    // Modal functions
    function showDownloadModal() {
      const modal = document.getElementById('downloadModal');
      if (modal) {
        modal.classList.add('active');
      }
    }

    function closeDownloadModal() {
      const modal = document.getElementById('downloadModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    // Expose closeDownloadModal globally for onclick handler
    window.closeDownloadModal = closeDownloadModal;

    // Close modal on background click
    const downloadModal = document.getElementById('downloadModal');
    if (downloadModal) {
      downloadModal.addEventListener('click', (e) => {
        if (e.target === downloadModal) {
          closeDownloadModal();
        }
      });
    }

    // Helper functions for credit checking and API calls
    let creditModule = null;
    let subscriptionModule = null;
    let currentUserId = null;
    
    async function loadSubscriptionModule() {
      if (subscriptionModule) return subscriptionModule;
      try {
        subscriptionModule = await import('./js/subscription.js');
        return subscriptionModule;
      } catch (error) {
        console.warn('Failed to load subscription module:', error);
        return null;
      }
    }
    
    async function loadCreditModule() {
      if (creditModule) return creditModule;
      try {
        creditModule = await import('./js/credit-manager.js');
        return creditModule;
      } catch (error) {
        console.warn('Failed to load credit module:', error);
        return null;
      }
    }
    
    // Get current user ID - FIXED: Use Firebase auth directly (same as background-workspace.html)
    async function getCurrentUserId() {
      if (currentUserId) return currentUserId;
      
      try {
        // Import Firebase auth directly
        const firebaseInit = await import('./js/firebase-init.js');
        if (firebaseInit && firebaseInit.auth) {
          const auth = firebaseInit.auth;
          
          // Check current user first
          if (auth.currentUser) {
            currentUserId = auth.currentUser.uid;
            currentUser = auth.currentUser;
            return currentUserId;
          }
          
          // Wait for auth state with timeout
          const { onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js');
          
          return new Promise((resolve) => {
            const unsubscribe = onAuthStateChanged(auth, (user) => {
              unsubscribe();
              if (user) {
                currentUserId = user.uid;
                currentUser = user;
                resolve(user.uid);
              } else {
                resolve(null);
              }
            });
            
            // Timeout after 3 seconds
            setTimeout(() => {
              unsubscribe();
              resolve(null);
            }, 3000);
          });
        }
      } catch (error) {
        console.warn('Failed to get user ID:', error);
      }
      
      return currentUserId || null;
    }
    
    // Get auth token helper - FIXED: Use Firebase auth directly (same as background-workspace.html)
    async function getAuthToken() {
      try {
        // Import Firebase auth directly
        const firebaseInit = await import('./js/firebase-init.js');
        if (firebaseInit && firebaseInit.auth) {
          const auth = firebaseInit.auth;
          const user = auth.currentUser;
          
          if (user) {
            // Force token refresh to ensure it's valid
            return await user.getIdToken(true);
          }
          
          // Wait for auth state if not immediately available
          const { onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js');
          
          return new Promise((resolve) => {
            const unsubscribe = onAuthStateChanged(auth, async (user) => {
              unsubscribe();
              if (user) {
                try {
                  const token = await user.getIdToken(true);
                  resolve(token);
                } catch (error) {
                  console.warn('Failed to get token:', error);
                  resolve(null);
                }
              } else {
                resolve(null);
              }
            });
            
            // Timeout after 3 seconds
            setTimeout(() => {
              unsubscribe();
              resolve(null);
            }, 3000);
          });
        }
      } catch (error) {
        console.warn('Failed to get auth token:', error);
      }
      return null;
    }
    
    // Process with Premium HD API (2000-4000px BiRefNet GPU High-Resolution) - UPDATED to match background-workspace.html
    async function processWithPremiumHD(dataURL, targetSize = 'original') {
      try {
        // Validate image data before sending
        const validation = validateImageDataURL(dataURL);
        if (!validation.valid) {
          return {
            success: false,
            error: validation.error || 'Invalid image file. Please ensure you are uploading a valid image (JPG, PNG, etc.).'
          };
        }
        
        // Check credits first
        const subModule = await loadSubscriptionModule();
        const userId = await getCurrentUserId();
        
        if (!userId) {
          return {
            success: false,
            error: 'Please sign in to use Premium HD processing',
            requiresAuth: true
          };
        }
        
        // Get API base URL
        function getApiBaseUrl() {
          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            return 'http://localhost:3000';
          }
          return window.location.origin;
        }
        const API_BASE_URL = getApiBaseUrl();
        
        // Verify credits (this should be done on backend, but we check here for UX)
        setStatus('⚡ Processing with Premium HD (GPU-accelerated High-Resolution)... This may take 30-90 seconds.');
        
        const startTime = Date.now();
        
        // Progress indicator - update every 10 seconds for premium
        let progressInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          if (elapsed < 60) {
            setStatus(`⚡ Premium HD processing... (${elapsed}s) - Please wait, high-quality processing takes 30-90 seconds.`);
          } else if (elapsed < 180) {
            setStatus(`⏳ Premium HD processing... (${elapsed}s) - High-quality processing takes longer. Almost done...`);
          }
        }, 10000);
        
        // Add timeout for premium processing (5 minutes)
        const controller = new AbortController();
        const timeout = setTimeout(() => {
          clearInterval(progressInterval);
          controller.abort();
        }, 300000); // 5 minutes
        
        const response = await fetch(`${API_BASE_URL}/api/tools/bg-remove-premium`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${await getAuthToken()}`
          },
          // Parse target size
          let targetWidth = null;
          let targetHeight = null;
          if (targetSize && targetSize !== 'original') {
            const [width, height] = targetSize.split('x');
            targetWidth = parseInt(width);
            targetHeight = parseInt(height);
          }
          
          body: JSON.stringify({ 
            imageData: dataURL,
            userId: userId,
            targetSize: targetSize || 'original',
            targetWidth: targetWidth,
            targetHeight: targetHeight
          }),
          signal: controller.signal
        });
        
        clearTimeout(timeout);
        clearInterval(progressInterval);
        
        if (!response.ok) {
          let errorData = {};
          let errorText = '';
          
          try {
            errorText = await response.text();
            console.error('Premium API Error Response Text:', errorText);
            
            if (errorText) {
              try {
                errorData = JSON.parse(errorText);
              } catch (e) {
                errorData = { error: errorText };
              }
            }
          } catch (e) {
            console.error('Error reading premium response:', e);
            errorData = { error: `Failed to read error response: ${e.message}` };
          }
          
          // Extract error message
          let errorMsg = errorData.error || errorData.message || errorData.errorMessage || `Server error: ${response.status}`;
          
          if (response.status === 401) {
            return {
              success: false,
              error: 'Please sign in to use Premium HD processing.',
              requiresAuth: true
            };
          }
          
          if (response.status === 402 || errorMsg.includes('credit') || errorMsg.includes('insufficient')) {
            return {
              success: false,
              error: 'Insufficient credits. Please purchase credits to use Premium HD processing.',
              requiresCredits: true
            };
          }
          
          console.error('Premium API Error Details:', {
            status: response.status,
            statusText: response.statusText,
            errorData: errorData,
            errorText: errorText,
            finalError: errorMsg
          });
          
          throw new Error(errorMsg);
        }
        
        const result = await response.json();
        
        if (result.success && result.resultImage) {
          return {
            success: true,
            dataUrl: result.resultImage,
            processedWith: 'Premium HD (2000-4000px GPU-accelerated High-Resolution)',
            outputSize: result.outputSize,
            outputSizeMB: result.outputSizeMB,
            creditsUsed: result.creditsUsed
          };
        } else {
          throw new Error(result.error || 'Processing failed');
        }
      } catch (error) {
        // Clean up progress interval if still running
        if (typeof progressInterval !== 'undefined') {
          clearInterval(progressInterval);
        }
        
        console.error('Premium HD processing error:', error);
        console.error('Error type:', typeof error);
        console.error('Error details:', {
          name: error?.name,
          message: error?.message,
          stack: error?.stack,
          error: error
        });
        
        let errorMessage = 'Premium HD processing failed';
        
        // Extract error message properly
        if (error instanceof Error) {
          errorMessage = error.message || error.toString();
        } else if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && typeof error === 'object') {
          errorMessage = error.error || error.message || error.errorMessage || error.msg || JSON.stringify(error);
        }
        
        // Clean up error message
        if (errorMessage === '[object Object]' || errorMessage.includes('[object Object]')) {
          try {
            const errorObj = error && typeof error === 'object' ? error : {};
            errorMessage = errorObj.error || errorObj.message || errorObj.errorMessage || 'Premium HD processing failed. Please try again.';
          } catch (e) {
            errorMessage = 'Premium HD processing failed. Please try again.';
          }
        }
        
        // Handle timeout
        if (error.name === 'AbortError' || errorMessage.includes('timeout') || errorMessage.includes('aborted')) {
          errorMessage = 'Request timeout. Premium HD processing may take longer. Please try again with a smaller image or wait a moment.';
        }
        
        // Handle network errors
        if (errorMessage.includes('NetworkError') || errorMessage.includes('Failed to fetch') || errorMessage.includes('Network request failed')) {
          errorMessage = 'Network error. Please check your internet connection and try again.';
        }
        
        // Handle 404
        if (errorMessage.includes('404') || errorMessage.includes('not found')) {
          errorMessage = 'API endpoint not found (404). Please refresh the page (Ctrl+Shift+R) and try again.';
        }
        
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    
    // Validate image data URL format - COMPREHENSIVE VALIDATION (same as background-workspace.html)
    function validateImageDataURL(dataURL) {
      if (!dataURL || typeof dataURL !== 'string') {
        return { valid: false, error: 'Image data is invalid or missing' };
      }
      
      // Check minimum length
      if (dataURL.length < 100) {
        return { valid: false, error: 'Image data is too small or corrupted. Please try uploading again.' };
      }
      
      // Check if it's a data URL
      if (!dataURL.startsWith('data:image/')) {
        return { valid: false, error: 'Invalid image format. Please upload a valid image file (JPG, PNG, etc.).' };
      }
      
      // Check if it has base64 data
      if (!dataURL.includes(',')) {
        return { valid: false, error: 'Image data is incomplete. Please try uploading the image again.' };
      }
      
      // Extract base64 part
      const parts = dataURL.split(',');
      const base64Part = parts[1];
      
      if (!base64Part || base64Part.length < 100) {
        return { valid: false, error: 'Image data is too small or corrupted. Please try a different image.' };
      }
      
      // Check base64 format (should only contain valid base64 characters)
      const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
      if (!base64Regex.test(base64Part)) {
        return { valid: false, error: 'Invalid base64 format. Please try uploading the image again.' };
      }
      
      // Try to decode a sample to verify it's valid base64
      try {
        const sampleSize = Math.min(1000, base64Part.length);
        const sample = base64Part.substring(0, sampleSize);
        const decoded = atob(sample);
        if (!decoded || decoded.length === 0) {
          return { valid: false, error: 'Image data is corrupted. Please try uploading again.' };
        }
      } catch (e) {
        return { valid: false, error: 'Invalid image data format. Please upload a valid image file (JPG, PNG, etc.).' };
      }
      
      return { valid: true };
    }
    
    // Handle download with modal showing two options - UPDATED to match background-workspace.html
    async function handleDownload() {
      // Get the current canvas image as data URL
      const resultDataURL = previewCanvas.toDataURL('image/png', 1.0);
      
      // Get ORIGINAL high-quality image from storage (not preview)
      const originalResultURL = sessionStorage.getItem(STORAGE_KEYS.foreground) || resultDataURL;
      
      // Get image info from ORIGINAL quality
      const imageInfo = await getImageInfo(originalResultURL);
      const originalSize = imageInfo.size;
      const originalSizeKB = parseInt(imageInfo.sizeKB);
      
      console.log('?? Download requested');
      console.log('   Original size:', originalSizeKB, 'KB');
      console.log('   Dimensions:', imageInfo.width, 'x', imageInfo.height);
      
      // Check if user is premium (must be logged in with active Pro plan)
      let isPremium = false;
      if (auth && currentUser) {
        if (!userSubscription) {
          userSubscription = await checkUserSubscription(currentUser);
        }
        // Only active Pro plan users are premium
        isPremium = userSubscription && 
                   (userSubscription.plan === 'premium' || userSubscription.plan === 'pro') && 
                   userSubscription.isValid;
      }
      
      console.log('   User type:', isPremium ? 'Premium' : 'Free');
      
      // Calculate compressed size info (will be used for Free option)
      let compressedInfo = null;
      if (originalSizeKB > 150) {
        setStatus('⚡ Calculating compressed size...');
        const compressed = await compressImageForFree(originalResultURL, 150);
        compressedInfo = {
          dataURL: compressed.dataURL,
          width: compressed.width,
          height: compressed.height,
          size: compressed.size,
          sizeKB: (compressed.size / 1024).toFixed(0),
          sizeMB: (compressed.size / (1024 * 1024)).toFixed(2)
        };
        clearStatus();
      }
      
      // Build modal options
      const downloadOptions = document.getElementById('downloadOptions');
      downloadOptions.innerHTML = '';
      
      // Option 1: Compressed (Free) - Always available, under 150 KB
      const freeOption = document.createElement('div');
      freeOption.className = 'download-option';
      freeOption.innerHTML = `
        <div class="download-option-header">
          <div class="download-option-title">Compressed Size</div>
          <span class="download-option-badge free">FREE</span>
        </div>
        <div class="download-option-details">
          ${compressedInfo ? 
            `<strong>${compressedInfo.sizeKB} KB</strong> (${compressedInfo.sizeMB} MB)<br>` +
            `${compressedInfo.width} × ${compressedInfo.height} pixels<br>` +
            `<small>Auto-compressed to under 150 KB</small>` :
            `<strong>${imageInfo.sizeKB} KB</strong> (${imageInfo.sizeMB} MB)<br>` +
            `${imageInfo.width} × ${imageInfo.height} pixels<br>` +
            `<small>Already under 150 KB limit</small>`
          }
        </div>
      `;
      freeOption.addEventListener('click', async () => {
        closeDownloadModal();
        await downloadCompressed(resultDataURL, imageInfo, compressedInfo);
      });
      downloadOptions.appendChild(freeOption);
      
      // Option 2: Original/High Quality (Premium) - Only for Pro users
      const premiumOption = document.createElement('div');
      premiumOption.className = 'download-option';
      if (!isPremium) {
        premiumOption.classList.add('disabled');
      }
      premiumOption.innerHTML = `
        <div class="download-option-header">
          <div class="download-option-title">Original / High Quality</div>
          <span class="download-option-badge premium">PRO</span>
        </div>
        <div class="download-option-details">
          <strong>${imageInfo.sizeKB} KB</strong> (${imageInfo.sizeMB} MB)<br>
          ${imageInfo.width} × ${imageInfo.height} pixels<br>
          ${!isPremium ? 
            `<small style="color: #dc2626;">?? Requires active Pro/Premium plan</small>` :
            `<small style="color: #059669;">? Full quality, no compression</small>`
          }
        </div>
      `;
      premiumOption.addEventListener('click', async () => {
        if (isPremium) {
          closeDownloadModal();
          await downloadOriginal(originalResultURL, imageInfo);
        } else {
          // Show upgrade message
          const message = `Original Quality Download\n\n` +
                         `Size: ${imageInfo.sizeKB} KB (${imageInfo.sizeMB} MB)\n` +
                         `Dimensions: ${imageInfo.width} × ${imageInfo.height} pixels\n\n` +
                         `Free users: Max 150 KB (compressed)\n` +
                         `Your file: ${imageInfo.sizeKB} KB\n\n` +
                         `Upgrade to Pro/Premium for:\n` +
                         `? Unlimited download size\n` +
                         `? Original quality (no compression)\n` +
                         `? HD resolution\n` +
                         `? Faster processing`;
          
          if (!auth || !currentUser) {
            if (confirm(message + '\n\nLogin now to upgrade?')) {
              window.location.href = 'login.html';
            }
          } else {
            if (confirm(message + '\n\nView pricing plans?')) {
              window.location.href = 'pricing.html';
            }
          }
        }
      });
      downloadOptions.appendChild(premiumOption);
      
      // Show modal
      showDownloadModal();
    }

    // Download compressed version (Free) - UPDATED to match background-workspace.html
    async function downloadCompressed(resultDataURL, originalInfo, compressedInfo) {
      // Get original quality from storage
      const originalResultURL = sessionStorage.getItem(STORAGE_KEYS.foreground) || resultDataURL;
      
      let downloadDataURL = originalResultURL;
      let downloadInfo = originalInfo;
      let wasCompressed = false;
      
      // If file is > 150 KB, compress it
      if (parseInt(originalInfo.sizeKB) > 150) {
        if (compressedInfo && compressedInfo.dataURL) {
          // Use pre-calculated compressed version
          downloadDataURL = compressedInfo.dataURL;
          downloadInfo = compressedInfo;
          wasCompressed = true;
        } else {
          // Compress now
          setStatus('⚡ Compressing to 150 KB...');
          const compressed = await compressImageForFree(originalResultURL, 150);
          downloadDataURL = compressed.dataURL;
          downloadInfo = {
            width: compressed.width,
            height: compressed.height,
            size: compressed.size,
            sizeKB: (compressed.size / 1024).toFixed(0),
            sizeMB: (compressed.size / (1024 * 1024)).toFixed(2)
          };
          wasCompressed = true;
          clearStatus();
        }
      }
      
      // Download
      const link = document.createElement('a');
      const filename = sessionStorage.getItem(STORAGE_KEYS.filename) || 'background-styled.png';
      const baseName = filename.replace(/\.[^/.]+$/, '') || 'background-styled';
      link.href = downloadDataURL;
      link.download = wasCompressed ? `${baseName}-free.png` : (filename.endsWith('.png') ? filename : `${baseName}.png`);
      link.click();
      
      const sizeLabel = wasCompressed ? `${downloadInfo.sizeKB} KB (compressed from ${originalInfo.sizeKB} KB)` : `${downloadInfo.sizeKB} KB`;
      setStatus(`✅ Downloaded ${sizeLabel} - Free tier`);
      setTimeout(() => clearStatus(), 4000);
      
      // Increment device quota after successful download (free users only)
      if (!isPremium && deviceInfo) {
        try {
          const { incrementDeviceQuota } = await import('./js/device-fingerprint.js');
          await incrementDeviceQuota('imageRemover', 1, downloadInfo.size);
          console.log('✅ Device quota incremented for download');
        } catch (error) {
          console.warn('Failed to increment device quota:', error);
        }
      }
    }

    // Download original/high quality version (Premium)
    async function downloadOriginal(resultDataURL, imageInfo) {
      // Increment device quota after successful download (premium users)
      if (isPremium && deviceInfo) {
        try {
          const { incrementDeviceQuota } = await import('./js/device-fingerprint.js');
          await incrementDeviceQuota('imageRemover', 1, imageInfo.size);
          console.log('✅ Device quota incremented for premium download');
        } catch (error) {
          console.warn('Failed to increment device quota:', error);
        }
      }
      
      // Download original version
      const link = document.createElement('a');
      const filename = sessionStorage.getItem(STORAGE_KEYS.filename) || 'background-styled.png';
      link.href = resultDataURL;
      link.download = filename.endsWith('.png') ? filename : `${filename.replace(/\.[^/.]+$/, '') || 'background-styled'}.png`;
      link.click();
      
      setStatus(`✅ Downloaded (${imageInfo.sizeKB} KB, ${imageInfo.width}×${imageInfo.height}px) - Premium`);
      setTimeout(() => clearStatus(), 4000);
    }

    // ========== MULTIPLE IMAGES SUPPORT ==========
    
    // Check if user is premium
    async function checkPremiumUser() {
      try {
        const creditMod = await loadCreditModule();
        const userId = await getCurrentUserId();
        
        if (!userId) {
          isPremiumUser = false;
          return false;
        }
        
        if (creditMod && creditMod.getUserCredits) {
          const creditData = await creditMod.getUserCredits(userId);
          isPremiumUser = creditData.unlimited || (creditData.credits && creditData.credits > 0);
          return isPremiumUser;
        }
        
        // Fallback: check subscription
        if (userSubscription) {
          isPremiumUser = userSubscription && 
                         (userSubscription.plan === 'premium' || userSubscription.plan === 'pro') && 
                         userSubscription.isValid;
          return isPremiumUser;
        }
        
        isPremiumUser = false;
        return false;
      } catch (error) {
        console.error('Error checking premium status:', error);
        isPremiumUser = false;
        return false;
      }
    }
    
    // Load multiple images from session storage
    function loadMultipleImages() {
      try {
        const stored = sessionStorage.getItem(STORAGE_KEYS.multipleImages);
        if (stored) {
          multipleImages = JSON.parse(stored);
          updateImagesGrid();
        }
      } catch (error) {
        console.error('Error loading multiple images:', error);
        multipleImages = [];
      }
    }
    
    // Save multiple images to session storage
    function saveMultipleImages() {
      try {
        sessionStorage.setItem(STORAGE_KEYS.multipleImages, JSON.stringify(multipleImages));
      } catch (error) {
        console.error('Error saving multiple images:', error);
      }
    }
    
    // Update images grid display
    function updateImagesGrid() {
      const imagesGridContainer = document.getElementById('imagesGridContainer');
      const imageCount = document.getElementById('imageCount');
      const multipleImagesGrid = document.getElementById('multipleImagesGrid');
      
      if (!imagesGridContainer || !imageCount || !multipleImagesGrid) return;
      
      imageCount.textContent = multipleImages.length;
      
      if (multipleImages.length === 0) {
        multipleImagesGrid.style.display = 'none';
        return;
      }
      
      multipleImagesGrid.style.display = 'block';
      imagesGridContainer.innerHTML = '';
      
      multipleImages.forEach((img, index) => {
        const frame = document.createElement('div');
        frame.style.cssText = 'position: relative; width: 1cm; height: 1cm; border: 2px solid #e2e6ff; border-radius: 4px; overflow: hidden; cursor: pointer; background: #f8f9ff;';
        
        const imgElement = document.createElement('img');
        imgElement.src = img.resultURL || img.dataURL;
        imgElement.style.cssText = 'width: 100%; height: 100%; object-fit: cover; display: block;';
        frame.appendChild(imgElement);
        
        // Styled indicator
        if (img.bgStyled) {
          const checkmark = document.createElement('div');
          checkmark.style.cssText = 'position: absolute; top: 2px; right: 2px; background: #4361ee; color: white; border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px;';
          checkmark.innerHTML = '<i class="fas fa-palette"></i>';
          frame.appendChild(checkmark);
        }
        
        // Click to select image
        frame.onclick = () => {
          selectImage(index);
        };
        
        imagesGridContainer.appendChild(frame);
      });
      
      // Update buttons
      const hasStyled = multipleImages.some(img => img.bgStyled);
      const downloadAllBtn = document.getElementById('downloadAllBtn');
      if (downloadAllBtn) {
        downloadAllBtn.disabled = !hasStyled || multipleImages.length === 0;
      }
    }
    
    // Select image to edit
    async function selectImage(index) {
      if (index < 0 || index >= multipleImages.length) return;
      
      currentImageIndex = index;
      const img = multipleImages[index];
      
      // Load image into canvas
      const foregroundImg = new Image();
      foregroundImg.crossOrigin = 'anonymous';
      foregroundImg.src = img.resultURL || img.dataURL;
      await foregroundImg.decode();
      
      previewCanvas.width = foregroundImg.width;
      previewCanvas.height = foregroundImg.height;
      const ctx = previewCanvas.getContext('2d');
      ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      ctx.drawImage(foregroundImg, 0, 0);
      
      // If bg style already applied, restore it
      if (img.bgStyle) {
        await drawComposite(img.bgStyle);
      } else {
        await drawComposite('transparent');
      }
      
      setStatus(`Image ${index + 1} of ${multipleImages.length} selected`);
    }
    
    // Apply current bg style to all images
    async function applyBgStyleToAll() {
      if (multipleImages.length === 0) {
        setStatus('No images to apply background style to');
        return;
      }
      
      if (!isPremiumUser && multipleImages.length > 1) {
        if (confirm('Batch background style application is available for premium users only. Would you like to upgrade to premium?')) {
          window.location.href = 'pricing.html';
        }
        return;
      }
      
      const applyAllBtn = document.getElementById('applyBgToAllBtn');
      if (applyAllBtn) applyAllBtn.disabled = true;
      
      setStatus(`Applying background style to ${multipleImages.length} images...`);
      
      // Get current background style
      const currentBg = backgroundImage.src || 'transparent';
      const isTransparent = currentBg === 'transparent' || !currentBg || currentBg === 'data:image/png;base64,';
      const bgStyle = isTransparent ? 'transparent' : currentBg;
      
      let successCount = 0;
      
      for (let i = 0; i < multipleImages.length; i++) {
        try {
          setStatus(`Applying style to image ${i + 1} of ${multipleImages.length}...`);
          
          const img = multipleImages[i];
          const foregroundImg = new Image();
          foregroundImg.crossOrigin = 'anonymous';
          foregroundImg.src = img.resultURL || img.dataURL;
          await foregroundImg.decode();
          
          // Create canvas for this image
          const canvas = document.createElement('canvas');
          canvas.width = foregroundImg.width;
          canvas.height = foregroundImg.height;
          const ctx = canvas.getContext('2d');
          
          // Draw background
          if (!isTransparent && bgStyle !== 'transparent') {
            const bgImg = new Image();
            bgImg.crossOrigin = 'anonymous';
            bgImg.src = bgStyle;
            await bgImg.decode();
            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
          }
          
          // Draw foreground
          ctx.drawImage(foregroundImg, 0, 0);
          
          // Apply overlay if enabled
          if (overlayState.enabled && overlayState.text) {
            ctx.save();
            ctx.font = `${overlayState.fontWeight} ${overlayState.fontSize}px ${overlayState.fontFamily}`;
            ctx.fillStyle = overlayState.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const shadowBlur = overlayState.shadow;
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = shadowBlur;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            let x = canvas.width / 2 + overlayState.offsetX;
            let y = canvas.height / 2 + overlayState.offsetY;
            
            if (overlayState.position === 'top') y = 50 + overlayState.offsetY;
            else if (overlayState.position === 'bottom') y = canvas.height - 50 + overlayState.offsetY;
            else if (overlayState.position === 'left') { x = 50 + overlayState.offsetX; ctx.textAlign = 'left'; }
            else if (overlayState.position === 'right') { x = canvas.width - 50 + overlayState.offsetX; ctx.textAlign = 'right'; }
            
            ctx.fillText(overlayState.text, x, y);
            ctx.restore();
          }
          
          // Save styled image
          img.bgStyled = true;
          img.bgStyle = bgStyle;
          img.styledDataURL = canvas.toDataURL('image/png');
          successCount++;
        } catch (error) {
          console.error(`Error applying style to image ${i + 1}:`, error);
        }
      }
      
      saveMultipleImages();
      updateImagesGrid();
      if (applyAllBtn) applyAllBtn.disabled = false;
      
      setStatus(`✅ Background style applied to ${successCount} images!`);
    }
    
    // Download all styled images as ZIP
    async function downloadAllStyledImages() {
      if (!window.JSZip) {
        setStatus('ZIP library not loaded. Please refresh the page.');
        return;
      }
      
      const styledImages = multipleImages.filter(img => img.bgStyled);
      if (styledImages.length === 0) {
        setStatus('No styled images to download. Please apply background style first.');
        return;
      }
      
      if (!isPremiumUser && styledImages.length > 1) {
        if (confirm('Multiple image download is available for premium users only. Would you like to upgrade to premium?')) {
          window.location.href = 'pricing.html';
        }
        return;
      }
      
      try {
        setStatus('Creating ZIP file...');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        if (downloadAllBtn) downloadAllBtn.disabled = true;
        
        const zip = new JSZip();
        
        for (let i = 0; i < styledImages.length; i++) {
          const img = styledImages[i];
          const imgElement = new Image();
          imgElement.crossOrigin = 'anonymous';
          imgElement.src = img.styledDataURL;
          
          await new Promise((resolve, reject) => {
            imgElement.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = imgElement.width;
              canvas.height = imgElement.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(imgElement, 0, 0);
              
              canvas.toBlob((blob) => {
                const filename = img.filename || `image-${i + 1}.png`;
                const baseName = filename.replace(/\.[^/.]+$/, '') || `image-${i + 1}`;
                zip.file(`${baseName}-styled.png`, blob);
                resolve();
              }, 'image/png');
            };
            imgElement.onerror = reject;
          });
        }
        
        setStatus('Generating ZIP file...');
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(zipBlob);
        link.download = `background-styled-images-${new Date().getTime()}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        
        setStatus(`✅ Downloaded ${styledImages.length} styled images as ZIP file!`);
        if (downloadAllBtn) downloadAllBtn.disabled = false;
      } catch (error) {
        console.error('ZIP download error:', error);
        setStatus('Failed to create ZIP file: ' + error.message);
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        if (downloadAllBtn) downloadAllBtn.disabled = false;
      }
    }

    // Download Modal Management (matching background-workspace.html)
    const freeDownloadOption = document.getElementById('freeDownloadOption');
    const premiumDownloadOption = document.getElementById('premiumDownloadOption');
    const confirmDownloadBtn = document.getElementById('confirmDownload');
    const cancelDownloadBtn = document.getElementById('cancelDownload');
    const premiumCreditInfo = document.getElementById('premiumCreditInfo');
    const premiumCreditText = document.getElementById('premiumCreditText');
    
    let selectedDownloadQuality = null;
    let selectedPremiumSize = 'original'; // Default: preserve original size
    
    // Update premium credit info
    async function updatePremiumCreditInfo() {
      try {
        const creditMod = await loadCreditModule();
        const userId = await getCurrentUserId();
        
        if (!userId) {
          premiumCreditText.innerHTML = '<a href="login.html" style="color: #4361ee; text-decoration: underline;">Sign in</a> required for Premium HD';
          premiumCreditInfo.style.display = 'block';
          return;
        }
        
        if (creditMod && creditMod.getUserCredits) {
          const creditData = await creditMod.getUserCredits(userId);
          
          if (creditData.unlimited) {
            premiumCreditText.textContent = 'Premium plan active - Unlimited credits';
            premiumCreditText.style.color = '#22c55e';
          } else {
            const credits = creditData.credits || 0;
            if (credits > 0) {
              premiumCreditText.innerHTML = `You have <strong>${credits}</strong> credit(s) - <a href="pricing.html" style="color: #4361ee; text-decoration: underline;">Buy more</a>`;
              premiumCreditText.style.color = '#1f2559';
            } else {
              premiumCreditText.innerHTML = 'No credits - <a href="pricing.html" style="color: #4361ee; text-decoration: underline;">Purchase credits</a> for Premium HD';
              premiumCreditText.style.color = '#dc2626';
            }
          }
          premiumCreditInfo.style.display = 'block';
        }
      } catch (error) {
        console.error('Error checking credits:', error);
        premiumCreditText.textContent = 'Unable to check credits';
        premiumCreditText.style.color = '#dc2626';
        premiumCreditInfo.style.display = 'block';
      }
    }
    
    // Handle quality selection
    if (freeDownloadOption) {
      freeDownloadOption.addEventListener('click', () => {
        selectedDownloadQuality = 'free';
        freeDownloadOption.classList.add('selected');
        if (premiumDownloadOption) premiumDownloadOption.classList.remove('selected');
        const sizeSelection = document.getElementById('premiumSizeSelection');
        if (sizeSelection) {
          sizeSelection.classList.remove('active');
        }
        if (confirmDownloadBtn) confirmDownloadBtn.disabled = false;
      });
    }
    
    if (premiumDownloadOption) {
      premiumDownloadOption.addEventListener('click', async () => {
        const userId = await getCurrentUserId();
        if (!userId) {
          if (confirm('Please sign in to use Premium HD. Would you like to sign in now?')) {
            window.location.href = 'login.html?returnTo=' + encodeURIComponent(window.location.href);
          }
          return;
        }
        
        // Check credits
        const creditMod = await loadCreditModule();
        if (creditMod && creditMod.hasSufficientCredits) {
          const creditCheck = await creditMod.hasSufficientCredits(userId, 1);
          
          if (!creditCheck.hasCredits && !creditCheck.unlimited) {
            if (confirm(`You need 2 credits for Premium HD. You have ${creditCheck.creditsAvailable || 0} credit(s). Would you like to purchase credits?`)) {
              window.location.href = 'pricing.html#credits';
            }
            return;
          }
        }
        
        selectedDownloadQuality = 'premium';
        premiumDownloadOption.classList.add('selected');
        if (freeDownloadOption) freeDownloadOption.classList.remove('selected');
        
        // Show size selection
        const sizeSelection = document.getElementById('premiumSizeSelection');
        if (sizeSelection) {
          sizeSelection.classList.add('active');
        }
        
        if (confirmDownloadBtn) confirmDownloadBtn.disabled = false;
      });
      
      // Handle size selection change
      const premiumSizeSelect = document.getElementById('premiumSizeSelect');
      if (premiumSizeSelect) {
        premiumSizeSelect.addEventListener('change', (e) => {
          selectedPremiumSize = e.target.value;
          const sizeInfo = document.getElementById('premiumSizeInfo');
          if (sizeInfo) {
            if (selectedPremiumSize === 'original') {
              sizeInfo.textContent = 'Original resolution will be preserved if within 25 MP limit';
            } else {
              const [width, height] = selectedPremiumSize.split('x');
              const mp = ((parseInt(width) * parseInt(height)) / 1_000_000).toFixed(2);
              sizeInfo.textContent = `${width}×${height} pixels (${mp} MP) • 2 credits`;
            }
          }
        });
      }
    }
    
    // Cancel download modal
    if (cancelDownloadBtn) {
      cancelDownloadBtn.addEventListener('click', () => {
        closeDownloadModal();
        selectedDownloadQuality = null;
      });
    }
    
    // Handle confirm download
    if (confirmDownloadBtn) {
      confirmDownloadBtn.addEventListener('click', async () => {
        if (!selectedDownloadQuality) return;
        
        const resultDataURL = previewCanvas.toDataURL('image/png', 1.0);
        
        if (!resultDataURL) {
          setStatus('No processed image available. Please process an image first.');
          closeDownloadModal();
          return;
        }
        
        try {
          let finalDownloadUrl = resultDataURL;
          
          // If premium, process with premium HD first, then apply background style
          if (selectedDownloadQuality === 'premium') {
            const userId = await getCurrentUserId();
            if (!userId) {
              setStatus('Please sign in to use Premium HD download.');
              closeDownloadModal();
              return;
            }
            
            // Get original image data
            const originalDataUrl = sessionStorage.getItem(STORAGE_KEYS.original);
            if (!originalDataUrl) {
              setStatus('Original image not found. Please upload again.');
              closeDownloadModal();
              return;
            }
            
            // Process with premium HD - FIXED: Add processing indicator
            const processingOverlay = document.createElement('div');
            processingOverlay.id = 'premiumProcessingOverlay';
            processingOverlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:20px;';
            processingOverlay.innerHTML = `
              <div style="background:white;padding:32px;border-radius:20px;max-width:400px;text-align:center;box-shadow:0 24px 60px rgba(0,0,0,0.3);">
                <div style="font-size:48px;margin-bottom:16px;">⏳</div>
                <h3 style="color:#1a214d;margin:0 0 12px 0;font-size:1.3rem;">Processing Premium HD...</h3>
                <p style="color:#6f7694;margin:0 0 20px 0;line-height:1.6;">This may take 30-90 seconds. Please wait while we process your image with high-quality AI.</p>
                <div style="width:100%;height:4px;background:#f0f0f0;border-radius:2px;overflow:hidden;">
                  <div id="processingProgressBar" style="height:100%;background:linear-gradient(90deg,#4361ee,#3a0ca3);width:0%;transition:width 0.3s;animation:pulse 1.5s infinite;"></div>
                </div>
              </div>
            `;
            document.body.appendChild(processingOverlay);
            
            // Animate progress bar
            let progress = 0;
            const progressBar = document.getElementById('processingProgressBar');
            const progressInterval = setInterval(() => {
              progress += Math.random() * 15;
              if (progress > 90) progress = 90;
              if (progressBar) progressBar.style.width = progress + '%';
            }, 500);
            
            closeDownloadModal();
            
            console.log('Starting premium HD processing...', { userId, hasOriginalData: !!originalDataUrl });
            
            try {
              const premiumResult = await processWithPremiumHD(originalDataUrl, selectedPremiumSize);
              
              clearInterval(progressInterval);
              if (progressBar) progressBar.style.width = '100%';
              
              console.log('Premium HD processing result:', { success: premiumResult.success, error: premiumResult.error, requiresAuth: premiumResult.requiresAuth, requiresCredits: premiumResult.requiresCredits });
              
              if (premiumResult.success) {
                // Show credit deduction info
                const creditsUsed = premiumResult.creditsUsed || 2;
                const creditsRemaining = premiumResult.creditsRemaining;
                const creditInfo = creditsRemaining !== undefined 
                  ? ` (${creditsUsed} credit used, ${creditsRemaining} remaining)`
                  : ` (${creditsUsed} credit used)`;
                
                // Remove processing overlay
                if (processingOverlay && processingOverlay.parentNode) {
                  processingOverlay.parentNode.removeChild(processingOverlay);
                }
                
                setStatus(`✅ Premium HD processed successfully!${creditInfo}`);
                
                // Continue with background style application
              } else {
                // Remove processing overlay
                if (processingOverlay && processingOverlay.parentNode) {
                  processingOverlay.parentNode.removeChild(processingOverlay);
                }
                
                if (premiumResult.requiresAuth) {
                  if (confirm('Please sign in to use Premium HD. Would you like to sign in now?')) {
                    window.location.href = 'login.html?returnTo=' + encodeURIComponent(window.location.href);
                  }
                } else if (premiumResult.requiresCredits) {
                  if (confirm('Insufficient credits for Premium HD. Would you like to purchase credits?')) {
                    window.location.href = 'pricing.html#credits';
                  }
                } else {
                  setStatus(premiumResult.error || 'Premium HD processing failed');
                }
                return;
              }
            } catch (error) {
              clearInterval(progressInterval);
              if (processingOverlay && processingOverlay.parentNode) {
                processingOverlay.parentNode.removeChild(processingOverlay);
              }
              console.error('Premium HD processing error:', error);
              setStatus('Premium HD processing failed: ' + (error.message || 'Unknown error'));
              return;
            }
            
              // Apply background style to premium HD result - FIXED: Use currentBackgroundRef
              const premiumImg = new Image();
              premiumImg.crossOrigin = 'anonymous';
              premiumImg.src = premiumResult.dataUrl;
              await premiumImg.decode();
              
              // Get current background style - FIXED: Use currentBackgroundRef instead of backgroundImage.src
              const currentBg = currentBackgroundRef || backgroundImage.src || 'transparent';
              const isTransparent = currentBg === 'transparent' || !currentBg || currentBg === 'data:image/png;base64,' || currentBg === '';
              
              // Create canvas with premium HD dimensions
              const premiumCanvas = document.createElement('canvas');
              premiumCanvas.width = premiumImg.width;
              premiumCanvas.height = premiumImg.height;
              const premiumCtx = premiumCanvas.getContext('2d');
              
              // Draw background - FIXED: Properly handle transparent and colored backgrounds
              if (!isTransparent && currentBg && currentBg !== 'transparent' && currentBg !== '') {
                try {
                  const bgImg = new Image();
                  bgImg.crossOrigin = 'anonymous';
                  bgImg.src = currentBg;
                  await new Promise((resolve, reject) => {
                    bgImg.onload = resolve;
                    bgImg.onerror = () => {
                      console.warn('Background image failed to load, using transparent');
                      resolve(); // Continue with transparent background
                    };
                    setTimeout(() => resolve(), 5000); // Timeout after 5s
                  });
                  if (bgImg.complete && bgImg.naturalWidth > 0) {
                    premiumCtx.drawImage(bgImg, 0, 0, premiumCanvas.width, premiumCanvas.height);
                  }
                } catch (bgError) {
                  console.warn('Error loading background image:', bgError);
                  // Continue with transparent background
                }
              }
              
              // Draw foreground
              premiumCtx.drawImage(premiumImg, 0, 0);
              
              // Apply overlay if enabled
              if (overlayState.enabled && overlayState.text) {
                // Apply overlay (same logic as preview)
                premiumCtx.save();
                premiumCtx.font = `${overlayState.fontWeight} ${overlayState.fontSize}px ${overlayState.fontFamily}`;
                premiumCtx.fillStyle = overlayState.color;
                premiumCtx.textAlign = 'center';
                premiumCtx.textBaseline = 'middle';
                const shadowBlur = overlayState.shadow;
                premiumCtx.shadowColor = 'rgba(0,0,0,0.5)';
                premiumCtx.shadowBlur = shadowBlur;
                premiumCtx.shadowOffsetX = 0;
                premiumCtx.shadowOffsetY = 0;
                
                let x = premiumCanvas.width / 2 + overlayState.offsetX;
                let y = premiumCanvas.height / 2 + overlayState.offsetY;
                
                if (overlayState.position === 'top') y = 50 + overlayState.offsetY;
                else if (overlayState.position === 'bottom') y = premiumCanvas.height - 50 + overlayState.offsetY;
                else if (overlayState.position === 'left') { x = 50 + overlayState.offsetX; premiumCtx.textAlign = 'left'; }
                else if (overlayState.position === 'right') { x = premiumCanvas.width - 50 + overlayState.offsetX; premiumCtx.textAlign = 'right'; }
                
                premiumCtx.fillText(overlayState.text, x, y);
                premiumCtx.restore();
              }
              
              finalDownloadUrl = premiumCanvas.toDataURL('image/png');
          } else {
            // Free Preview: Download current canvas at 512px
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = resultDataURL;
            await img.decode();
            
            const freeCanvas = document.createElement('canvas');
            const maxSize = 512;
            let width = img.width;
            let height = img.height;
            
            if (width > maxSize || height > maxSize) {
              const scale = Math.min(maxSize / width, maxSize / height);
              width = Math.round(width * scale);
              height = Math.round(height * scale);
            }
            
            freeCanvas.width = width;
            freeCanvas.height = height;
            const freeCtx = freeCanvas.getContext('2d');
            freeCtx.drawImage(img, 0, 0, width, height);
            finalDownloadUrl = freeCanvas.toDataURL('image/png');
          }
          
          // Download the image
          const link = document.createElement('a');
          const filename = sessionStorage.getItem(STORAGE_KEYS.filename) || 'background-styled.png';
          const baseName = filename.replace(/\.[^/.]+$/, '') || 'background-styled';
          const qualitySuffix = selectedDownloadQuality === 'premium' ? '-premium-hd' : '-free-preview';
          link.href = finalDownloadUrl;
          link.download = `${baseName}${qualitySuffix}.png`;
          
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Show success message
          const qualityLabel = selectedDownloadQuality === 'premium' ? 'Premium HD – up to 25 Megapixels (2 Credit per image)' : 'Free Preview (512px)';
          const wasPremium = selectedDownloadQuality === 'premium';
          setStatus(`✅ ${qualityLabel} downloaded successfully!`);
          
          // Close modal
          closeDownloadModal();
          selectedDownloadQuality = null;
          
          // Update credit info if premium
          if (wasPremium) {
            await updatePremiumCreditInfo();
          }
        } catch (error) {
          console.error('Download error:', error);
          setStatus('Download failed. Please try again. Error: ' + error.message);
          closeDownloadModal();
        }
      });
    }
    
    // Update download button to show modal
    if (downloadBtn) {
      downloadBtn.addEventListener('click', async () => {
        const resultDataURL = previewCanvas.toDataURL('image/png', 1.0);
        
        if (!resultDataURL) {
          setStatus('No processed image available. Please process an image first.');
          return;
        }
        
        // Reset modal state
        selectedDownloadQuality = null;
        if (confirmDownloadBtn) confirmDownloadBtn.disabled = true;
        if (freeDownloadOption) freeDownloadOption.classList.remove('selected');
        if (premiumDownloadOption) premiumDownloadOption.classList.remove('selected');
        if (premiumCreditInfo) premiumCreditInfo.style.display = 'none';
        
        // Update premium credit info
        await updatePremiumCreditInfo();
        
        // Show modal
        showDownloadModal();
      });
    }

    if (backToPreview) {
      backToPreview.addEventListener('click', () => {
        window.location.href = 'background-workspace.html';
      });
    }
    
    // Multiple images event listeners
    const applyBgToAllBtn = document.getElementById('applyBgToAllBtn');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const clearAllImages = document.getElementById('clearAllImages');
    
    if (applyBgToAllBtn) {
      applyBgToAllBtn.addEventListener('click', applyBgStyleToAll);
    }
    
    if (downloadAllBtn) {
      downloadAllBtn.addEventListener('click', downloadAllStyledImages);
    }
    
    if (clearAllImages) {
      clearAllImages.addEventListener('click', () => {
        if (confirm('Clear all images?')) {
          multipleImages = [];
          saveMultipleImages();
          updateImagesGrid();
          window.location.href = 'background-workspace.html';
        }
      });
    }
    
    // Initialize premium check and update grid on page load
    (async () => {
      await checkPremiumUser();
      if (multipleImages.length > 0) {
        updateImagesGrid();
        // Select first image
        await selectImage(0);
      }
    })();

    if (overlayToggle) {
      overlayToggle.addEventListener('change', () => {
        overlayState.enabled = overlayToggle.checked;
        if (overlayFields) {
          overlayFields.classList.toggle('hidden', !overlayState.enabled);
        }
        if (overlayState.enabled && overlayTextInput) {
          overlayTextInput.focus();
        } else {
          overlayState.text = '';
          if (overlayTextInput) {
            overlayTextInput.value = '';
          }
        }
        drawComposite(currentBackgroundRef ?? 'transparent');
      });
    }

    function updateOverlayAndRender() {
      if (overlayTextInput) overlayState.text = overlayTextInput.value;
      if (overlayFontSelect) overlayState.fontFamily = overlayFontSelect.value;
      if (overlayWeightSelect) overlayState.fontWeight = Number(overlayWeightSelect.value);
      if (overlaySizeRange) overlayState.fontSize = Number(overlaySizeRange.value);
      if (overlayPositionSelect) overlayState.position = overlayPositionSelect.value;
      if (overlayOffsetX) overlayState.offsetX = Number(overlayOffsetX.value);
      if (overlayOffsetY) overlayState.offsetY = Number(overlayOffsetY.value);
      if (overlayColorInput) overlayState.color = overlayColorInput.value;
      if (overlayShadowRange) overlayState.shadow = Number(overlayShadowRange.value);
      if (overlaySizeValue) overlaySizeValue.textContent = `${overlayState.fontSize}px`;
      if (overlayShadowValue) overlayShadowValue.textContent = `${overlayState.shadow}px`;
      if (overlayOffsetXValue) overlayOffsetXValue.textContent = `${overlayState.offsetX}%`;
      if (overlayOffsetYValue) overlayOffsetYValue.textContent = `${overlayState.offsetY}%`;
      drawComposite(currentBackgroundRef ?? 'transparent');
    }

    if (overlayTextInput) overlayTextInput.addEventListener('input', updateOverlayAndRender);
    if (overlayFontSelect) overlayFontSelect.addEventListener('change', updateOverlayAndRender);
    if (overlayWeightSelect) overlayWeightSelect.addEventListener('change', updateOverlayAndRender);
    if (overlaySizeRange) overlaySizeRange.addEventListener('input', updateOverlayAndRender);
    if (overlayPositionSelect) overlayPositionSelect.addEventListener('change', updateOverlayAndRender);
    if (overlayOffsetX) overlayOffsetX.addEventListener('input', updateOverlayAndRender);
    if (overlayOffsetY) overlayOffsetY.addEventListener('input', updateOverlayAndRender);
    if (overlayColorInput) overlayColorInput.addEventListener('input', updateOverlayAndRender);
    if (overlayShadowRange) overlayShadowRange.addEventListener('input', updateOverlayAndRender);

    let currentBackgroundRef = 'transparent';

    function toggleManualControls() {
      const isManual = overlayState.position === 'manual';
      if (overlayManualX) overlayManualX.classList.toggle('hidden', !isManual);
      if (overlayManualY) overlayManualY.classList.toggle('hidden', !isManual);
    }

    if (overlayPositionSelect) {
      overlayPositionSelect.addEventListener('change', () => {
        overlayState.position = overlayPositionSelect.value;
        toggleManualControls();
      });
    }

    if (overlayOffsetX && overlayOffsetXValue) {
      overlayOffsetX.addEventListener('input', () => {
        overlayOffsetXValue.textContent = `${overlayOffsetX.value}%`;
      });
    }
    if (overlayOffsetY && overlayOffsetYValue) {
      overlayOffsetY.addEventListener('input', () => {
        overlayOffsetYValue.textContent = `${overlayOffsetY.value}%`;
      });
    }

    toggleManualControls();

    // Initialize after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        renderGrid('magicGrid', fallbackBackgrounds.magic);
        renderGrid('photoGrid', fallbackBackgrounds.photos);
        renderGrid('techGrid', fallbackBackgrounds.tech);
        renderColours();
        // Wait a bit for canvas to be ready
        setTimeout(() => {
          init();
        }, 100);
      });
    } else {
      renderGrid('magicGrid', fallbackBackgrounds.magic);
      renderGrid('photoGrid', fallbackBackgrounds.photos);
      renderGrid('techGrid', fallbackBackgrounds.tech);
      renderColours();
      // Wait a bit for canvas to be ready
      setTimeout(() => {
        init();
      }, 100);
    }

  const footerYearEl = document.getElementById('footerYear');
  if (footerYearEl) footerYearEl.textContent = new Date().getFullYear();
  </script>
    
<script src="js/auth.js" type="module"></script>

    <footer>
        <div class="container footer-inner">
            <div class="footer-company-links">
                <span>Company</span>
                <a href="index.html#about">About Us</a>
                <a href="index.html#contact">Contact</a>
                <a href="pricing.html">Pricing</a>
                <a href="privacy-policy.html">Privacy Policy</a>
                <a href="terms-of-service.html">Terms of Service</a>
                <a href="dmca-en.html">DMCA</a>
                <a href="blog.html">Blog</a>
            <a href="sitemap.xml">Sitemap</a>
                <a href="feedback.html">Feedback</a></div>
            <p class="footer-brand-line">&copy; easyjpgtopdf &mdash; Free PDF &amp; Image Tools for everyone. All rights reserved.</p>
                        <p class="footer-credits">
                Thanks to every open-source contributor powering this site. <a href="attributions.html">See full acknowledgements</a>.
            </p>
            <div class="footer-social-search" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; padding-top: 20px; border-top: 1px solid #444; flex-wrap: wrap; gap: 15px;">
                <div class="footer-social-links" style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                                        <a href="https://x.com/easyjpgtopdf" target="_blank" rel="noopener noreferrer" title="Follow us on X (Twitter)" style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; color: #aaa; text-decoration: none; transition: all 0.3s; border-radius: 50%;" onmouseover="this.style.color='#fff'; this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.color='#aaa'; this.style.background='transparent'">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                    </a>
                                        <a href="https://www.youtube.com/@EasyJpgtoPdf" target="_blank" rel="noopener noreferrer" title="Subscribe to our YouTube channel" style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; color: #aaa; text-decoration: none; transition: all 0.3s; border-radius: 50%;" onmouseover="this.style.color='#fff'; this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.color='#aaa'; this.style.background='transparent'">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                        </svg>
                    </a>
                    <div style="display: inline-flex; align-items: center; gap: 8px; color: #aaa; cursor: default;" title="Mobile App Coming Soon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.05 20.28c-.98.95-2.05.88-3.08.4-1.09-.5-2.08-.95-3.24-1.44-2.24-1.01-4.33-1.95-5.99-3.22C2.79 14.25.99 12.12.99 9.12c0-2.23 1.21-4.15 3.29-5.19.4-.2.81-.38 1.24-.52.7-.23 1.23-.52 1.62-.82.49-.38.85-.88 1.06-1.46.19-.57.24-1.17.14-1.8-.09-.63-.29-1.24-.58-1.81L7.76.36c.16-.24.35-.45.57-.62.22-.17.46-.3.72-.4.26-.1.54-.15.82-.15.28 0 .56.05.82.15.26.1.5.23.72.4.22.17.41.38.57.62l1.39 2.06c.29.57.49 1.18.58 1.81.1.63.05 1.23-.14 1.8-.21.58-.57 1.08-1.06 1.46-.39.3-.92.59-1.62.82-.43.14-.84.32-1.24.52-2.08 1.04-3.29 2.96-3.29 5.19 0 3 1.8 5.13 4.5 6.5 1.66 1.27 3.75 2.21 5.99 3.22 1.16.49 2.15.94 3.24 1.44 1.03.48 2.1.55 3.08-.4 1.01-.98 1.01-2.4.01-3.38z"/>
                        </svg>
                        <span style="font-size: 0.9rem;">App Coming Soon</span>
                    </div>
                </div>
                <div class="footer-search" style="flex: 1; min-width: 200px; max-width: 300px;">
                                        <form action="search.html" method="get" style="display: flex; gap: 5px;">
                        <input type="text" name="q" placeholder="Search our site..." style="flex: 1; padding: 8px 12px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 0.9rem; outline: none;" onfocus="this.style.borderColor='#4361ee'" onblur="this.style.borderColor='#555'">
                        <button type="submit" style="padding: 8px 15px; background: #4361ee; border: none; border-radius: 4px; color: #fff; cursor: pointer; transition: background 0.3s;" onmouseover="this.style.background='#3a0ca3'" onmouseout="this.style.background='#4361ee'">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                            </svg>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </footer>
    <script src="js/global-components.js"></script>
    <script>
    // Ensure header loads - multiple attempts to guarantee it works
    (function() {
        function tryLoadHeader() {
            if (typeof loadGlobalHeader === 'function') {
                try {
                    loadGlobalHeader();
                    return true;
                } catch (e) {
                    console.error('Error calling loadGlobalHeader:', e);
                }
            }
            return false;
        }
        
        // Try immediately if script already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            if (!tryLoadHeader()) {
                // Script not loaded yet, wait for it
                var attempts = 0;
                var maxAttempts = 60; // 3 seconds total
                var checkHeader = setInterval(function() {
                    attempts++;
                    if (tryLoadHeader() || attempts >= maxAttempts) {
                        clearInterval(checkHeader);
                    }
                }, 50);
            }
        } else {
            // Wait for DOM to be ready
            document.addEventListener('DOMContentLoaded', function() {
                if (!tryLoadHeader()) {
                    var attempts = 0;
                    var maxAttempts = 40;
                    var checkHeader = setInterval(function() {
                        attempts++;
                        if (tryLoadHeader() || attempts >= maxAttempts) {
                            clearInterval(checkHeader);
                        }
                    }, 50);
                }
            });
        }
        
        // Final backup attempt on window load
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (!document.querySelector('header') && typeof loadGlobalHeader === 'function') {
                    loadGlobalHeader();
                }
            }, 100);
        });
    })();
    </script>

        
</body>
</html>
